# Graph MVCC Visibility
# Graph-specific visibility helpers wrapping the unified is_visible() function
# Provides snapshot-consistent traversal support for graph operations
# Based on Stage 3 Section 3: unified 3-case visibility + is_aborted fast-path

U storage/txn/snapshot.{Snapshot};
U storage/txn/clog.{Clog};
U storage/txn/visibility.{is_edge_visible, is_tuple_visible};
U storage/constants.{INVALID_TXN_ID};
U graph/types.{AdjEntry, GraphNode};

# ============================================================================
# Node Visibility — Check if a GraphNode is visible to the snapshot
# ============================================================================

# Check if a graph node is visible under the given MVCC snapshot
F is_node_visible(node: &GraphNode, snapshot: &Snapshot, clog: &Clog) -> bool {
    is_tuple_visible(
        node.txn_id_create,
        node.txn_id_expire,
        node.cmd_id,
        node.expire_cmd_id,
        snapshot,
        clog,
    )
}

# ============================================================================
# Edge Visibility — Check if an AdjEntry is visible to the snapshot
# ============================================================================

# Check if an adjacency list entry (edge) is visible under the given MVCC snapshot
F is_adj_entry_visible(entry: &AdjEntry, snapshot: &Snapshot, clog: &Clog) -> bool {
    is_edge_visible(
        entry.txn_id_create,
        entry.txn_id_expire,
        entry.cmd_id,
        entry.expire_cmd_id,
        snapshot,
        clog,
    )
}

# ============================================================================
# Filtered Adjacency Scan — Return only visible edges from a list
# ============================================================================

# Filter a list of adjacency entries to only those visible to the snapshot
# Used during traversal to ensure snapshot-consistent edge reads
F filter_visible_entries(
    entries: &Vec<AdjEntry>,
    snapshot: &Snapshot,
    clog: &Clog,
) -> Vec<AdjEntry> {
    ~result = Vec.new();
    ~i: u64 = 0;
    L while i < entries.len() {
        I is_adj_entry_visible(&entries[i], snapshot, clog) {
            result.push(entries[i]);
        }
        i += 1;
    }
    result
}

# ============================================================================
# Visibility Helpers for Traversal
# ============================================================================

# Check if a node is visible AND active (not soft-deleted within the snapshot)
# This combines MVCC visibility with the active flag check
F is_node_accessible(node: &GraphNode, snapshot: &Snapshot, clog: &Clog) -> bool {
    I !is_node_visible(node, snapshot, clog) {
        R false;
    }
    node.is_active()
}

# Filter entries by edge type, returning only visible ones
F filter_visible_by_type(
    entries: &Vec<AdjEntry>,
    edge_type: u16,
    snapshot: &Snapshot,
    clog: &Clog,
) -> Vec<AdjEntry> {
    ~result = Vec.new();
    ~i: u64 = 0;
    L while i < entries.len() {
        I entries[i].edge_type == edge_type && is_adj_entry_visible(&entries[i], snapshot, clog) {
            result.push(entries[i]);
        }
        i += 1;
    }
    result
}

# Filter entries by target node, returning only visible ones
F filter_visible_by_target(
    entries: &Vec<AdjEntry>,
    target_node: u64,
    snapshot: &Snapshot,
    clog: &Clog,
) -> Vec<AdjEntry> {
    ~result = Vec.new();
    ~i: u64 = 0;
    L while i < entries.len() {
        I entries[i].target_node == target_node && is_adj_entry_visible(&entries[i], snapshot, clog) {
            result.push(entries[i]);
        }
        i += 1;
    }
    result
}

# Count visible edges from an adjacency list
F count_visible_entries(
    entries: &Vec<AdjEntry>,
    snapshot: &Snapshot,
    clog: &Clog,
) -> u64 {
    ~count: u64 = 0;
    ~i: u64 = 0;
    L while i < entries.len() {
        I is_adj_entry_visible(&entries[i], snapshot, clog) {
            count += 1;
        }
        i += 1;
    }
    count
}

# Get visible neighbor node IDs from adjacency entries
F visible_neighbor_ids(
    entries: &Vec<AdjEntry>,
    snapshot: &Snapshot,
    clog: &Clog,
) -> Vec<u64> {
    ~result = Vec.new();
    ~i: u64 = 0;
    L while i < entries.len() {
        I is_adj_entry_visible(&entries[i], snapshot, clog) {
            result.push(entries[i].target_node);
        }
        i += 1;
    }
    result
}
