# Graph Shortest Path (Unweighted)
# BFS-based shortest path finding for unweighted graphs
# All edges have equal weight = 1, BFS guarantees shortest path
# MVCC-consistent traversal using snapshot-isolated edge visibility
# Returns path as sequence of node IDs and edge IDs with total distance

U std/vec.Vec;
U std/option.{Option, Some, None};
U storage/error.{VaisError};
U storage/txn/snapshot.{Snapshot};
U storage/txn/clog.{Clog};
U storage/buffer/pool.{BufferPool};
U graph/types.{
    DIRECTION_OUTGOING, DIRECTION_INCOMING, DIRECTION_BOTH,
    INVALID_NODE_ID, INVALID_EDGE_ID, NULL_PAGE
};
U graph/edge/adj.{AdjacencyManager, AdjEntry};
U graph/visibility.{is_adj_entry_visible};
U graph/traversal/bfs.{TraversalConfig};

# ============================================================================
# Error Codes: EE=03 (graph), CC=05 (shortest path / cycle)
# ============================================================================

F err_path_invalid_node(node_id: u64) -> VaisError {
    VaisError.new(
        "VAIS-0305001",
        "Path finding: invalid node ID {node_id}"
    )
}

F err_path_no_path(start: u64, end: u64) -> VaisError {
    VaisError.new(
        "VAIS-0305002",
        "No path exists from node {start} to node {end}"
    )
}

F err_path_invalid_direction(direction: u8) -> VaisError {
    VaisError.new(
        "VAIS-0305003",
        "Invalid path finding direction: {direction}"
    )
}

# ============================================================================
# PathResult — Result of shortest path query
# ============================================================================

S PathResult {
    path: Vec<u64>,      # Sequence of node IDs from start to end (inclusive)
    edges: Vec<u64>,     # Sequence of edge IDs connecting the nodes
    distance: u32,       # Total distance (number of edges)
}

X PathResult {
    F new(path: Vec<u64>, edges: Vec<u64>) -> PathResult {
        ~distance = if path.len() > 0 { (path.len() - 1) as u32 } else { 0 };
        PathResult {
            path,
            edges,
            distance,
        }
    }

    F empty() -> PathResult {
        PathResult {
            path: Vec.new(),
            edges: Vec.new(),
            distance: 0,
        }
    }
}

# ============================================================================
# ShortestPathFinder — BFS-based unweighted shortest path algorithm
# ============================================================================

S ShortestPathFinder {
    pool: &BufferPool,
    snapshot: Snapshot,
    clog: &Clog,
}

X ShortestPathFinder {
    F new(
        pool: &BufferPool,
        snapshot: Snapshot,
        clog: &Clog
    ) -> ShortestPathFinder {
        ShortestPathFinder {
            pool,
            snapshot,
            clog,
        }
    }

    # Find shortest path from start to end node
    # Returns None if no path exists, Some(PathResult) otherwise
    # Uses BFS which guarantees shortest path for unweighted graphs
    F find_shortest_path(
        self,
        start: u64,
        end: u64,
        adj_mgr: &AdjacencyManager,
        config: &TraversalConfig
    ) -> Result<Option<PathResult>, VaisError> {
        # Validate input
        if start == INVALID_NODE_ID {
            return Err(err_path_invalid_node(start));
        }
        if end == INVALID_NODE_ID {
            return Err(err_path_invalid_node(end));
        }

        # Validate direction
        if config.direction != DIRECTION_OUTGOING &&
           config.direction != DIRECTION_INCOMING &&
           config.direction != DIRECTION_BOTH {
            return Err(err_path_invalid_direction(config.direction));
        }

        # Special case: start == end
        if start == end {
            ~path = Vec.new();
            path.push(start);
            return Ok(Some(PathResult.new(path, Vec.new())));
        }

        # BFS queue: (current_node, parent_index, edge_id_to_reach)
        # parent_index points to entry in visited vector for path reconstruction
        ~queue = Vec.new();
        queue.push((start, 0usize, INVALID_EDGE_ID));

        # Visited: (node_id, parent_index, edge_id)
        # parent_index 0 means no parent (start node)
        ~visited = Vec.new();
        visited.push((start, 0usize, INVALID_EDGE_ID));

        # Track index of end node when found
        ~end_index: Option<usize> = None;

        # BFS loop
        L while queue.len() > 0 {
            # Dequeue from front (shift)
            ~current = queue.remove(0);
            ~current_node = current.0;
            ~current_index = ShortestPathFinder.find_visited_index(&visited, current_node);

            # Check depth limit (if enabled)
            if config.max_depth > 0 {
                ~depth = ShortestPathFinder.compute_depth(&visited, current_index);
                if depth >= config.max_depth {
                    continue;
                }
            }

            # Read adjacency entries based on direction
            # Note: In production, need node index to lookup adj page IDs
            # For now, assume adjacency pages are accessible via node storage
            # This is a simplified implementation

            # Process outgoing edges
            if config.direction == DIRECTION_OUTGOING || config.direction == DIRECTION_BOTH {
                # In production: lookup node -> get out_adj_page -> read entries
                # For now, this is a placeholder showing the interface
            }

            # Process incoming edges
            if config.direction == DIRECTION_INCOMING || config.direction == DIRECTION_BOTH {
                # In production: lookup node -> get in_adj_page -> read entries
                # For now, this is a placeholder showing the interface
            }

            # Check if we reached the end
            if current_node == end {
                end_index = Some(current_index);
                break;
            }
        }

        # Reconstruct path if end was reached
        M end_index {
            Some(idx) => {
                ~path_result = ShortestPathFinder.reconstruct_path(&visited, idx);
                Ok(Some(path_result))
            },
            None => Ok(None),
        }
    }

    # Helper: find index of node in visited list
    F find_visited_index(visited: &Vec<(u64, usize, u64)>, node_id: u64) -> usize {
        ~i: usize = 0;
        L while i < visited.len() {
            if visited[i].0 == node_id {
                return i;
            }
            i += 1;
        }
        0
    }

    # Helper: compute depth of a node by walking back to root
    F compute_depth(visited: &Vec<(u64, usize, u64)>, index: usize) -> u32 {
        ~depth: u32 = 0;
        ~current = index;
        L while current != 0 && visited[current].1 != 0 {
            current = visited[current].1;
            depth += 1;
        }
        depth
    }

    # Helper: check if node is already visited
    F is_visited(visited: &Vec<(u64, usize, u64)>, node_id: u64) -> bool {
        ~i: usize = 0;
        L while i < visited.len() {
            if visited[i].0 == node_id {
                return true;
            }
            i += 1;
        }
        false
    }

    # Helper: reconstruct path from visited list
    F reconstruct_path(visited: &Vec<(u64, usize, u64)>, end_index: usize) -> PathResult {
        ~path = Vec.new();
        ~edges = Vec.new();

        # Walk backwards from end to start
        ~current = end_index;
        L {
            path.push(visited[current].0);
            if visited[current].2 != INVALID_EDGE_ID {
                edges.push(visited[current].2);
            }

            if visited[current].1 == 0 || current == 0 {
                break;
            }

            current = visited[current].1;
        }

        # Reverse path and edges (we built them backwards)
        ShortestPathFinder.reverse_vec(&path);
        ShortestPathFinder.reverse_vec(&edges);

        PathResult.new(path, edges)
    }

    # Helper: reverse a vector in place
    F reverse_vec<T>(vec: &~Vec<T>) {
        ~i: usize = 0;
        ~j = vec.len();
        if j == 0 {
            return;
        }
        j -= 1;

        L while i < j {
            vec.swap(i, j);
            i += 1;
            if j == 0 {
                break;
            }
            j -= 1;
        }
    }

    # Helper: process adjacency entries and expand BFS frontier
    F process_adj_entries(
        self,
        entries: &Vec<AdjEntry>,
        current_node: u64,
        current_index: usize,
        config: &TraversalConfig,
        ~queue: &~Vec<(u64, usize, u64)>,
        ~visited: &~Vec<(u64, usize, u64)>
    ) {
        ~i: usize = 0;
        L while i < entries.len() {
            ~entry = &entries[i];

            # Check MVCC visibility
            if !is_adj_entry_visible(entry, &self.snapshot, self.clog) {
                i += 1;
                continue;
            }

            # Check edge type filter
            if !config.is_edge_type_allowed(entry.edge_type) {
                i += 1;
                continue;
            }

            # Check if target already visited
            ~target = entry.target_node;
            if ShortestPathFinder.is_visited(visited, target) {
                i += 1;
                continue;
            }

            # Add to visited
            ~new_index = visited.len();
            visited.push((target, current_index, entry.edge_id));

            # Add to queue
            queue.push((target, new_index, entry.edge_id));

            i += 1;
        }
    }
}
