# Graph DFS Traversal
# Depth-First Search with MVCC snapshot-consistent edge visibility
# Stack-based traversal with visited set for cycle prevention
# Supports edge type filtering and directional traversal

U std/vec.Vec;
U std/option.{Option, Some, None};
U storage/error.{VaisError};
U storage/txn/snapshot.{Snapshot};
U storage/txn/clog.{Clog};
U storage/buffer/pool.{BufferPool};
U storage/page/allocator.{PageAllocator};
U storage/page/freelist.{FreelistBitmap};
U graph/types.{
    DIRECTION_OUTGOING, DIRECTION_INCOMING, DIRECTION_BOTH,
    INVALID_NODE_ID, INVALID_EDGE_ID, NULL_PAGE
};
U graph/node/storage.{NodeStore};
U graph/edge/adj.{AdjacencyManager, AdjEntry};
U graph/visibility.{is_adj_entry_visible};
U graph/traversal/bfs.{
    TraversalStep, TraversalResult, TraversalConfig,
    err_traversal_invalid_node, err_traversal_invalid_direction
};

# ============================================================================
# DfsTraversal â€” Depth-First Search engine
# ============================================================================

S DfsTraversal {
    pool: &BufferPool,
    node_store: &NodeStore,
    snapshot: Snapshot,
    clog: &Clog,
}

X DfsTraversal {
    F new(
        pool: &BufferPool,
        node_store: &NodeStore,
        snapshot: Snapshot,
        clog: &Clog
    ) -> DfsTraversal {
        DfsTraversal {
            pool,
            node_store,
            snapshot,
            clog,
        }
    }

    # Perform DFS traversal from start_node
    # Note: This requires a node index to map node_id -> (page_id, slot_index)
    # For now, we implement the core DFS logic assuming AdjacencyManager can read adj lists
    F traverse(
        self,
        start_node: u64,
        adj_mgr: &AdjacencyManager,
        config: &TraversalConfig
    ) -> Result<TraversalResult, VaisError> {
        I start_node == INVALID_NODE_ID {
            R Err(err_traversal_invalid_node(start_node));
        }

        # Validate direction
        I config.direction != DIRECTION_OUTGOING &&
           config.direction != DIRECTION_INCOMING &&
           config.direction != DIRECTION_BOTH {
            R Err(err_traversal_invalid_direction(config.direction));
        }

        # Initialize result
        ~result = TraversalResult.new();

        # Stack: (node_id, depth)
        ~stack = Vec.new();
        stack.push((start_node, 0u32));

        # Visited set: Vec<u64> for cycle prevention
        ~visited = Vec.new();
        visited.push(start_node);

        # Add start node to result
        result.add_step(TraversalStep.root(start_node));

        # DFS loop
        W stack.len() > 0 {
            # Pop from stack (from end)
            ~stack_len = stack.len();
            ~current = stack[stack_len - 1];
            stack.remove(stack_len - 1);
            ~current_node = current.0;
            ~current_depth = current.1;

            # Check depth limit -- skip expansion if at max depth
            I config.max_depth == 0 || current_depth < config.max_depth {
                # Look up node to get adjacency page IDs
                ~node = self.node_store.read_node(current_node)?;

                # Process outgoing edges
                I config.direction == DIRECTION_OUTGOING || config.direction == DIRECTION_BOTH {
                    I node.out_adj_page != NULL_PAGE {
                        ~out_entries = adj_mgr.read_all_entries(node.out_adj_page)?;
                        self.process_edges(&out_entries, current_node, current_depth, config, &stack, &visited, &result);
                    }
                }

                # Process incoming edges
                I config.direction == DIRECTION_INCOMING || config.direction == DIRECTION_BOTH {
                    I node.in_adj_page != NULL_PAGE {
                        ~in_entries = adj_mgr.read_all_entries(node.in_adj_page)?;
                        self.process_edges(&in_entries, current_node, current_depth, config, &stack, &visited, &result);
                    }
                }
            }
        }

        Ok(result)
    }

    # Helper: check if node is already visited
    F is_visited(visited: &Vec<u64>, node_id: u64) -> bool {
        ~i: u64 = 0;
        W i < visited.len() {
            I visited[i] == node_id {
                R true;
            }
            i += 1;
        }
        false
    }

    # Helper: process edges from adjacency list
    F process_edges(
        self,
        entries: &Vec<AdjEntry>,
        current_node: u64,
        current_depth: u32,
        config: &TraversalConfig,
        ~stack: &~Vec<(u64, u32)>,
        ~visited: &~Vec<u64>,
        ~result: &~TraversalResult
    ) {
        ~next_depth = current_depth + 1;

        ~i: u64 = 0;
        W i < entries.len() {
            ~entry = &entries[i];

            # Check MVCC visibility, edge type filter, and already-visited
            I is_adj_entry_visible(entry, &self.snapshot, self.clog)
                && config.is_edge_type_allowed(entry.edge_type) {
                ~target = entry.target_node;
                I !DfsTraversal.is_visited(visited, target) {
                    # Mark as visited
                    visited.push(target);

                    # Add to stack (push to end)
                    stack.push((target, next_depth));

                    # Add to result
                    ~step = TraversalStep.from_edge(
                        target,
                        next_depth,
                        current_node,
                        entry.edge_id,
                        entry.edge_type
                    );
                    result.add_step(step);
                }
            }

            i += 1;
        }
    }
}
