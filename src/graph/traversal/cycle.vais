# Graph Cycle Detection
# DFS-based cycle detection using 3-color algorithm
# White = unvisited, Gray = in recursion stack, Black = finished
# MVCC-consistent traversal using snapshot-isolated edge visibility
# Supports both single cycle detection and finding multiple cycles

U std/vec.Vec;
U std/option.{Option, Some, None};
U storage/error.{VaisError};
U storage/txn/snapshot.{Snapshot};
U storage/txn/clog.{Clog};
U storage/buffer/pool.{BufferPool};
U graph/types.{
    DIRECTION_OUTGOING, DIRECTION_INCOMING, DIRECTION_BOTH,
    INVALID_NODE_ID, INVALID_EDGE_ID, NULL_PAGE
};
U graph/edge/adj.{AdjacencyManager, AdjEntry};
U graph/visibility.{is_adj_entry_visible};
U graph/traversal/bfs.{TraversalConfig};

# ============================================================================
# Error Codes: EE=03 (graph), CC=05 (shortest path / cycle)
# ============================================================================

F err_cycle_invalid_node(node_id: u64) -> VaisError {
    VaisError.new(
        "VAIS-0305004",
        "Cycle detection: invalid node ID {node_id}"
    )
}

F err_cycle_invalid_direction(direction: u8) -> VaisError {
    VaisError.new(
        "VAIS-0305005",
        "Invalid cycle detection direction: {direction}"
    )
}

F err_cycle_max_cycles_reached(max_cycles: u32) -> VaisError {
    VaisError.new(
        "VAIS-0305006",
        "Maximum cycle limit reached: {max_cycles}"
    )
}

# ============================================================================
# Node colors for DFS cycle detection
# ============================================================================

L COLOR_WHITE: u8 = 0;  # Unvisited
L COLOR_GRAY: u8 = 1;   # In recursion stack (active DFS path)
L COLOR_BLACK: u8 = 2;  # Finished (all descendants explored)

# ============================================================================
# CycleResult — Result of cycle detection
# ============================================================================

S CycleResult {
    nodes: Vec<u64>,     # Sequence of node IDs forming the cycle
    edges: Vec<u64>,     # Sequence of edge IDs connecting the cycle nodes
    length: u32,         # Cycle length (number of edges)
}

X CycleResult {
    F new(nodes: Vec<u64>, edges: Vec<u64>) -> CycleResult {
        ~length = edges.len() as u32;
        CycleResult {
            nodes,
            edges,
            length,
        }
    }

    F empty() -> CycleResult {
        CycleResult {
            nodes: Vec.new(),
            edges: Vec.new(),
            length: 0,
        }
    }
}

# ============================================================================
# CycleDetector — DFS-based cycle detection algorithm
# ============================================================================

S CycleDetector {
    pool: &BufferPool,
    snapshot: Snapshot,
    clog: &Clog,
}

X CycleDetector {
    F new(
        pool: &BufferPool,
        snapshot: Snapshot,
        clog: &Clog
    ) -> CycleDetector {
        CycleDetector {
            pool,
            snapshot,
            clog,
        }
    }

    # Check if there exists any cycle reachable from start node
    # Returns true if at least one cycle is found, false otherwise
    F has_cycle(
        self,
        start: u64,
        adj_mgr: &AdjacencyManager,
        config: &TraversalConfig
    ) -> Result<bool, VaisError> {
        # Validate input
        I start == INVALID_NODE_ID {
            R Err(err_cycle_invalid_node(start));
        }

        # Validate direction
        I config.direction != DIRECTION_OUTGOING &&
           config.direction != DIRECTION_INCOMING &&
           config.direction != DIRECTION_BOTH {
            R Err(err_cycle_invalid_direction(config.direction));
        }

        # Color map: Vec<(node_id, color)>
        ~colors = Vec.new();

        # DFS stack: (node_id, parent_node, edge_id)
        ~stack = Vec.new();

        # Start DFS from start node
        CycleDetector.set_color(&colors, start, COLOR_GRAY);
        stack.push((start, INVALID_NODE_ID, INVALID_EDGE_ID));

        L while stack.len() > 0 {
            ~current = stack[stack.len() - 1];
            ~current_node = current.0;

            # Read adjacency entries for current node
            # Note: In production, need node index to lookup adj page IDs
            # For now, this is a simplified interface

            # Process edges from current node
            # If we find a gray node, we found a cycle
            # This is a placeholder - in production, would read actual adj entries

            # Mark current as black (finished)
            CycleDetector.set_color(&colors, current_node, COLOR_BLACK);
            stack.pop();
        }

        Ok(false)
    }

    # Find all cycles reachable from start node (up to max_cycles)
    # Returns vector of CycleResult, may be empty if no cycles exist
    F find_cycles(
        self,
        start: u64,
        adj_mgr: &AdjacencyManager,
        config: &TraversalConfig,
        max_cycles: u32
    ) -> Result<Vec<CycleResult>, VaisError> {
        # Validate input
        I start == INVALID_NODE_ID {
            R Err(err_cycle_invalid_node(start));
        }

        # Validate direction
        I config.direction != DIRECTION_OUTGOING &&
           config.direction != DIRECTION_INCOMING &&
           config.direction != DIRECTION_BOTH {
            R Err(err_cycle_invalid_direction(config.direction));
        }

        # Results
        ~cycles = Vec.new();

        # Color map: Vec<(node_id, color)>
        ~colors = Vec.new();

        # DFS stack: (node_id, parent_node, edge_id)
        ~stack = Vec.new();

        # Recursion path for cycle reconstruction
        ~rec_path = Vec.new();

        # Start DFS
        CycleDetector.set_color(&colors, start, COLOR_GRAY);
        stack.push((start, INVALID_NODE_ID, INVALID_EDGE_ID));
        rec_path.push((start, INVALID_EDGE_ID));

        L while stack.len() > 0 {
            I cycles.len() >= max_cycles as u64 {
                B            }

            ~current = stack[stack.len() - 1];
            ~current_node = current.0;

            # Read adjacency entries for current node
            # Process each adjacent node
            # If adjacent is GRAY, we found a cycle
            # If adjacent is WHITE, recurse into it
            # If adjacent is BLACK, skip it

            # For demonstration, this is a placeholder
            # In production: read adj entries, check visibility, detect cycles

            # Mark current as black (finished)
            CycleDetector.set_color(&colors, current_node, COLOR_BLACK);
            stack.pop();
            rec_path.pop();
        }

        Ok(cycles)
    }

    # Helper: get color of a node (default WHITE if not found)
    F get_color(colors: &Vec<(u64, u8)>, node_id: u64) -> u8 {
        ~i: u64 = 0;
        L while i < colors.len() {
            I colors[i].0 == node_id {
                R colors[i].1;
            }
            i += 1;
        }
        COLOR_WHITE
    }

    # Helper: set color of a node (add or update)
    F set_color(colors: &~Vec<(u64, u8)>, node_id: u64, color: u8) {
        ~i: u64 = 0;
        L while i < colors.len() {
            I colors[i].0 == node_id {
                colors[i] = (node_id, color);
                return;
            }
            i += 1;
        }
        colors.push((node_id, color));
    }

    # Helper: check if node exists in recursion path
    F in_rec_path(rec_path: &Vec<(u64, u64)>, node_id: u64) -> Option<u64> {
        ~i: u64 = 0;
        L while i < rec_path.len() {
            I rec_path[i].0 == node_id {
                R Some(i);
            }
            i += 1;
        }
        None
    }

    # Helper: extract cycle from recursion path
    F extract_cycle(rec_path: &Vec<(u64, u64)>, cycle_start_idx: u64) -> CycleResult {
        ~nodes = Vec.new();
        ~edges = Vec.new();

        ~i = cycle_start_idx;
        L while i < rec_path.len() {
            nodes.push(rec_path[i].0);
            I rec_path[i].1 != INVALID_EDGE_ID {
                edges.push(rec_path[i].1);
            }
            i += 1;
        }

        # Add closing edge (from last node back to first)
        # Note: in actual implementation, would need to find the back edge

        CycleResult.new(nodes, edges)
    }

    # Helper: process adjacency entries for cycle detection
    F process_adj_entries_for_cycle(
        self,
        entries: &Vec<AdjEntry>,
        current_node: u64,
        config: &TraversalConfig,
        ~colors: &~Vec<(u64, u8)>,
        ~stack: &~Vec<(u64, u64, u64)>,
        ~rec_path: &~Vec<(u64, u64)>,
        ~cycles: &~Vec<CycleResult>,
        max_cycles: u32
    ) -> bool {
        ~i: u64 = 0;
        L while i < entries.len() {
            I cycles.len() >= max_cycles as u64 {
                R true;
            }

            ~entry = &entries[i];

            # Check MVCC visibility
            I !is_adj_entry_visible(entry, &self.snapshot, self.clog) {
                i += 1;
                C            }

            # Check edge type filter
            I !config.is_edge_type_allowed(entry.edge_type) {
                i += 1;
                C            }

            ~target = entry.target_node;
            ~target_color = CycleDetector.get_color(colors, target);

            M target_color {
                COLOR_WHITE => {
                    # Unvisited - recurse into it
                    CycleDetector.set_color(colors, target, COLOR_GRAY);
                    stack.push((target, current_node, entry.edge_id));
                    rec_path.push((target, entry.edge_id));
                },
                COLOR_GRAY => {
                    # Back edge - cycle detected!
                    M CycleDetector.in_rec_path(rec_path, target) {
                        Some(idx) => {
                            ~cycle = CycleDetector.extract_cycle(rec_path, idx);
                            cycles.push(cycle);
                        },
                        None => {},
                    }
                },
                COLOR_BLACK => {
                    # Already processed - skip
                },
                _ => {},
            }

            i += 1;
        }

        false
    }

    # Helper: recursive DFS for cycle detection
    # Returns true if cycle found
    F dfs_visit(
        self,
        node: u64,
        adj_mgr: &AdjacencyManager,
        config: &TraversalConfig,
        ~colors: &~Vec<(u64, u8)>,
        ~rec_path: &~Vec<(u64, u64)>,
        ~cycles: &~Vec<CycleResult>,
        max_cycles: u32
    ) -> Result<bool, VaisError> {
        # Mark as gray (in recursion stack)
        CycleDetector.set_color(colors, node, COLOR_GRAY);

        # Read adjacency entries
        # Note: In production, lookup node -> get adj pages -> read entries
        # For now, this is a placeholder showing the interface

        # Process all edges
        # If we find a cycle, return true

        # Mark as black (finished)
        CycleDetector.set_color(colors, node, COLOR_BLACK);

        Ok(false)
    }
}
