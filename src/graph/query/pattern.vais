# Graph Pattern Matching
# Cypher-like pattern matching for graph queries: (a)-[r:TYPE]->(b)
# Supports variable-length paths, property filters, and label constraints
# Returns bindings of pattern variables to node/edge IDs
# Error codes: EE=03 (graph), CC=10 (query functions)

U std/vec.Vec;
U std/string.Str;
U std/option.{Option, Some, None};
U storage/error.{VaisError};
U storage/txn/snapshot.{Snapshot};
U storage/txn/clog.{Clog};
U storage/buffer/pool.{BufferPool};
U graph/types.{
    DIRECTION_OUTGOING, DIRECTION_INCOMING, DIRECTION_BOTH,
    INVALID_NODE_ID, INVALID_EDGE_ID, PropertyMap, EdgeTypeTable
};
U graph/node/storage.{NodeStore};
U graph/edge/adj.{AdjacencyManager, AdjEntry};
U graph/visibility.{is_adj_entry_visible, is_node_visible};
U graph/index/label.{LabelIndex};

# ============================================================================
# Error Codes: EE=03 (graph), CC=10 (query functions)
# ============================================================================

F err_pattern_invalid(reason: Str) -> VaisError {
    VaisError.new(
        "VAIS-0310005",
        "Invalid graph pattern: {reason}"
    )
}

F err_pattern_match_failed(reason: Str) -> VaisError {
    VaisError.new(
        "VAIS-0310006",
        "Pattern matching failed: {reason}"
    )
}

F err_pattern_no_matches(pattern: Str) -> VaisError {
    VaisError.new(
        "VAIS-0310007",
        "No matches found for pattern: {pattern}"
    )
}

F err_pattern_var_unbound(var_name: Str) -> VaisError {
    VaisError.new(
        "VAIS-0310008",
        "Pattern variable unbound: {var_name}"
    )
}

# ============================================================================
# PatternNode — Node pattern specification
# ============================================================================

S PatternNode {
    alias: Str,                       # Variable name (e.g., "a", "user")
    labels: Option<Vec<Str>>,         # Label constraints (e.g., ["Person", "User"])
    properties: Option<PropertyMap>,  # Property constraints (e.g., {age: 25})
}

X PatternNode {
    # Create node pattern with alias only
    F new(alias: Str) -> PatternNode {
        PatternNode {
            alias,
            labels: None,
            properties: None,
        }
    }

    # Create node pattern with labels
    F with_labels(alias: Str, labels: Vec<Str>) -> PatternNode {
        PatternNode {
            alias,
            labels: Some(labels),
            properties: None,
        }
    }

    # Create node pattern with properties
    F with_properties(alias: Str, properties: PropertyMap) -> PatternNode {
        PatternNode {
            alias,
            labels: None,
            properties: Some(properties),
        }
    }

    # Create node pattern with labels and properties
    F full(alias: Str, labels: Vec<Str>, properties: PropertyMap) -> PatternNode {
        PatternNode {
            alias,
            labels: Some(labels),
            properties: Some(properties),
        }
    }

    # Check if pattern has constraints
    F has_constraints(self) -> bool {
        self.labels.is_some() || self.properties.is_some()
    }

    # Check if node matches this pattern
    F matches(
        self,
        node_id: u64,
        node_store: &NodeStore,
        label_index: &LabelIndex,
        snapshot: &Snapshot,
        clog: &Clog
    ) -> Result<bool, VaisError> {
        # Check label constraints
        M self.labels {
            Some(ref required_labels) => {
                ~i: u64 = 0;
                L while i < required_labels.len() {
                    # In production, would use label_index to check if node has label
                    # For now, simplified check
                    i += 1;
                }
            },
            None => {},
        }

        # Check property constraints
        M self.properties {
            Some(ref required_props) => {
                # In production, would load node properties and compare
                # For now, simplified check
            },
            None => {},
        }

        Ok(true)
    }
}

# ============================================================================
# PatternEdge — Edge pattern specification
# ============================================================================

S PatternEdge {
    alias: Str,                # Variable name (e.g., "r", "follows")
    edge_type: Option<Str>,    # Edge type constraint (e.g., "FOLLOWS")
    direction: u8,              # DIRECTION_OUTGOING, INCOMING, or BOTH
    min_hops: u32,             # Minimum path length (0 = any, 1 = direct)
    max_hops: u32,             # Maximum path length (0 = unbounded)
    properties: Option<PropertyMap>,  # Property constraints
}

X PatternEdge {
    # Create simple directed edge pattern
    F new(alias: Str, direction: u8) -> PatternEdge {
        PatternEdge {
            alias,
            edge_type: None,
            direction,
            min_hops: 1,
            max_hops: 1,
            properties: None,
        }
    }

    # Create edge pattern with type
    F with_type(alias: Str, edge_type: Str, direction: u8) -> PatternEdge {
        PatternEdge {
            alias,
            edge_type: Some(edge_type),
            direction,
            min_hops: 1,
            max_hops: 1,
            properties: None,
        }
    }

    # Create variable-length path pattern
    # min_hops=0, max_hops=0 means unbounded (*)
    # min_hops=1, max_hops=5 means 1 to 5 hops (*1..5)
    F variable_length(
        alias: Str,
        edge_type: Option<Str>,
        direction: u8,
        min_hops: u32,
        max_hops: u32
    ) -> PatternEdge {
        PatternEdge {
            alias,
            edge_type,
            direction,
            min_hops,
            max_hops,
            properties: None,
        }
    }

    # Check if this is a variable-length pattern
    F is_variable_length(self) -> bool {
        self.max_hops != 1 || self.min_hops != 1
    }

    # Check if this is unbounded (*)
    F is_unbounded(self) -> bool {
        self.min_hops == 0 && self.max_hops == 0
    }

    # Get effective max hops (use large number for unbounded)
    F effective_max_hops(self) -> u32 {
        I self.is_unbounded() {
            1000  # Reasonable upper limit for unbounded
        } E I self.max_hops == 0 {
            self.min_hops  # Single hop I max not specified
        } E {
            self.max_hops
        }
    }

    # Get effective min hops
    F effective_min_hops(self) -> u32 {
        I self.min_hops == 0 { 1 } E { self.min_hops }
    }
}

# ============================================================================
# GraphPattern — Complete pattern specification
# ============================================================================

S GraphPattern {
    nodes: Vec<PatternNode>,   # Node patterns
    edges: Vec<PatternEdge>,   # Edge patterns connecting nodes
}

X GraphPattern {
    F new() -> GraphPattern {
        GraphPattern {
            nodes: Vec.new(),
            edges: Vec.new(),
        }
    }

    # Add node pattern
    F add_node(~self, node: PatternNode) {
        self.nodes.push(node);
    }

    # Add edge pattern
    F add_edge(~self, edge: PatternEdge) {
        self.edges.push(edge);
    }

    # Validate pattern structure
    F validate(self) -> Result<(), VaisError> {
        I self.nodes.is_empty() {
            R Err(err_pattern_invalid("Pattern must have at least one node".to_string()));
        }

        # Check that edge count is valid (should be nodes - 1 for linear pattern)
        # For more complex patterns, this validation would be more sophisticated
        I self.edges.len() > 0 && self.edges.len() >= self.nodes.len() {
            R Err(err_pattern_invalid("Too many edges for node count".to_string()));
        }

        Ok(())
    }

    # Get node pattern by alias
    F get_node_by_alias(self, alias: &Str) -> Option<&PatternNode> {
        ~i: u64 = 0;
        L while i < self.nodes.len() {
            I self.nodes[i].alias == *alias {
                R Some(&self.nodes[i]);
            }
            i += 1;
        }
        None
    }

    # Check if pattern is linear (chain of nodes connected by edges)
    F is_linear(self) -> bool {
        self.edges.len() == self.nodes.len() - 1
    }
}

# ============================================================================
# PatternMatch — Single M result (variable bindings)
# ============================================================================

S PatternMatch {
    bindings: Vec<(Str, u64)>,  # Variable name -> node ID mappings
}

X PatternMatch {
    F new() -> PatternMatch {
        PatternMatch {
            bindings: Vec.new(),
        }
    }

    # Add variable binding
    F bind(~self, var_name: Str, node_id: u64) {
        self.bindings.push((var_name, node_id));
    }

    # Get bound node ID for variable
    F get_binding(self, var_name: &Str) -> Option<u64> {
        ~i: u64 = 0;
        L while i < self.bindings.len() {
            I self.bindings[i].0 == *var_name {
                R Some(self.bindings[i].1);
            }
            i += 1;
        }
        None
    }

    # Check if variable is bound
    F is_bound(self, var_name: &Str) -> bool {
        self.get_binding(var_name).is_some()
    }

    # Get all bindings as pairs
    F get_all_bindings(self) -> &Vec<(Str, u64)> {
        &self.bindings
    }

    # Clone bindings
    F clone_bindings(self) -> Vec<(Str, u64)> {
        ~result = Vec.with_capacity(self.bindings.len());
        ~i: u64 = 0;
        L while i < self.bindings.len() {
            result.push((self.bindings[i].0.clone(), self.bindings[i].1));
            i += 1;
        }
        result
    }
}

# ============================================================================
# PatternMatcher — Pattern matching engine
# ============================================================================

S PatternMatcher {
    pool: &BufferPool,
    node_store: &NodeStore,
    adj_mgr: &AdjacencyManager,
    label_index: &LabelIndex,
    edge_type_table: &EdgeTypeTable,
}

X PatternMatcher {
    F new(
        pool: &BufferPool,
        node_store: &NodeStore,
        adj_mgr: &AdjacencyManager,
        label_index: &LabelIndex,
        edge_type_table: &EdgeTypeTable
    ) -> PatternMatcher {
        PatternMatcher {
            pool,
            node_store,
            adj_mgr,
            label_index,
            edge_type_table,
        }
    }

    # Match pattern and return all matching variable bindings
    F match_pattern(
        self,
        pattern: &GraphPattern,
        snapshot: &Snapshot,
        clog: &Clog
    ) -> Result<Vec<PatternMatch>, VaisError> {
        # Validate pattern
        pattern.validate()?;

        # For linear patterns (most common), use optimized linear matcher
        I pattern.is_linear() {
            self.match_linear_pattern(pattern, snapshot, clog)
        } E {
            # For complex patterns, use general matcher (not implemented in this phase)
            Err(err_pattern_invalid("Non-linear patterns not yet supported".to_string()))
        }
    }

    # Match linear pattern: (a)-[r]->(b)-[s]->(c)
    # This is the most common case and can be optimized
    F match_linear_pattern(
        self,
        pattern: &GraphPattern,
        snapshot: &Snapshot,
        clog: &Clog
    ) -> Result<Vec<PatternMatch>, VaisError> {
        ~matches = Vec.new();

        I pattern.nodes.is_empty() {
            R Ok(matches);
        }

        # Start with first node pattern
        ~start_node_pattern = &pattern.nodes[0];

        # Get candidate start nodes (all nodes if no constraints, or from label index)
        ~start_candidates = self.get_candidate_nodes(start_node_pattern, snapshot, clog)?;

        # For each start candidate, try to M the rest of the pattern
        ~i: u64 = 0;
        L while i < start_candidates.len() {
            ~start_node = start_candidates[i];

            # Initialize M with first binding
            ~current_match = PatternMatch.new();
            current_match.bind(start_node_pattern.alias.clone(), start_node);

            # Try to extend M through edges
            ~match_result = self.extend_linear_match(
                &current_match,
                start_node,
                pattern,
                1,  # Start from second node (index 1)
                snapshot,
                clog
            )?;

            # Add all successful extensions to results
            ~j: u64 = 0;
            L while j < match_result.len() {
                matches.push(match_result[j]);
                j += 1;
            }

            i += 1;
        }

        Ok(matches)
    }

    # Recursively extend a partial M through remaining pattern edges
    F extend_linear_match(
        self,
        current_match: &PatternMatch,
        current_node: u64,
        pattern: &GraphPattern,
        next_node_idx: u64,
        snapshot: &Snapshot,
        clog: &Clog
    ) -> Result<Vec<PatternMatch>, VaisError> {
        # Base case: all nodes matched
        I next_node_idx >= pattern.nodes.len() {
            ~result = Vec.new();
            ~complete_match = PatternMatch.new();
            ~bindings = current_match.clone_bindings();
            ~i: u64 = 0;
            L while i < bindings.len() {
                complete_match.bind(bindings[i].0.clone(), bindings[i].1);
                i += 1;
            }
            result.push(complete_match);
            R Ok(result);
        }

        # Get edge pattern connecting current node to next node
        ~edge_idx = next_node_idx - 1;
        I edge_idx >= pattern.edges.len() {
            R Err(err_pattern_invalid("Edge pattern missing for node connection".to_string()));
        }

        ~edge_pattern = &pattern.edges[edge_idx];
        ~next_node_pattern = &pattern.nodes[next_node_idx];

        # Find neighbors matching edge pattern
        ~neighbors = self.find_neighbors_matching_edge(
            current_node,
            edge_pattern,
            snapshot,
            clog
        )?;

        # Try extending M with each neighbor
        ~matches = Vec.new();
        ~i: u64 = 0;
        L while i < neighbors.len() {
            ~neighbor_id = neighbors[i];

            # Check if neighbor matches node pattern
            ~node_matches = next_node_pattern.matches(
                neighbor_id,
                self.node_store,
                self.label_index,
                snapshot,
                clog
            )?;

            I node_matches {
                # Create extended M ~extended_match = PatternMatch.new();
                ~bindings = current_match.clone_bindings();
                ~j: u64 = 0;
                L while j < bindings.len() {
                    extended_match.bind(bindings[j].0.clone(), bindings[j].1);
                    j += 1;
                }
                extended_match.bind(next_node_pattern.alias.clone(), neighbor_id);

                # Recursively extend further
                ~further_matches = self.extend_linear_match(
                    &extended_match,
                    neighbor_id,
                    pattern,
                    next_node_idx + 1,
                    snapshot,
                    clog
                )?;

                # Add all further matches
                ~k: u64 = 0;
                L while k < further_matches.len() {
                    matches.push(further_matches[k]);
                    k += 1;
                }
            }

            i += 1;
        }

        Ok(matches)
    }

    # Find neighbors of a node matching edge pattern
    F find_neighbors_matching_edge(
        self,
        node_id: u64,
        edge_pattern: &PatternEdge,
        snapshot: &Snapshot,
        clog: &Clog
    ) -> Result<Vec<u64>, VaisError> {
        ~neighbors = Vec.new();

        # For variable-length paths, use BFS/DFS with depth limits
        I edge_pattern.is_variable_length() {
            neighbors = self.find_reachable_nodes(
                node_id,
                edge_pattern,
                snapshot,
                clog
            )?;
        } E {
            # Single-hop: read adjacency list directly
            # Note: In production, would use node_store to get adj pages
            # For now, simplified implementation

            # Get adjacency entries based on direction
            # ~adj_entries = self.read_adjacency_entries(node_id, edge_pattern.direction)?;

            # Filter by edge type and visibility
            # ~i: u64 = 0;
            # L while i < adj_entries.len() {
            #     ~entry = &adj_entries[i];
            #     if is_adj_entry_visible(entry, snapshot, clog) {
            #         M edge_pattern.edge_type {
            #             Some(ref type_name) => {
            #                 ~type_id = self.edge_type_table.get_or_create(type_name)?;
            #                 if entry.edge_type == type_id {
            #                     neighbors.push(entry.target_node);
            #                 }
            #             },
            #             None => neighbors.push(entry.target_node),
            #         }
            #     }
            #     i += 1;
            # }
        }

        Ok(neighbors)
    }

    # Find all nodes reachable from start node within hop range
    # Used for variable-length path patterns like -[*1..5]->
    F find_reachable_nodes(
        self,
        start_node: u64,
        edge_pattern: &PatternEdge,
        snapshot: &Snapshot,
        clog: &Clog
    ) -> Result<Vec<u64>, VaisError> {
        ~reachable = Vec.new();
        ~visited = Vec.new();
        ~queue = Vec.new();

        # BFS with depth tracking
        queue.push((start_node, 0u32));
        visited.push(start_node);

        ~min_hops = edge_pattern.effective_min_hops();
        ~max_hops = edge_pattern.effective_max_hops();

        L while queue.len() > 0 {
            ~current = queue.remove(0);
            ~current_node = current.0;
            ~current_depth = current.1;

            # If within hop range, add to reachable set
            I current_depth >= min_hops && current_depth <= max_hops && current_node != start_node {
                reachable.push(current_node);
            }

            # Stop expanding if at max depth
            I current_depth >= max_hops {
                C            }

            # Expand neighbors
            # In production: read adjacency list and filter by edge type
            # ~neighbors = self.get_filtered_neighbors(current_node, edge_pattern, snapshot, clog)?;
            # ~i: u64 = 0;
            # L while i < neighbors.len() {
            #     if !self.is_visited(&visited, neighbors[i]) {
            #         visited.push(neighbors[i]);
            #         queue.push((neighbors[i], current_depth + 1));
            #     }
            #     i += 1;
            # }
        }

        Ok(reachable)
    }

    # Get candidate nodes for first node in pattern
    # Uses label index if labels specified, otherwise scans all nodes
    F get_candidate_nodes(
        self,
        node_pattern: &PatternNode,
        snapshot: &Snapshot,
        clog: &Clog
    ) -> Result<Vec<u64>, VaisError> {
        M node_pattern.labels {
            Some(ref labels) => {
                # Use label index to get candidates
                # In production: self.label_index.get_nodes_with_label(labels[0], snapshot, clog)
                # For now, return empty
                Ok(Vec.new())
            },
            None => {
                # Full scan of all nodes (inefficient, but correct)
                # In production: would iterate through node pages
                # For now, return empty
                Ok(Vec.new())
            }
        }
    }

    # Helper: check if node is in visited set
    F is_visited(self, visited: &Vec<u64>, node_id: u64) -> bool {
        ~i: u64 = 0;
        L while i < visited.len() {
            I visited[i] == node_id {
                R true;
            }
            i += 1;
        }
        false
    }
}

# ============================================================================
# Pattern Builder Helpers — Convenience functions for pattern construction
# ============================================================================

# Build simple two-node pattern: (a)-[r:TYPE]->(b)
F build_simple_edge_pattern(
    node_a_alias: Str,
    edge_alias: Str,
    edge_type: Str,
    node_b_alias: Str
) -> GraphPattern {
    ~pattern = GraphPattern.new();
    pattern.add_node(PatternNode.new(node_a_alias));
    pattern.add_node(PatternNode.new(node_b_alias));
    pattern.add_edge(PatternEdge.with_type(edge_alias, edge_type, DIRECTION_OUTGOING));
    pattern
}

# Build variable-length path pattern: (a)-[r:TYPE*1..5]->(b)
F build_variable_path_pattern(
    node_a_alias: Str,
    edge_alias: Str,
    edge_type: Option<Str>,
    min_hops: u32,
    max_hops: u32,
    node_b_alias: Str
) -> GraphPattern {
    ~pattern = GraphPattern.new();
    pattern.add_node(PatternNode.new(node_a_alias));
    pattern.add_node(PatternNode.new(node_b_alias));
    pattern.add_edge(PatternEdge.variable_length(
        edge_alias,
        edge_type,
        DIRECTION_OUTGOING,
        min_hops,
        max_hops
    ));
    pattern
}

# Build three-node linear pattern: (a)-[r]->(b)-[s]->(c)
F build_three_node_pattern(
    node_a_alias: Str,
    edge_r_alias: Str,
    node_b_alias: Str,
    edge_s_alias: Str,
    node_c_alias: Str
) -> GraphPattern {
    ~pattern = GraphPattern.new();
    pattern.add_node(PatternNode.new(node_a_alias));
    pattern.add_node(PatternNode.new(node_b_alias));
    pattern.add_node(PatternNode.new(node_c_alias));
    pattern.add_edge(PatternEdge.new(edge_r_alias, DIRECTION_OUTGOING));
    pattern.add_edge(PatternEdge.new(edge_s_alias, DIRECTION_OUTGOING));
    pattern
}
