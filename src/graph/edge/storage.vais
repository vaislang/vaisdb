# Graph Edge Property Storage
# Manages edge property pages: stores PropertyMap for edges
# Page type: PAGE_TYPE_GRAPH_PROPERTY (0x32), engine: ENGINE_TAG_GRAPH (0x03)
# Edge metadata (src, dst, type, MVCC) is stored in AdjEntry within adjacency pages.
# This module stores only the variable-size property data for edges/nodes.

U std/bytes.{ByteBuffer};
U std/vec.Vec;
U std/option.{Option, Some, None};
U storage/constants.{
    PAGE_HEADER_SIZE, DEFAULT_PAGE_SIZE, NULL_PAGE,
    FILE_ID_GRAPH, INVALID_TXN_ID
};
U storage/error.{VaisError, err_internal};
U storage/page/header.{PageHeader};
U storage/page/types.{PAGE_TYPE_GRAPH_PROPERTY, ENGINE_TAG_GRAPH};
U storage/buffer/pool.{BufferPool};
U storage/page/allocator.{PageAllocator};
U storage/page/freelist.{FreelistBitmap};
U graph/types.{
    PropertyMap, PROP_PAGE_HEADER_SIZE,
    ENTITY_TYPE_NODE, ENTITY_TYPE_EDGE,
    err_graph_page_full
};

# ============================================================================
# PropertyPage — Stores properties for a single entity (node or edge)
# Layout: [PageHeader 48B] [PropPageHeader 16B] [PropertyMap bytes...]
# ============================================================================

S PropertyPageHeader {
    entity_type: u8,        # 0=node, 1=edge
    entity_id: u64,         # Node ID or Edge ID
    prop_count: u16,        # Number of properties
    next_prop_page: u32,    # Overflow continuation (0 = none)
    reserved: u8,
}

X PropertyPageHeader {
    F new(entity_type: u8, entity_id: u64) -> PropertyPageHeader {
        PropertyPageHeader {
            entity_type,
            entity_id,
            prop_count: 0,
            next_prop_page: NULL_PAGE,
            reserved: 0,
        }
    }

    # Serialize (16 bytes)
    F serialize(self, buf: &~ByteBuffer) {
        buf.put_u8(self.entity_type);
        buf.put_u64_le(self.entity_id);
        buf.put_u16_le(self.prop_count);
        buf.put_u32_le(self.next_prop_page);
        buf.put_u8(self.reserved);
    }

    # Deserialize (16 bytes)
    F deserialize(buf: &ByteBuffer) -> Result<PropertyPageHeader, VaisError> {
        Ok(PropertyPageHeader {
            entity_type: buf.get_u8()?,
            entity_id: buf.get_u64_le()?,
            prop_count: buf.get_u16_le()?,
            next_prop_page: buf.get_u32_le()?,
            reserved: buf.get_u8()?,
        })
    }
}

# ============================================================================
# PropertyStore — High-level property storage interface
# ============================================================================

S PropertyStore {
    pool: &BufferPool,
    allocator: &PageAllocator,
    bitmap: &FreelistBitmap,
    page_size: u32,
}

X PropertyStore {
    F new(
        pool: &BufferPool,
        allocator: &PageAllocator,
        bitmap: &FreelistBitmap,
        page_size: u32
    ) -> PropertyStore {
        PropertyStore { pool, allocator, bitmap, page_size }
    }

    # Write properties for an entity, returns property page ID
    F write_properties(
        ~self,
        entity_type: u8,
        entity_id: u64,
        props: &PropertyMap,
        txn_id: u64
    ) -> Result<u32, VaisError> {
        I props.is_empty() {
            R Ok(NULL_PAGE);
        }

        # Serialize properties
        ~prop_buf = ByteBuffer.new(512);
        props.serialize(&prop_buf);
        ~prop_bytes = prop_buf.to_vec();

        # Allocate page
        ~page_id = self.allocator.allocate_page(FILE_ID_GRAPH, self.bitmap)?;

        # Build page
        ~page_data = vec![0u8; self.page_size as u64];

        # Write page header
        ~header = PageHeader.new(page_id, PAGE_TYPE_GRAPH_PROPERTY, ENGINE_TAG_GRAPH);
        header.txn_id = txn_id;
        header.item_count = props.len() as u16;
        header.write_to_page(&page_data);

        # Write property page header
        ~buf = ByteBuffer.wrap(&page_data);
        buf.set_position(PAGE_HEADER_SIZE as u64);
        ~prop_header = PropertyPageHeader.new(entity_type, entity_id);
        prop_header.prop_count = props.len() as u16;
        prop_header.serialize(&buf);

        # Write property data
        ~available = self.page_size - PAGE_HEADER_SIZE - PROP_PAGE_HEADER_SIZE;
        I prop_bytes.len() as u32 > available {
            R Err(err_graph_page_full(page_id));
        }
        ~i: u64 = 0;
        W i < prop_bytes.len() {
            buf.put_u8(prop_bytes[i]);
            i += 1;
        }

        # Update checksum
        PageHeader.update_checksum(&page_data);

        # Write to buffer pool
        ~frame_id = self.pool.fetch_page(FILE_ID_GRAPH, page_id)?;
        ~frame_data = self.pool.get_page_mut(frame_id);
        ~j: u64 = 0;
        W j < page_data.len() {
            frame_data[j] = page_data[j];
            j += 1;
        }
        self.pool.unpin_page(frame_id, true);

        Ok(page_id)
    }

    # Read properties for an entity
    F read_properties(self, page_id: u32) -> Result<PropertyMap, VaisError> {
        I page_id == NULL_PAGE {
            R Ok(PropertyMap.new());
        }

        ~frame_id = self.pool.fetch_page(FILE_ID_GRAPH, page_id)?;
        ~page_data = self.pool.get_page(frame_id);

        # Verify page type
        ~header = PageHeader.read_from_page(page_data)?;
        I header.page_type != PAGE_TYPE_GRAPH_PROPERTY {
            self.pool.unpin_page(frame_id, false);
            R Err(err_internal("Expected GRAPH_PROPERTY page type"));
        }

        # Read property page header
        ~buf = ByteBuffer.wrap_readonly(&page_data[PAGE_HEADER_SIZE as u64..]);
        ~prop_header = PropertyPageHeader.deserialize(&buf)?;

        # Read property data
        ~props = PropertyMap.deserialize(&buf)?;

        self.pool.unpin_page(frame_id, false);
        Ok(props)
    }

    # Update properties for an entity (in-place if fits)
    F update_properties(
        ~self,
        page_id: u32,
        props: &PropertyMap,
        txn_id: u64
    ) -> Result<(), VaisError> {
        I page_id == NULL_PAGE {
            R Err(err_internal("Cannot update properties on NULL page"));
        }

        ~frame_id = self.pool.fetch_page(FILE_ID_GRAPH, page_id)?;
        ~page_data = self.pool.get_page_mut(frame_id);

        # Read existing header
        ~header = PageHeader.read_from_page(page_data)?;
        ~buf = ByteBuffer.wrap_readonly(&page_data[PAGE_HEADER_SIZE as u64..]);
        ~prop_header = PropertyPageHeader.deserialize(&buf)?;

        # Serialize new properties
        ~prop_buf = ByteBuffer.new(512);
        props.serialize(&prop_buf);
        ~prop_bytes = prop_buf.to_vec();

        ~available = self.page_size - PAGE_HEADER_SIZE - PROP_PAGE_HEADER_SIZE;
        I prop_bytes.len() as u32 > available {
            self.pool.unpin_page(frame_id, false);
            R Err(err_graph_page_full(page_id));
        }

        # Rewrite property data
        ~write_buf = ByteBuffer.wrap(page_data);
        write_buf.set_position((PAGE_HEADER_SIZE + PROP_PAGE_HEADER_SIZE) as u64);
        ~i: u64 = 0;
        W i < prop_bytes.len() {
            write_buf.put_u8(prop_bytes[i]);
            i += 1;
        }

        # Update header
        ~new_header = header;
        new_header.txn_id = txn_id;
        new_header.item_count = props.len() as u16;
        new_header.write_to_page(page_data);

        # Update prop_header count
        ~h_buf = ByteBuffer.wrap(page_data);
        h_buf.set_position(PAGE_HEADER_SIZE as u64);
        ~updated_prop_header = prop_header;
        updated_prop_header.prop_count = props.len() as u16;
        updated_prop_header.serialize(&h_buf);

        PageHeader.update_checksum(page_data);
        self.pool.unpin_page(frame_id, true);
        Ok(())
    }

    # Delete properties (free the page)
    F delete_properties(~self, page_id: u32) -> Result<(), VaisError> {
        I page_id == NULL_PAGE {
            R Ok(());
        }
        self.allocator.free_page(FILE_ID_GRAPH, page_id, self.bitmap)?;
        Ok(())
    }
}
