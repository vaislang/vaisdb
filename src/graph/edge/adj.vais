# Adjacency List Manager
# Manages adjacency list pages (PAGE_TYPE_GRAPH_ADJ = 0x31)
# Each node has outgoing and incoming adjacency lists stored as AdjEntry arrays
# Page layout: [PageHeader 48B] [AdjPageHeader 16B] [AdjEntry 42B * N]
# Supports page chaining for nodes with many edges (next_adj_page)

U std/bytes.{ByteBuffer};
U std/vec.Vec;
U std/option.{Option, Some, None};
U storage/constants.{
    PAGE_HEADER_SIZE, NULL_PAGE, FILE_ID_GRAPH, INVALID_TXN_ID
};
U storage/error.{VaisError, err_internal};
U storage/page/header.{PageHeader};
U storage/page/types.{PAGE_TYPE_GRAPH_ADJ, ENGINE_TAG_GRAPH};
U storage/buffer/pool.{BufferPool};
U storage/page/allocator.{PageAllocator};
U storage/page/freelist.{FreelistBitmap};
U graph/types.{
    AdjEntry, ADJ_ENTRY_SIZE, ADJ_PAGE_HEADER_SIZE,
    DIRECTION_OUTGOING, DIRECTION_INCOMING,
    err_graph_adj_corrupt, err_graph_page_full
};

# ============================================================================
# AdjPageHeader — Adjacency list page body header (16 bytes)
# ============================================================================

S AdjPageHeader {
    node_id: u64,          # Owner node ID
    direction: u8,         # 0=outgoing, 1=incoming
    entry_count: u16,      # Number of AdjEntry in this page
    next_adj_page: u32,    # Next page in chain (0 = last page)
    reserved: u8,
}

X AdjPageHeader {
    F new(node_id: u64, direction: u8) -> AdjPageHeader {
        AdjPageHeader {
            node_id,
            direction,
            entry_count: 0,
            next_adj_page: NULL_PAGE,
            reserved: 0,
        }
    }

    # Serialize (16 bytes)
    F serialize(self, buf: &~ByteBuffer) {
        buf.put_u64_le(self.node_id);
        buf.put_u8(self.direction);
        buf.put_u16_le(self.entry_count);
        buf.put_u32_le(self.next_adj_page);
        buf.put_u8(self.reserved);
    }

    # Deserialize (16 bytes)
    F deserialize(buf: &ByteBuffer) -> Result<AdjPageHeader, VaisError> {
        Ok(AdjPageHeader {
            node_id: buf.get_u64_le()?,
            direction: buf.get_u8()?,
            entry_count: buf.get_u16_le()?,
            next_adj_page: buf.get_u32_le()?,
            reserved: buf.get_u8()?,
        })
    }
}

# ============================================================================
# AdjPage — Single adjacency list page
# ============================================================================

S AdjPage {
    page_id: u32,
    adj_header: AdjPageHeader,
    entries: Vec<AdjEntry>,
    page_size: u32,
}

X AdjPage {
    # Create new empty adjacency page
    F new(page_id: u32, node_id: u64, direction: u8, page_size: u32) -> AdjPage {
        AdjPage {
            page_id,
            adj_header: AdjPageHeader.new(node_id, direction),
            entries: Vec.new(),
            page_size,
        }
    }

    # Load from page buffer
    F load(page_id: u32, page_data: &[u8], page_size: u32) -> Result<AdjPage, VaisError> {
        ~header = PageHeader.read_from_page(page_data)?;
        I header.page_type != PAGE_TYPE_GRAPH_ADJ {
            R Err(err_graph_adj_corrupt(page_id));
        }

        ~buf = ByteBuffer.wrap_readonly(&page_data[PAGE_HEADER_SIZE as u64..]);
        ~adj_header = AdjPageHeader.deserialize(&buf)?;

        # Read entries
        ~entries = Vec.with_capacity(adj_header.entry_count as u64);
        ~i: u64 = 0;
        W i < adj_header.entry_count as u64 {
            entries.push(AdjEntry.deserialize(&buf)?);
            i += 1;
        }

        Ok(AdjPage {
            page_id,
            adj_header,
            entries,
            page_size,
        })
    }

    # Maximum entries that fit in one page
    F max_entries(page_size: u32) -> u16 {
        ~available = page_size - PAGE_HEADER_SIZE - ADJ_PAGE_HEADER_SIZE;
        (available / ADJ_ENTRY_SIZE) as u16
    }

    # Check if page has room for one more entry
    F has_space(self) -> bool {
        self.entries.len() < AdjPage.max_entries(self.page_size) as u64
    }

    # Add entry to page
    F add_entry(~self, entry: AdjEntry) -> Result<(), VaisError> {
        I !self.has_space() {
            R Err(err_graph_page_full(self.page_id));
        }
        self.entries.push(entry);
        self.adj_header.entry_count += 1;
        Ok(())
    }

    # Find entry by edge_id
    F find_entry(self, edge_id: u64) -> Option<u64> {
        ~i: u64 = 0;
        W i < self.entries.len() {
            I self.entries[i].edge_id == edge_id {
                R Some(i);
            }
            i += 1;
        }
        None
    }

    # Find entry by target_node and edge_type
    F find_entry_by_target(self, target_node: u64, edge_type: u16) -> Option<u64> {
        ~i: u64 = 0;
        W i < self.entries.len() {
            I self.entries[i].target_node == target_node && self.entries[i].edge_type == edge_type {
                R Some(i);
            }
            i += 1;
        }
        None
    }

    # Get all active entries (not expired)
    F active_entries(self) -> Vec<&AdjEntry> {
        ~result = Vec.new();
        ~i: u64 = 0;
        W i < self.entries.len() {
            I self.entries[i].is_active() {
                result.push(&self.entries[i]);
            }
            i += 1;
        }
        result
    }

    # Write page to buffer
    F write_to_buffer(self, page_lsn: u64, txn_id: u64) -> Vec<u8> {
        ~out = vec![0u8; self.page_size as u64];

        # Page header
        ~header = PageHeader.new(self.page_id, PAGE_TYPE_GRAPH_ADJ, ENGINE_TAG_GRAPH);
        header.page_lsn = page_lsn;
        header.txn_id = txn_id;
        header.item_count = self.adj_header.entry_count;
        header.next_page = self.adj_header.next_adj_page;
        header.write_to_page(&out);

        # Adj page header
        ~buf = ByteBuffer.wrap(&out);
        buf.set_position(PAGE_HEADER_SIZE as u64);
        self.adj_header.serialize(&buf);

        # Entries
        ~i: u64 = 0;
        W i < self.entries.len() {
            self.entries[i].serialize(&buf);
            i += 1;
        }

        PageHeader.update_checksum(&out);
        out
    }
}

# ============================================================================
# AdjacencyManager — High-level adjacency list management via buffer pool
# Handles page chaining for large adjacency lists
# ============================================================================

S AdjacencyManager {
    pool: &BufferPool,
    allocator: &PageAllocator,
    bitmap: &FreelistBitmap,
    page_size: u32,
}

X AdjacencyManager {
    F new(
        pool: &BufferPool,
        allocator: &PageAllocator,
        bitmap: &FreelistBitmap,
        page_size: u32
    ) -> AdjacencyManager {
        AdjacencyManager { pool, allocator, bitmap, page_size }
    }

    # Create a new adjacency list page for a node (returns page_id)
    F create_adj_page(
        ~self,
        node_id: u64,
        direction: u8,
        txn_id: u64
    ) -> Result<u32, VaisError> {
        ~page_id = self.allocator.allocate_page(FILE_ID_GRAPH, self.bitmap)?;
        ~adj_page = AdjPage.new(page_id, node_id, direction, self.page_size);

        # Write to buffer pool
        ~page_buffer = adj_page.write_to_buffer(0, txn_id);
        ~frame_id = self.pool.fetch_page(FILE_ID_GRAPH, page_id)?;
        ~frame_data = self.pool.get_page_mut(frame_id);
        ~i: u64 = 0;
        W i < page_buffer.len() {
            frame_data[i] = page_buffer[i];
            i += 1;
        }
        self.pool.unpin_page(frame_id, true);

        Ok(page_id)
    }

    # Add an edge entry to a node's adjacency list
    # Handles page-full by allocating a new page and chaining
    F add_edge(
        ~self,
        adj_page_id: u32,
        entry: AdjEntry,
        txn_id: u64
    ) -> Result<u32, VaisError> {
        # Load current page
        ~frame_id = self.pool.fetch_page(FILE_ID_GRAPH, adj_page_id)?;
        ~page_data = self.pool.get_page(frame_id);
        ~adj_page = AdjPage.load(adj_page_id, page_data, self.page_size)?;
        self.pool.unpin_page(frame_id, false);

        # Walk chain to find page with space
        ~current_page = adj_page;
        L {
            I current_page.has_space() {
                # Add to this page
                current_page.add_entry(entry)?;

                # Write back
                ~write_buf = current_page.write_to_buffer(0, txn_id);
                ~wframe = self.pool.fetch_page(FILE_ID_GRAPH, current_page.page_id)?;
                ~wdata = self.pool.get_page_mut(wframe);
                ~j: u64 = 0;
                W j < write_buf.len() {
                    wdata[j] = write_buf[j];
                    j += 1;
                }
                self.pool.unpin_page(wframe, true);

                R Ok(current_page.page_id);
            }

            # Check if there's a next page
            I current_page.adj_header.next_adj_page == NULL_PAGE {
                # Need to allocate new page
                ~new_page_id = self.allocator.allocate_page(FILE_ID_GRAPH, self.bitmap)?;
                ~new_page = AdjPage.new(
                    new_page_id,
                    current_page.adj_header.node_id,
                    current_page.adj_header.direction,
                    self.page_size
                );
                new_page.add_entry(entry)?;

                # Link current → new
                current_page.adj_header.next_adj_page = new_page_id;

                # Write both pages
                ~cur_buf = current_page.write_to_buffer(0, txn_id);
                ~cf = self.pool.fetch_page(FILE_ID_GRAPH, current_page.page_id)?;
                ~cd = self.pool.get_page_mut(cf);
                ~k: u64 = 0;
                W k < cur_buf.len() {
                    cd[k] = cur_buf[k];
                    k += 1;
                }
                self.pool.unpin_page(cf, true);

                ~new_buf = new_page.write_to_buffer(0, txn_id);
                ~nf = self.pool.fetch_page(FILE_ID_GRAPH, new_page_id)?;
                ~nd = self.pool.get_page_mut(nf);
                ~m: u64 = 0;
                W m < new_buf.len() {
                    nd[m] = new_buf[m];
                    m += 1;
                }
                self.pool.unpin_page(nf, true);

                R Ok(new_page_id);
            }

            # Move to next page
            ~next_id = current_page.adj_header.next_adj_page;
            ~nframe = self.pool.fetch_page(FILE_ID_GRAPH, next_id)?;
            ~ndata = self.pool.get_page(nframe);
            current_page = AdjPage.load(next_id, ndata, self.page_size)?;
            self.pool.unpin_page(nframe, false);
        }
    }

    # Read all entries from an adjacency list (follows page chain)
    F read_all_entries(self, adj_page_id: u32) -> Result<Vec<AdjEntry>, VaisError> {
        I adj_page_id == NULL_PAGE {
            R Ok(Vec.new());
        }

        ~result = Vec.new();
        ~current_page_id = adj_page_id;

        W current_page_id != NULL_PAGE {
            ~frame_id = self.pool.fetch_page(FILE_ID_GRAPH, current_page_id)?;
            ~page_data = self.pool.get_page(frame_id);
            ~adj_page = AdjPage.load(current_page_id, page_data, self.page_size)?;
            self.pool.unpin_page(frame_id, false);

            # Copy entries
            ~i: u64 = 0;
            W i < adj_page.entries.len() {
                result.push(adj_page.entries[i]);
                i += 1;
            }

            current_page_id = adj_page.adj_header.next_adj_page;
        }

        Ok(result)
    }

    # Mark an edge as expired in the adjacency list
    F expire_edge(
        ~self,
        adj_page_id: u32,
        edge_id: u64,
        txn_id: u64,
        cmd_id: u32
    ) -> Result<bool, VaisError> {
        I adj_page_id == NULL_PAGE {
            R Ok(false);
        }

        ~current_page_id = adj_page_id;

        W current_page_id != NULL_PAGE {
            ~frame_id = self.pool.fetch_page(FILE_ID_GRAPH, current_page_id)?;
            ~page_data = self.pool.get_page_mut(frame_id);
            ~adj_page = AdjPage.load(current_page_id, page_data, self.page_size)?;

            M adj_page.find_entry(edge_id) {
                Some(idx) => {
                    # Found it — mark expired
                    adj_page.entries[idx].set_expired(txn_id, cmd_id);

                    # Write back
                    ~write_buf = adj_page.write_to_buffer(0, txn_id);
                    ~j: u64 = 0;
                    W j < write_buf.len() {
                        page_data[j] = write_buf[j];
                        j += 1;
                    }
                    self.pool.unpin_page(frame_id, true);
                    R Ok(true);
                },
                None => {
                    ~next_id = adj_page.adj_header.next_adj_page;
                    self.pool.unpin_page(frame_id, false);
                    current_page_id = next_id;
                },
            }
        }

        Ok(false)
    }
}
