# Graph Property Index
# B+Tree-based index for property-based entity lookup
# Key format: encode_u16_be(prop_key_id) + encoded_value + encode_u64_be(entity_id) → TID
# Supports both point lookups and range scans on property values

U std/vec.Vec;
U std/bytes.{ByteBuffer};
U storage/constants.{FILE_ID_GRAPH, NULL_PAGE};
U storage/error.{VaisError, err_internal};
U storage/buffer/pool.{BufferPool};
U storage/page/allocator.{PageAllocator};
U storage/page/freelist.{FreelistBitmap};
U storage/btree/tree.{BTree};
U storage/btree/insert.{btree_insert};
U storage/btree/delete.{btree_delete};
U storage/btree/search.{search_lower_bound};
U storage/btree/key.{encode_u64_key, encode_i64_key};
U storage/btree/cursor.{BTreeCursor, ScanDirection};
U storage/wal/group_commit.{GroupCommitManager};
U graph/types.{PropertyValue, PROP_TYPE_NULL, PROP_TYPE_INT, PROP_TYPE_FLOAT, PROP_TYPE_STRING, PROP_TYPE_BOOL, PROP_TYPE_BYTES};

# Error codes: EE=03 (graph), CC=07 (property index)
F err_property_index_corrupt(prop_key_id: u16) -> VaisError {
    VaisError.new(
        "VAIS-0307001",
        "Property index corrupted for prop_key_id {prop_key_id}"
    )
}

F err_property_index_unsupported_type(prop_type: u8) -> VaisError {
    VaisError.new(
        "VAIS-0307002",
        "Unsupported property type for indexing: {prop_type}"
    )
}

F err_property_index_full() -> VaisError {
    VaisError.new(
        "VAIS-0307003",
        "Property index is full"
    )
}

# ============================================================================
# PropertyIndex — B+Tree wrapper for property-based entity lookup
# ============================================================================

S PropertyIndex {
    tree: BTree,
}

X PropertyIndex {
    # Create new property index with given root page
    F new(root_page_id: u32, file_id: u8, page_size: u32) -> PropertyIndex {
        PropertyIndex {
            tree: BTree.new(root_page_id, file_id, page_size),
        }
    }

    # Insert a property for an entity (node or edge)
    # Key: [prop_key_id (u16 BE)][encoded_value][entity_id (u64 BE)] → TID (dummy)
    F insert_property(
        ~self,
        entity_id: u64,
        prop_key_id: u16,
        value: &PropertyValue,
        txn_id: u64,
        gcm: &~GroupCommitManager,
        pool: &~BufferPool,
        allocator: &PageAllocator,
    ) -> Result<(), VaisError> {
        ~key = Self.encode_property_key(prop_key_id, value, entity_id)?;

        # TID is not meaningful for property index, use entity_id as dummy
        ~tid = (entity_id & 0xFFFFFFFF) as u32;

        # Insert into B+Tree
        ~inserted = btree_insert(&self.tree, &key, tid, txn_id, gcm, pool)?;

        I !inserted {
            # Key already exists, this is fine (idempotent)
            Ok(())
        } E {
            Ok(())
        }
    }

    # Remove a property from an entity
    F remove_property(
        ~self,
        entity_id: u64,
        prop_key_id: u16,
        value: &PropertyValue,
        txn_id: u64,
        gcm: &~GroupCommitManager,
        pool: &~BufferPool,
    ) -> Result<(), VaisError> {
        ~key = Self.encode_property_key(prop_key_id, value, entity_id)?;

        # Delete from B+Tree
        btree_delete(&self.tree, &key, txn_id, gcm, pool)?;

        Ok(())
    }

    # Lookup all entities with a specific property value
    # Returns vector of entity_ids
    F lookup_by_property(
        self,
        prop_key_id: u16,
        value: &PropertyValue,
        pool: &~BufferPool,
    ) -> Result<Vec<u64>, VaisError> {
        ~results = Vec.new();

        # Create start key: [prop_key_id][encoded_value]
        ~value_encoded = Self.encode_property_value(value)?;
        ~start_key = Self.encode_property_prefix(prop_key_id, &value_encoded);

        # Create end key: [prop_key_id][encoded_value][0xFF...] (max entity_id)
        ~end_key = Self.encode_property_key_internal(prop_key_id, &value_encoded, 0xFFFFFFFFFFFFFFFF);

        # Range scan
        ~entries = self.tree.range_scan(&start_key, &end_key, pool)?;

        # Extract entity_ids from keys
        ~i: u64 = 0;
        L while i < entries.len() {
            ~key = &entries[i].0;
            M Self.decode_property_key(key) {
                Some((~decoded_prop_key_id, ~_value, ~entity_id)) => {
                    I decoded_prop_key_id == prop_key_id {
                        results.push(entity_id);
                    }
                },
                None => {
                    # Corrupted key, skip
                },
            }
            i += 1;
        }

        Ok(results)
    }

    # Range scan on property values
    # Returns all entities where min_value <= property_value <= max_value
    F range_scan(
        self,
        prop_key_id: u16,
        min_value: &PropertyValue,
        max_value: &PropertyValue,
        pool: &~BufferPool,
    ) -> Result<Vec<u64>, VaisError> {
        ~results = Vec.new();

        # Encode min and max values
        ~min_encoded = Self.encode_property_value(min_value)?;
        ~max_encoded = Self.encode_property_value(max_value)?;

        # Create start key: [prop_key_id][min_value]
        ~start_key = Self.encode_property_prefix(prop_key_id, &min_encoded);

        # Create end key: [prop_key_id][max_value][0xFF...]
        ~end_key = Self.encode_property_key_internal(prop_key_id, &max_encoded, 0xFFFFFFFFFFFFFFFF);

        # Range scan
        ~entries = self.tree.range_scan(&start_key, &end_key, pool)?;

        # Extract entity_ids
        ~i: u64 = 0;
        L while i < entries.len() {
            ~key = &entries[i].0;
            M Self.decode_property_key(key) {
                Some((~decoded_prop_key_id, ~_value, ~entity_id)) => {
                    I decoded_prop_key_id == prop_key_id {
                        results.push(entity_id);
                    }
                },
                None => {
                    # Corrupted key, skip
                },
            }
            i += 1;
        }

        Ok(results)
    }

    # Encode composite key: [prop_key_id (u16 BE)][encoded_value][entity_id (u64 BE)]
    F encode_property_key(
        prop_key_id: u16,
        value: &PropertyValue,
        entity_id: u64,
    ) -> Result<Vec<u8>, VaisError> {
        ~value_bytes = Self.encode_property_value(value)?;
        Ok(Self.encode_property_key_internal(prop_key_id, &value_bytes, entity_id))
    }

    # Internal: encode with pre-encoded value bytes
    F encode_property_key_internal(
        prop_key_id: u16,
        value_bytes: &[u8],
        entity_id: u64,
    ) -> Vec<u8> {
        ~capacity = 2 + value_bytes.len() + 8;
        ~key = Vec.with_capacity(capacity);

        # Encode prop_key_id (u16 BE)
        key.push(((prop_key_id >> 8) & 0xFF) as u8);
        key.push((prop_key_id & 0xFF) as u8);

        # Append encoded value
        ~i: u64 = 0;
        L while i < value_bytes.len() {
            key.push(value_bytes[i]);
            i += 1;
        }

        # Encode entity_id (u64 BE)
        ~entity_bytes = encode_u64_key(entity_id);
        i = 0;
        L while i < entity_bytes.len() {
            key.push(entity_bytes[i]);
            i += 1;
        }

        key
    }

    # Encode property prefix key for range scan: [prop_key_id (u16 BE)][encoded_value]
    F encode_property_prefix(prop_key_id: u16, value_bytes: &[u8]) -> Vec<u8> {
        ~capacity = 2 + value_bytes.len();
        ~key = Vec.with_capacity(capacity);

        # Encode prop_key_id (u16 BE)
        key.push(((prop_key_id >> 8) & 0xFF) as u8);
        key.push((prop_key_id & 0xFF) as u8);

        # Append encoded value
        ~i: u64 = 0;
        L while i < value_bytes.len() {
            key.push(value_bytes[i]);
            i += 1;
        }

        key
    }

    # Encode property value for index key
    # Format: [type_byte][encoded_value]
    F encode_property_value(value: &PropertyValue) -> Result<Vec<u8>, VaisError> {
        ~encoded = Vec.new();
        encoded.push(value.prop_type);

        M value.prop_type {
            PROP_TYPE_NULL => {
                # No additional bytes for null
            },
            PROP_TYPE_INT => {
                # Encode i64 with sign-flip for correct sort order
                ~int_bytes = encode_i64_key(value.int_val);
                ~i: u64 = 0;
                L while i < int_bytes.len() {
                    encoded.push(int_bytes[i]);
                    i += 1;
                }
            },
            PROP_TYPE_FLOAT => {
                # Encode f64 bits as u64 (big-endian)
                # For correct sort order, flip sign bit for negatives
                ~bits = value.float_val.to_bits();
                ~flipped = I (bits & 0x8000000000000000) != 0 {
                    # Negative: flip all bits
                    !bits
                } E {
                    # Positive: flip sign bit only
                    bits ^ 0x8000000000000000
                };

                encoded.push(((flipped >> 56) & 0xFF) as u8);
                encoded.push(((flipped >> 48) & 0xFF) as u8);
                encoded.push(((flipped >> 40) & 0xFF) as u8);
                encoded.push(((flipped >> 32) & 0xFF) as u8);
                encoded.push(((flipped >> 24) & 0xFF) as u8);
                encoded.push(((flipped >> 16) & 0xFF) as u8);
                encoded.push(((flipped >> 8) & 0xFF) as u8);
                encoded.push((flipped & 0xFF) as u8);
            },
            PROP_TYPE_STRING => {
                # Length-prefixed UTF-8 (u16 length + bytes)
                ~str_bytes = value.string_val.as_bytes();
                ~len = str_bytes.len() as u16;
                encoded.push(((len >> 8) & 0xFF) as u8);
                encoded.push((len & 0xFF) as u8);

                ~i: u64 = 0;
                L while i < str_bytes.len() {
                    encoded.push(str_bytes[i]);
                    i += 1;
                }
            },
            PROP_TYPE_BOOL => {
                # Boolean: 0 or 1
                encoded.push(I value.bool_val { 1 } E { 0 });
            },
            PROP_TYPE_BYTES => {
                # Not typically indexed, but support it with length prefix
                ~len = value.bytes_val.len() as u16;
                encoded.push(((len >> 8) & 0xFF) as u8);
                encoded.push((len & 0xFF) as u8);

                ~i: u64 = 0;
                L while i < value.bytes_val.len() {
                    encoded.push(value.bytes_val[i]);
                    i += 1;
                }
            },
            _ => {
                R Err(err_property_index_unsupported_type(value.prop_type));
            },
        }

        Ok(encoded)
    }

    # Decode property key back to (prop_key_id, value_bytes, entity_id)
    # Note: value_bytes is the raw encoded value, not fully decoded PropertyValue
    F decode_property_key(key: &[u8]) -> Option<(u16, Vec<u8>, u64)> {
        I key.len() < 11 {  # Minimum: 2 (prop_key_id) + 1 (type) + 8 (entity_id)
            R None;
        }

        # Decode prop_key_id (u16 BE)
        ~prop_key_id = ((key[0] as u16) << 8) | (key[1] as u16);

        # Extract entity_id from the last 8 bytes
        ~entity_id_offset = key.len() - 8;
        ~entity_id: u64 = 0;
        entity_id |= (key[entity_id_offset] as u64) << 56;
        entity_id |= (key[entity_id_offset + 1] as u64) << 48;
        entity_id |= (key[entity_id_offset + 2] as u64) << 40;
        entity_id |= (key[entity_id_offset + 3] as u64) << 32;
        entity_id |= (key[entity_id_offset + 4] as u64) << 24;
        entity_id |= (key[entity_id_offset + 5] as u64) << 16;
        entity_id |= (key[entity_id_offset + 6] as u64) << 8;
        entity_id |= key[entity_id_offset + 7] as u64;

        # Value bytes are between prop_key_id and entity_id
        ~value_bytes = key[2..entity_id_offset].to_vec();

        Some((prop_key_id, value_bytes, entity_id))
    }

    # Get underlying B+Tree (for advanced operations)
    F get_tree(self) -> &BTree {
        &self.tree
    }

    F get_tree_mut(~self) -> &~BTree {
        &self.tree
    }
}
