# Server Authentication & TLS
# Authentication mechanisms and TLS configuration for the TCP server.
# Supports: cleartext, MD5, API key, and token-based auth.
# Error codes: EE=06 (server), CC=06 (auth)

U std/vec.Vec;
U std/string.Str;
U std/option.{Option, Some, None};
U std/hashmap.HashMap;
U storage/error.{VaisError, ErrorSeverity};
U server/config.ServerConfig;

# ============================================================================
# Authentication Method
# ============================================================================

# Auth method: 0=cleartext, 1=md5, 2=api_key, 3=token
L AuthMethod = Cleartext | Md5 | ApiKey | Token;

# Wire byte → AuthMethod
F auth_method_from_byte(b: u8) -> Option<AuthMethod> {
    I b == 0 {
        Some(AuthMethod.Cleartext)
    } E I b == 1 {
        Some(AuthMethod.Md5)
    } E I b == 2 {
        Some(AuthMethod.ApiKey)
    } E I b == 3 {
        Some(AuthMethod.Token)
    } E {
        None
    }
}

# AuthMethod → wire byte
F auth_method_to_byte(method: &AuthMethod) -> u8 {
    M method {
        AuthMethod.Cleartext => 0,
        AuthMethod.Md5 => 1,
        AuthMethod.ApiKey => 2,
        AuthMethod.Token => 3,
    }
}

# ============================================================================
# Authentication Config
# ============================================================================

S AuthConfig {
    method: AuthMethod,
    require_tls: bool,
}

X AuthConfig {
    F new(method: AuthMethod, require_tls: bool) -> AuthConfig {
        AuthConfig { method, require_tls }
    }

    F default() -> AuthConfig {
        AuthConfig {
            method: AuthMethod.Cleartext,
            require_tls: false,
        }
    }
}

# ============================================================================
# User Credential
# ============================================================================

S UserCredential {
    username: Str,
    password_hash: Str,     # Cleartext or MD5 hash
    api_key: Option<Str>,
    is_superuser: bool,
}

X UserCredential {
    F new(username: Str, password_hash: Str, api_key: Option<Str>, is_superuser: bool) -> UserCredential {
        UserCredential { username, password_hash, api_key, is_superuser }
    }

    F default_user() -> UserCredential {
        UserCredential {
            username: "vaisdb",
            password_hash: "vaisdb",
            api_key: None,
            is_superuser: true,
        }
    }
}

# Authentication result
S AuthResult {
    authenticated: bool,
    user: Str,
    is_superuser: bool,
}

X AuthResult {
    F success(user: Str, is_superuser: bool) -> AuthResult {
        AuthResult { authenticated: true, user, is_superuser }
    }

    F failure(user: Str) -> AuthResult {
        AuthResult { authenticated: false, user, is_superuser: false }
    }
}

# ============================================================================
# Credential Store
# ============================================================================

S CredentialStore {
    users: HashMap<Str, UserCredential>,
}

X CredentialStore {
    F new() -> CredentialStore {
        ~store = HashMap.new();
        ~default_user = UserCredential.default_user();
        store.insert(default_user.username.clone(), default_user);
        CredentialStore { users: store }
    }

    F add_user(~self, credential: UserCredential) {
        self.users.insert(credential.username.clone(), credential);
    }

    F remove_user(~self, username: &Str) -> bool {
        M self.users.remove(username) {
            Some(_) => true,
            None => false,
        }
    }

    F get_user(self, username: &Str) -> Option<&UserCredential> {
        self.users.get(username)
    }

    # Validate credentials against stored user
    F validate(self, method: &AuthMethod, username: &Str, credential: &Str) -> Result<bool, VaisError> {
        ~user_cred = M self.users.get(username) {
            Some(cred) => cred,
            None => { R Err(err_user_not_found(username.clone())); },
        };

        M method {
            AuthMethod.Cleartext => {
                Ok(*credential == user_cred.password_hash)
            },
            AuthMethod.Md5 => {
                # Placeholder: compare credential directly to hash
                # Production: compute md5(password + username) and compare
                Ok(*credential == user_cred.password_hash)
            },
            AuthMethod.ApiKey => {
                M &user_cred.api_key {
                    Some(key) => Ok(*credential == *key),
                    None => Ok(false),
                }
            },
            AuthMethod.Token => {
                Err(err_auth_method_not_supported("Token"))
            },
        }
    }
}

# ============================================================================
# Authenticator — Main authentication engine
# ============================================================================

S Authenticator {
    config: AuthConfig,
    store: CredentialStore,
}

X Authenticator {
    F new(config: AuthConfig) -> Authenticator {
        Authenticator { config, store: CredentialStore.new() }
    }

    F default() -> Authenticator {
        Authenticator {
            config: AuthConfig.default(),
            store: CredentialStore.new(),
        }
    }

    F add_user(~self, credential: UserCredential) {
        self.store.add_user(credential);
    }

    F remove_user(~self, username: &Str) -> bool {
        self.store.remove_user(username)
    }

    # Authenticate a user with the given method and credential
    F authenticate(self, method: &AuthMethod, username: &Str, credential: &Str) -> Result<AuthResult, VaisError> {
        ~is_valid = self.store.validate(method, username, credential)?;

        I !is_valid {
            R Err(err_invalid_credentials(username.clone()));
        }

        ~user_cred = M self.store.get_user(username) {
            Some(cred) => cred,
            None => { R Err(err_user_not_found(username.clone())); },
        };

        Ok(AuthResult.success(username.clone(), user_cred.is_superuser))
    }

    # Get the configured auth method byte for wire protocol
    F auth_method_byte(self) -> u8 {
        auth_method_to_byte(&self.config.method)
    }

    F requires_tls(self) -> bool {
        self.config.require_tls
    }

    F get_store(self) -> &CredentialStore {
        &self.store
    }

    F get_store_mut(~self) -> &~CredentialStore {
        &self.store
    }
}

# ============================================================================
# TLS Configuration
# ============================================================================

S TlsConfig {
    cert_path: Str,
    key_path: Str,
    enabled: bool,
}

X TlsConfig {
    F new(cert_path: Str, key_path: Str) -> TlsConfig {
        ~enabled = cert_path.len() > 0 && key_path.len() > 0;
        TlsConfig { cert_path, key_path, enabled }
    }

    F disabled() -> TlsConfig {
        TlsConfig { cert_path: "", key_path: "", enabled: false }
    }

    F from_server_config(config: &ServerConfig) -> TlsConfig {
        I config.has_tls() {
            TlsConfig.new(config.tls_cert_file.clone(), config.tls_key_file.clone())
        } E {
            TlsConfig.disabled()
        }
    }

    F is_enabled(self) -> bool {
        self.enabled
    }

    F get_cert_path(self) -> &Str {
        &self.cert_path
    }

    F get_key_path(self) -> &Str {
        &self.key_path
    }
}

# ============================================================================
# Error Constructors
# ============================================================================

F err_auth_method_not_supported(method: Str) -> VaisError {
    VaisError.new(
        "VAIS-0606002",
        "Authentication method not supported: {method}"
    )
}

F err_user_not_found(user: Str) -> VaisError {
    VaisError.new(
        "VAIS-0606003",
        "User not found: '{user}'"
    )
}

F err_invalid_credentials(user: Str) -> VaisError {
    VaisError.new(
        "VAIS-0606004",
        "Invalid credentials for user '{user}'"
    )
}

F err_tls_required() -> VaisError {
    VaisError.new(
        "VAIS-0608003",
        "TLS connection required for this authentication method"
    ).with_severity(ErrorSeverity.Fatal)
}
