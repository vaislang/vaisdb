# TCP Server & Accept Loop
# Listens on configurable port, accepts connections, dispatches to handlers
# Requires std/net for actual TCP I/O — placeholder implementation
# Error codes: EE=06 (server), CC=03 (connection), CC=07 (listener)

U std/vec.Vec;
U std/string.Str;
U std/option.{Option, Some, None};
U std/sync.{Mutex, AtomicU64, Ordering};
U storage/error.{VaisError, ErrorSeverity};
U server/types.{
    ConnectionState, TransactionState,
    StartupPayload, ErrorResponse,
    MSG_TYPE_STARTUP, MSG_TYPE_AUTH_RESPONSE, MSG_TYPE_TERMINATE,
    PROTOCOL_VERSION_MAJOR, PROTOCOL_VERSION_MINOR,
    err_protocol_error, err_protocol_version, err_max_connections,
    err_connection_reset,
};
U server/config.{ServerConfig, GlobalConfig};
U server/connection.{Connection, ConnectionPool};
U server/auth.{Authenticator, AuthResult, TlsConfig};
U server/handler.QueryHandler;
U server/protocol.{
    read_framed_message, FramedMessage,
    serialize_auth_request, serialize_auth_ok,
    serialize_ready, serialize_error,
    deserialize_startup, deserialize_auth_response,
};

# ============================================================================
# Server State
# ============================================================================

L ServerState = Starting | Running | ShuttingDown | Stopped;

# ============================================================================
# TcpServer — Main server struct
# ============================================================================

S TcpServer {
    config: ServerConfig,
    global_config: GlobalConfig,
    pool: ConnectionPool,
    auth: Authenticator,
    tls_config: TlsConfig,
    state: ServerState,
    total_queries: AtomicU64,
    total_connections: AtomicU64,
    # FUTURE(std/net): TcpListener handle
}

X TcpServer {
    # Create new server from configuration
    F new(config: ServerConfig) -> Result<TcpServer, VaisError> {
        # Validate configuration
        config.validate()?;

        ~global_config = GlobalConfig.new(config);
        ~pool = ConnectionPool.from_config(&config);
        ~auth = Authenticator.default();
        ~tls_config = TlsConfig.from_server_config(&config);

        Ok(TcpServer {
            config,
            global_config,
            pool,
            auth,
            tls_config,
            state: ServerState.Starting,
            total_queries: AtomicU64.new(0),
            total_connections: AtomicU64.new(0),
        })
    }

    # Start the server (bind and listen)
    # FUTURE(std/net): Bind address, accept loop, startup logging
    F start(~self) -> Result<(), VaisError> {
        # Placeholder: transition state without actual TCP bind
        self.state = ServerState.Running;
        Ok(())
    }

    # Stop the server gracefully
    F stop(~self) -> Result<(), VaisError> {
        self.state = ServerState.ShuttingDown;

        # Close all active connections
        ~conn_ids = self.pool.connection_ids();
        ~i: u64 = 0;
        W i < conn_ids.len() {
            self.pool.remove_connection(conn_ids[i]);
            i += 1;
        }

        # FUTURE(std/net): Close TcpListener, drain in-flight queries, flush WAL + checkpoint
        self.state = ServerState.Stopped;
        Ok(())
    }

    # Check if server is running
    F is_running(self) -> bool {
        M &self.state {
            ServerState.Running => true,
            _ => false,
        }
    }

    # Get server statistics
    F get_stats(self) -> ServerStats {
        ServerStats {
            active_connections: self.pool.active_count(),
            total_connections: self.total_connections.load(Ordering.Relaxed),
            total_queries: self.total_queries.load(Ordering.Relaxed),
            max_connections: self.config.max_connections,
            port: self.config.port,
        }
    }

    # ========================================================================
    # Connection Lifecycle
    # ========================================================================

    # Handle a new incoming TCP connection.
    # This is called by the accept loop for each new connection.
    # Returns the connection ID.
    F accept_connection(~self, timestamp: u64) -> Result<u64, VaisError> {
        I !self.is_running() {
            R Err(err_server_not_running());
        }

        I !self.pool.has_capacity() {
            R Err(err_max_connections(self.config.max_connections));
        }

        # Create connection with placeholder user/database (filled in during startup)
        ~conn_id = self.pool.create_connection("", "", timestamp)?;
        self.total_connections.fetch_add(1, Ordering.Relaxed);

        Ok(conn_id)
    }

    # Handle startup message from newly connected client.
    # Validates protocol version, extracts user/database, initiates auth.
    F handle_startup(
        ~self,
        conn_id: u64,
        startup: &StartupPayload,
    ) -> Result<Vec<Vec<u8>>, VaisError> {
        # Check protocol version
        I startup.protocol_major != PROTOCOL_VERSION_MAJOR {
            R Err(err_protocol_version(startup.protocol_major, startup.protocol_minor));
        }

        # Extract user and database
        ~user = M startup.get_param(&"user") {
            Some(u) => u.clone(),
            None => "vaisdb",
        };

        ~database = M startup.get_param(&"database") {
            Some(d) => d.clone(),
            None => "vaisdb",
        };

        ~app_name = M startup.get_param(&"application_name") {
            Some(a) => a.clone(),
            None => "",
        };

        # Update connection with user info
        self.pool.with_connection(conn_id, |conn| {
            conn.user = user.clone();
            conn.database = database.clone();
            conn.application_name = app_name;
            conn.set_state(ConnectionState.Authenticating)
        })??;

        # Send auth request
        ~responses = Vec.new();
        ~auth_method_byte = self.auth.auth_method_byte();
        responses.push(serialize_auth_request(auth_method_byte));

        Ok(responses)
    }

    # Handle auth response from client
    F handle_auth_response(
        ~self,
        conn_id: u64,
        credentials: &Str,
    ) -> Result<Vec<Vec<u8>>, VaisError> {
        ~responses = Vec.new();

        # Get user from connection
        ~user = self.pool.with_connection_ref(conn_id, |conn| {
            conn.get_user().clone()
        })?;

        # Authenticate
        ~auth_result = self.auth.authenticate(
            &self.auth.get_config().method,
            &user,
            credentials,
        )?;

        # Auth succeeded — transition to Ready
        self.pool.with_connection(conn_id, |conn| {
            conn.set_state(ConnectionState.Ready)
        })??;

        responses.push(serialize_auth_ok());
        responses.push(serialize_ready(&TransactionState.Idle));

        Ok(responses)
    }

    # Process a framed message for an authenticated connection
    F process_message(
        ~self,
        conn_id: u64,
        msg: &FramedMessage,
    ) -> Result<Vec<Vec<u8>>, VaisError> {
        ~handler = QueryHandler.new(conn_id);

        I msg.msg_type == MSG_TYPE_QUERY {
            self.total_queries.fetch_add(1, Ordering.Relaxed);
        }

        handler.handle_message(msg, &self.pool)
    }

    # Disconnect a client (cleanup)
    F disconnect(~self, conn_id: u64) {
        self.pool.remove_connection(conn_id);
    }

    # ========================================================================
    # Configuration Access
    # ========================================================================

    F get_config(self) -> &ServerConfig {
        &self.config
    }

    F get_global_config(self) -> &GlobalConfig {
        &self.global_config
    }

    F get_global_config_mut(~self) -> &~GlobalConfig {
        &self.global_config
    }

    F get_auth(self) -> &Authenticator {
        &self.auth
    }

    F get_auth_mut(~self) -> &~Authenticator {
        &self.auth
    }

    F get_pool(self) -> &ConnectionPool {
        &self.pool
    }
}

# ============================================================================
# Server Statistics
# ============================================================================

S ServerStats {
    active_connections: u64,
    total_connections: u64,
    total_queries: u64,
    max_connections: u32,
    port: u16,
}

X ServerStats {
    F new() -> ServerStats {
        ServerStats {
            active_connections: 0,
            total_connections: 0,
            total_queries: 0,
            max_connections: 0,
            port: 0,
        }
    }
}

# ============================================================================
# Connection Event Loop (per-connection message processing)
# ============================================================================

# Process raw bytes received from a TCP connection.
# Accumulates data in recv_buffer until a complete message is available.
# Returns response bytes to send back.
S ConnectionProcessor {
    conn_id: u64,
    recv_buffer: Vec<u8>,
    is_authenticated: bool,
    is_startup_done: bool,
}

X ConnectionProcessor {
    F new(conn_id: u64) -> ConnectionProcessor {
        ConnectionProcessor {
            conn_id,
            recv_buffer: Vec.new(),
            is_authenticated: false,
            is_startup_done: false,
        }
    }

    # Append received data and try to process complete messages.
    # Returns all response messages to send.
    F on_data_received(
        ~self,
        data: &[u8],
        server: &~TcpServer,
    ) -> Result<Vec<Vec<u8>>, VaisError> {
        # Append to recv buffer
        ~i: u64 = 0;
        W i < data.len() {
            self.recv_buffer.push(data[i]);
            i += 1;
        }

        ~all_responses = Vec.new();

        # Try to parse and process complete messages
        ~processing = true;
        W processing {
            M read_framed_message(&self.recv_buffer) {
                Ok(msg) => {
                    # Remove consumed bytes from buffer
                    ~consumed = msg.total_wire_len as u64;
                    ~new_buf = Vec.new();
                    ~j: u64 = consumed;
                    W j < self.recv_buffer.len() {
                        new_buf.push(self.recv_buffer[j]);
                        j += 1;
                    }
                    self.recv_buffer = new_buf;

                    # Route message
                    ~responses = I !self.is_startup_done {
                        # First message must be Startup
                        ~reader = msg.payload_reader();
                        ~startup = deserialize_startup(&reader)?;
                        self.is_startup_done = true;
                        server.handle_startup(self.conn_id, &startup)?
                    } E I !self.is_authenticated {
                        # Next message should be AuthResponse
                        ~reader = msg.payload_reader();
                        ~credentials = deserialize_auth_response(&reader)?;
                        self.is_authenticated = true;
                        server.handle_auth_response(self.conn_id, &credentials)?
                    } E {
                        # Normal message processing
                        server.process_message(self.conn_id, &msg)?
                    };

                    # Collect responses
                    ~r: u64 = 0;
                    W r < responses.len() {
                        all_responses.push(responses[r].clone());
                        r += 1;
                    }
                },
                Err(_) => {
                    # Incomplete message — wait for more data
                    processing = false;
                },
            }
        }

        Ok(all_responses)
    }

    # Check if this connection is authenticated and ready
    F is_ready(self) -> bool {
        self.is_authenticated
    }
}

# ============================================================================
# Error Constructors
# ============================================================================

F err_server_not_running() -> VaisError {
    VaisError.new(
        "VAIS-0607001",
        "Server is not running"
    ).with_severity(ErrorSeverity.Fatal)
}

F err_server_bind_failed(addr: Str, port: u16) -> VaisError {
    VaisError.new(
        "VAIS-0607002",
        "Failed to bind to {addr}:{port}"
    ).with_severity(ErrorSeverity.Fatal)
}

F err_server_accept_failed() -> VaisError {
    VaisError.new(
        "VAIS-0607003",
        "Failed to accept incoming connection"
    )
}
