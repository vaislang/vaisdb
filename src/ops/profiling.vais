# Production Operations — Slow Query Log & Profiling
# Phase 9 Task 7: Slow query logging with per-engine breakdown
# Provides: SlowQueryLogger (ring buffer + file logger), QueryProfiler

U std/vec.Vec;
U std/string.Str;
U std/option.{Option, Some, None};
U std/sync.{Mutex};
U storage/error.{VaisError};
U ops/types.{
    SlowQueryEntry, QueryProfile,
    SLOW_QUERY_SORT_DURATION, SLOW_QUERY_SORT_TIMESTAMP, SLOW_QUERY_SORT_ROWS_SCANNED,
    err_slow_query_log_full,
};
U ops/config.{SlowQueryConfig};

# ============================================================================
# SlowQueryLogger — Ring buffer for recent slow queries + file logging
# ============================================================================

## Captures queries that exceed the configured threshold.
## Stores up to ring_buffer_size entries in memory (oldest evicted).
## Optionally appends to a slow query log file.
S SlowQueryLogger {
    config: SlowQueryConfig,
    buffer: Vec<SlowQueryEntry>,     # Ring buffer storage
    write_pos: u64,                  # Next write position (modular)
    count: u64,                      # Total entries written (may exceed buffer size)
    lock: Mutex,                     # Protects buffer writes
    next_query_id: u64,              # Monotonic query ID counter
}

X SlowQueryLogger {
    ## Create a new slow query logger
    F new(config: SlowQueryConfig) -> SlowQueryLogger {
        ~capacity = config.ring_buffer_size as u64;
        SlowQueryLogger {
            config,
            buffer: Vec.with_capacity(capacity),
            write_pos: 0,
            count: 0,
            lock: Mutex.new(),
            next_query_id: 1,
        }
    }

    ## Check if a query's duration exceeds the slow query threshold
    F is_slow(self, duration_ms: u64) -> bool {
        self.config.enabled && duration_ms >= self.config.threshold_ms as u64
    }

    ## Record a slow query entry
    ## Returns the assigned query_id, or None if logging is disabled
    F record(~self, entry: SlowQueryEntry) -> Option<u64> {
        I !self.config.enabled {
            R None;
        }

        ~guard = self.lock.lock();

        # Assign query ID
        ~query_id = self.next_query_id;
        self.next_query_id = self.next_query_id + 1;

        # Truncate query text if needed
        ~truncated_entry = entry;
        I truncated_entry.query_text.len() as u32 > self.config.max_query_length {
            truncated_entry.query_text = truncated_entry.query_text
                .substring(0, self.config.max_query_length as u64);
        }
        truncated_entry.query_id = query_id;

        # Write to ring buffer
        ~capacity = self.config.ring_buffer_size as u64;
        I self.buffer.len() < capacity {
            # Buffer not yet full, just push
            self.buffer.push(truncated_entry);
        } E {
            # Buffer full, overwrite oldest entry
            ~idx = self.write_pos % capacity;
            self.buffer[idx] = truncated_entry;
        }

        self.write_pos = self.write_pos + 1;
        self.count = self.count + 1;

        Some(query_id)
    }

    ## Get recent slow queries from the ring buffer
    ## Returns entries sorted by the specified order
    F get_recent(self, limit: u32, sort_by: u8) -> Vec<SlowQueryEntry> {
        ~guard = self.lock.lock();

        ~capacity = self.config.ring_buffer_size as u64;
        ~result = Vec.new();

        # Determine how many entries are actually stored
        ~stored = I self.buffer.len() < capacity {
            self.buffer.len()
        } E {
            capacity
        };

        # Copy entries out (most recent first)
        ~copied: u64 = 0;
        ~max_copy = I (limit as u64) < stored { limit as u64 } E { stored };

        I stored > 0 {
            ~read_pos = I self.write_pos > 0 { self.write_pos - 1 } E { 0 };
            W copied < max_copy {
                ~idx = read_pos % capacity;
                result.push(self.buffer[idx].clone());
                copied = copied + 1;
                I read_pos == 0 {
                    # Wrapped around or reached beginning
                    read_pos = capacity - 1;
                } E {
                    read_pos = read_pos - 1;
                }
            }
        }

        # Sort by requested field
        M sort_by {
            0 => {
                # SLOW_QUERY_SORT_DURATION: sort by duration descending
                sort_by_duration_desc(&~result);
            },
            1 => {
                # SLOW_QUERY_SORT_TIMESTAMP: already in reverse chronological order
            },
            2 => {
                # SLOW_QUERY_SORT_ROWS_SCANNED: sort by rows_scanned descending
                sort_by_rows_scanned_desc(&~result);
            },
            _ => {},
        }

        result
    }

    ## Get total number of slow queries recorded since startup
    F total_count(self) -> u64 {
        self.count
    }

    ## Get current buffer utilization
    F buffer_utilization(self) -> f64 {
        I self.config.ring_buffer_size == 0 {
            R 0.0;
        }
        (self.buffer.len() as f64) / (self.config.ring_buffer_size as f64)
    }

    ## Clear the ring buffer
    F clear(~self) {
        ~guard = self.lock.lock();
        self.buffer.clear();
        self.write_pos = 0;
    }

    ## Format a slow query entry as a log line (for file output)
    F format_log_line(self, entry: &SlowQueryEntry) -> Str {
        ~engines = "";
        ~i: u64 = 0;
        W i < entry.engines_used.len() {
            I i > 0 {
                engines = "{engines},";
            }
            engines = "{engines}{entry.engines_used[i]}";
            i = i + 1;
        }

        ~hit_rate = entry.buffer_hit_rate();
        "[SLOW] id={entry.query_id} duration={entry.duration_ms}ms plan={entry.plan_time_ms}ms exec={entry.exec_time_ms}ms rows_scanned={entry.rows_scanned} rows_returned={entry.rows_returned} buffer_hit_rate={hit_rate:.3} lock_wait={entry.lock_wait_ms}ms memory={entry.memory_used_bytes}B engines=[{engines}] user={entry.user_name} client={entry.client_address} sql=\"{entry.query_text}\""
    }
}

# ============================================================================
# QueryProfiler — Tracks execution profile for a single query
# ============================================================================

## Created at query start, updated during execution, finalized at query end.
## Captures per-engine timing and I/O statistics.
S QueryProfiler {
    profile: QueryProfile,
    is_active: bool,
    start_time_ns: u64,              # Nanosecond timestamp at query start
    # Per-engine start timestamps (for computing duration)
    sql_start_ns: u64,
    vector_start_ns: u64,
    graph_start_ns: u64,
    fulltext_start_ns: u64,
    fusion_start_ns: u64,
}

X QueryProfiler {
    ## Create a new profiler for a query
    F new(query_text: Str) -> QueryProfiler {
        QueryProfiler {
            profile: QueryProfile.new(query_text),
            is_active: false,
            start_time_ns: 0,
            sql_start_ns: 0,
            vector_start_ns: 0,
            graph_start_ns: 0,
            fulltext_start_ns: 0,
            fusion_start_ns: 0,
        }
    }

    ## Start profiling (record start timestamp)
    F start(~self, current_ns: u64) {
        self.start_time_ns = current_ns;
        self.is_active = true;
    }

    ## Mark start of planning phase
    F start_planning(~self, current_ns: u64) {
        # Planning start is the query start
        self.start_time_ns = current_ns;
    }

    ## Mark end of planning phase, start of execution phase
    F end_planning(~self, current_ns: u64) {
        I self.start_time_ns > 0 {
            self.profile.plan_time_ms = (current_ns - self.start_time_ns) / 1000000;
        }
    }

    ## Mark start of SQL engine work
    F start_sql(~self, current_ns: u64) {
        self.sql_start_ns = current_ns;
    }

    ## Mark end of SQL engine work
    F end_sql(~self, current_ns: u64) {
        I self.sql_start_ns > 0 {
            self.profile.sql_time_us = self.profile.sql_time_us
                + (current_ns - self.sql_start_ns) / 1000;
            self.sql_start_ns = 0;
        }
    }

    ## Mark start of vector engine work
    F start_vector(~self, current_ns: u64) {
        self.vector_start_ns = current_ns;
    }

    ## Mark end of vector engine work
    F end_vector(~self, current_ns: u64) {
        I self.vector_start_ns > 0 {
            self.profile.vector_time_us = self.profile.vector_time_us
                + (current_ns - self.vector_start_ns) / 1000;
            self.vector_start_ns = 0;
        }
    }

    ## Mark start of graph engine work
    F start_graph(~self, current_ns: u64) {
        self.graph_start_ns = current_ns;
    }

    ## Mark end of graph engine work
    F end_graph(~self, current_ns: u64) {
        I self.graph_start_ns > 0 {
            self.profile.graph_time_us = self.profile.graph_time_us
                + (current_ns - self.graph_start_ns) / 1000;
            self.graph_start_ns = 0;
        }
    }

    ## Mark start of full-text engine work
    F start_fulltext(~self, current_ns: u64) {
        self.fulltext_start_ns = current_ns;
    }

    ## Mark end of full-text engine work
    F end_fulltext(~self, current_ns: u64) {
        I self.fulltext_start_ns > 0 {
            self.profile.fulltext_time_us = self.profile.fulltext_time_us
                + (current_ns - self.fulltext_start_ns) / 1000;
            self.fulltext_start_ns = 0;
        }
    }

    ## Mark start of score fusion work
    F start_fusion(~self, current_ns: u64) {
        self.fusion_start_ns = current_ns;
    }

    ## Mark end of score fusion work
    F end_fusion(~self, current_ns: u64) {
        I self.fusion_start_ns > 0 {
            self.profile.fusion_time_us = self.profile.fusion_time_us
                + (current_ns - self.fusion_start_ns) / 1000;
            self.fusion_start_ns = 0;
        }
    }

    ## Record I/O statistics
    F record_io(~self, pages_read: u64, pages_written: u64, hits: u64, misses: u64) {
        self.profile.pages_read = self.profile.pages_read + pages_read;
        self.profile.pages_written = self.profile.pages_written + pages_written;
        self.profile.buffer_hits = self.profile.buffer_hits + hits;
        self.profile.buffer_misses = self.profile.buffer_misses + misses;
    }

    ## Record lock statistics
    F record_lock(~self, acquisitions: u64, wait_time_us: u64) {
        self.profile.lock_acquisitions = self.profile.lock_acquisitions + acquisitions;
        self.profile.lock_wait_time_us = self.profile.lock_wait_time_us + wait_time_us;
    }

    ## Finalize profiling: compute total duration
    F finish(~self, current_ns: u64, rows_produced: u64) {
        I self.start_time_ns > 0 {
            ~total_ns = current_ns - self.start_time_ns;
            self.profile.total_duration_ms = total_ns / 1000000;
            self.profile.exec_time_ms = self.profile.total_duration_ms - self.profile.plan_time_ms;
        }
        self.profile.rows_produced = rows_produced;
        self.profile.peak_memory_bytes = 0;  # FUTURE(memory): Integrate with memory tracking subsystem
        self.is_active = false;
    }

    ## Get the completed profile
    F get_profile(self) -> &QueryProfile {
        &self.profile
    }

    ## Convert profile into a SlowQueryEntry for the slow query log
    F to_slow_query_entry(self, started_at: i64) -> SlowQueryEntry {
        ~entry = SlowQueryEntry.new(0, self.profile.query_text.clone(), started_at);
        entry.duration_ms = self.profile.total_duration_ms;
        entry.plan_time_ms = self.profile.plan_time_ms;
        entry.exec_time_ms = self.profile.exec_time_ms;
        entry.rows_returned = self.profile.rows_produced;
        entry.buffer_hits = self.profile.buffer_hits;
        entry.buffer_misses = self.profile.buffer_misses;
        entry.memory_used_bytes = self.profile.peak_memory_bytes;
        entry.lock_wait_ms = self.profile.lock_wait_time_us / 1000;

        # Compute engine breakdown percentages
        ~(sql_pct, vec_pct, graph_pct, ft_pct) = self.profile.engine_breakdown();
        entry.set_engine_breakdown(sql_pct, vec_pct, graph_pct, ft_pct);

        # Populate engines_used list
        I self.profile.sql_time_us > 0 {
            entry.engines_used.push("sql");
        }
        I self.profile.vector_time_us > 0 {
            entry.engines_used.push("vector");
        }
        I self.profile.graph_time_us > 0 {
            entry.engines_used.push("graph");
        }
        I self.profile.fulltext_time_us > 0 {
            entry.engines_used.push("fulltext");
        }

        entry
    }
}

# ============================================================================
# Sorting helpers (simple insertion sort for small ring buffer results)
# ============================================================================

## Sort entries by duration descending (slowest first)
F sort_by_duration_desc(entries: &~Vec<SlowQueryEntry>) {
    ~len = entries.len();
    I len <= 1 {
        R;
    }
    ~i: u64 = 1;
    W i < len {
        ~j = i;
        W j > 0 && entries[j].duration_ms > entries[j - 1].duration_ms {
            entries.swap(j, j - 1);
            j = j - 1;
        }
        i = i + 1;
    }
}

## Sort entries by rows_scanned descending
F sort_by_rows_scanned_desc(entries: &~Vec<SlowQueryEntry>) {
    ~len = entries.len();
    I len <= 1 {
        R;
    }
    ~i: u64 = 1;
    W i < len {
        ~j = i;
        W j > 0 && entries[j].rows_scanned > entries[j - 1].rows_scanned {
            entries.swap(j, j - 1);
            j = j - 1;
        }
        i = i + 1;
    }
}
