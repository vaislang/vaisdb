# Production Operations — Logical Backup & Restore
# Phase 9 Task 4: SQL dump (DDL + INSERT), restore verification
# Provides: DumpWriter (logical export), DumpRestorer (logical import)

U std/vec.Vec;
U std/string.Str;
U std/option.{Option, Some, None};
U std/file.{File, file_exists};
U storage/error.{VaisError};
U ops/types.{
    DumpOptions, DumpResult, RestoreOptions,
    err_restore_failed,
};

# ============================================================================
# DumpWriter — Generates SQL dump (logical backup)
# ============================================================================

## Exports database contents as SQL statements:
## - DDL: CREATE TABLE, CREATE INDEX, etc.
## - Data: INSERT INTO ... VALUES (...) for each row
## - Vectors: serialized as array literals in INSERT
## - Graph: node INSERT + edge INSERT (respecting import ordering)
## - Fulltext: index definitions only (data rebuilt via INSERT triggers)
S DumpWriter {
    options: DumpOptions,
}

X DumpWriter {
    ## Create a new dump writer
    F new(options: DumpOptions) -> DumpWriter {
        DumpWriter { options }
    }

    ## Generate the full SQL dump as a string
    ## In production, this would stream to a file writer
    ## Parameters provide access to catalog and data
    F dump_to_string(
        self,
        table_names: &Vec<Str>,
        get_create_table_sql: F(Str) -> Result<Str, VaisError>,
        get_index_sql: F(Str) -> Result<Vec<Str>, VaisError>,
        get_row_sql: F(Str) -> Result<Vec<Str>, VaisError>,
    ) -> Result<(Str, DumpResult), VaisError> {
        ~output = Vec.new();
        ~result = DumpResult.new();

        # Header comment
        output.push("-- VaisDB SQL Dump");
        output.push("-- Format version: 1");
        output.push("");

        # Filter tables if configured
        ~tables_to_dump = M &self.options.table_filter {
            Some(filter) => filter.clone(),
            None => table_names.clone(),
        };

        # Phase 1: DDL (CREATE TABLE + CREATE INDEX)
        I self.options.include_ddl {
            output.push("-- DDL");
            output.push("BEGIN;");
            output.push("");

            ~i: u64 = 0;
            W i < tables_to_dump.len() {
                ~table_name = &tables_to_dump[i];
                ~create_sql = get_create_table_sql(table_name.clone())?;
                output.push(&create_sql);
                output.push("");

                # Indexes for this table
                ~index_sqls = get_index_sql(table_name.clone())?;
                ~j: u64 = 0;
                W j < index_sqls.len() {
                    output.push(&index_sqls[j]);
                    j = j + 1;
                }
                I index_sqls.len() > 0 {
                    output.push("");
                }

                result.tables_dumped = result.tables_dumped + 1;
                i = i + 1;
            }

            output.push("COMMIT;");
            output.push("");
        }

        # Phase 2: Data (INSERT statements)
        I self.options.include_data {
            output.push("-- Data");
            output.push("BEGIN;");
            output.push("");

            ~i: u64 = 0;
            W i < tables_to_dump.len() {
                ~table_name = &tables_to_dump[i];
                ~row_sqls = get_row_sql(table_name.clone())?;

                I row_sqls.len() > 0 {
                    output.push("-- Table: {table_name}");
                    ~j: u64 = 0;
                    W j < row_sqls.len() {
                        output.push(&row_sqls[j]);
                        result.rows_dumped = result.rows_dumped + 1;
                        j = j + 1;
                    }
                    output.push("");
                }

                i = i + 1;
            }

            output.push("COMMIT;");
            output.push("");
        }

        # Join output lines
        ~dump_text = "";
        ~k: u64 = 0;
        W k < output.len() {
            dump_text = "{dump_text}{output[k]}\n";
            k = k + 1;
        }

        result.bytes_written = dump_text.len() as u64;

        Ok((dump_text, result))
    }

    ## Format a vector as a SQL array literal
    ## e.g., ARRAY[0.1, 0.2, 0.3]::VECTOR(3)
    F format_vector_literal(values: &[f32]) -> Str {
        ~parts = Vec.new();
        ~i: u64 = 0;
        W i < values.len() as u64 {
            parts.push("{values[i]}");
            i = i + 1;
        }

        ~inner = "";
        ~j: u64 = 0;
        W j < parts.len() {
            I j > 0 {
                inner = "{inner}, ";
            }
            inner = "{inner}{parts[j]}";
            j = j + 1;
        }

        ~dim = values.len();
        "ARRAY[{inner}]::VECTOR({dim})"
    }

    ## Format a graph node INSERT
    ## INSERT INTO nodes (node_id, label, properties) VALUES (...)
    F format_node_insert(
        table_name: &Str,
        node_id: u64,
        label: &Str,
        properties_json: &Str,
    ) -> Str {
        "INSERT INTO {table_name} (node_id, label, properties) VALUES ({node_id}, '{label}', '{properties_json}');"
    }

    ## Format a graph edge INSERT
    ## INSERT INTO edges (source_id, target_id, edge_type, properties) VALUES (...)
    F format_edge_insert(
        table_name: &Str,
        source_id: u64,
        target_id: u64,
        edge_type: &Str,
        properties_json: &Str,
    ) -> Str {
        "INSERT INTO {table_name} (source_id, target_id, edge_type, properties) VALUES ({source_id}, {target_id}, '{edge_type}', '{properties_json}');"
    }
}

# ============================================================================
# DumpRestorer — Restores from a SQL dump (logical restore)
# ============================================================================

## Reads SQL dump text and executes statements to restore the database.
## Supports single-transaction mode (all-or-nothing) and parallel restore.
S DumpRestorer {
    options: RestoreOptions,
}

X DumpRestorer {
    ## Create a new dump restorer
    F new(options: RestoreOptions) -> DumpRestorer {
        DumpRestorer { options }
    }

    ## Parse and validate a dump file
    ## Returns list of SQL statements found in the dump
    F parse_dump(self, dump_text: &Str) -> Result<Vec<Str>, VaisError> {
        ~statements = Vec.new();

        # Split by semicolons (naive approach; production would use proper tokenizer)
        # Skip comments (lines starting with --)
        ~lines = dump_text.split('\n');
        ~current_stmt = "";

        ~i: u64 = 0;
        W i < lines.len() {
            ~line = lines[i].trim();

            # Skip empty lines and comments
            I line.len() == 0 || line.starts_with("--") {
                i = i + 1;
                # next iteration
            } E {
                I current_stmt.len() > 0 {
                    current_stmt = "{current_stmt} {line}";
                } E {
                    current_stmt = line.to_string();
                }

                # Check for statement terminator
                I line.ends_with(";") {
                    statements.push(current_stmt.clone());
                    current_stmt = "";
                }

                i = i + 1;
            }
        }

        # Don't lose unterminated last statement
        I current_stmt.len() > 0 {
            statements.push(current_stmt);
        }

        Ok(statements)
    }

    ## Execute restore: run all statements from the dump
    ## execute_sql_fn: callback to execute a single SQL statement
    F restore(
        self,
        dump_text: &Str,
        execute_sql_fn: F(Str) -> Result<u64, VaisError>,
    ) -> Result<DumpResult, VaisError> {
        ~result = DumpResult.new();
        ~statements = self.parse_dump(dump_text)?;

        ~i: u64 = 0;
        W i < statements.len() {
            ~stmt = &statements[i];
            M execute_sql_fn(stmt.clone()) {
                Ok(rows_affected) => {
                    result.rows_dumped = result.rows_dumped + rows_affected;
                },
                Err(e) => {
                    I !self.options.ignore_errors {
                        R Err(err_restore_failed(e.to_string()));
                    }
                    # If ignore_errors, continue to next statement
                },
            }
            i = i + 1;
        }

        result.tables_dumped = statements.len() as u32;
        Ok(result)
    }

    ## Verify restore by comparing row counts with original dump
    ## Returns true if all tables have expected row counts
    F verify_restore(
        self,
        expected_counts: &Vec<(Str, u64)>,
        get_row_count_fn: F(Str) -> Result<u64, VaisError>,
    ) -> Result<bool, VaisError> {
        ~i: u64 = 0;
        W i < expected_counts.len() {
            ~(table_name, expected) = &expected_counts[i];
            ~actual = get_row_count_fn(table_name.clone())?;
            I actual != *expected {
                R Ok(false);
            }
            i = i + 1;
        }
        Ok(true)
    }
}
