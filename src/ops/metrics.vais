# Production Operations — Engine-Specific Metrics Collection
# Phase 9 Task 6: Buffer pool, WAL, Transaction, Vector, Graph, Fulltext metrics
# Provides: EngineMetricsCollector with per-engine snapshot collection

U std/vec.Vec;
U std/string.Str;
U std/option.{Option, Some, None};
U std/sync.{RwLock};
U storage/error.{VaisError};
U ops/types.{
    BufferPoolMetrics, WalMetrics, TxnMetrics,
    VectorEngineMetrics, GraphEngineMetrics, FullTextEngineMetrics,
    MetricValue, METRIC_TYPE_COUNTER, METRIC_TYPE_GAUGE,
};
U ops/config.{MetricsConfig};

# ============================================================================
# EngineMetricsCollector — Collects per-engine metrics
# ============================================================================

## Holds the latest snapshot of each engine's metrics
## Updated periodically by the metrics collection loop
## All snapshots are protected by individual RwLocks for fine-grained concurrency
S EngineMetricsCollector {
    config: MetricsConfig,
    buffer_pool: RwLock<BufferPoolMetrics>,
    wal: RwLock<WalMetrics>,
    txn: RwLock<TxnMetrics>,
    vector: RwLock<VectorEngineMetrics>,
    graph: RwLock<GraphEngineMetrics>,
    fulltext: RwLock<FullTextEngineMetrics>,
}

X EngineMetricsCollector {
    ## Create new engine metrics collector with default initial values
    F new(config: MetricsConfig) -> EngineMetricsCollector {
        EngineMetricsCollector {
            config,
            buffer_pool: RwLock.new(BufferPoolMetrics.new(0)),
            wal: RwLock.new(WalMetrics.new(0)),
            txn: RwLock.new(TxnMetrics.new(0)),
            vector: RwLock.new(VectorEngineMetrics.new(0)),
            graph: RwLock.new(GraphEngineMetrics.new(0)),
            fulltext: RwLock.new(FullTextEngineMetrics.new(0)),
        }
    }

    # ========================================================================
    # Buffer Pool Metrics
    # ========================================================================

    ## Update buffer pool metrics snapshot
    F update_buffer_pool(
        ~self,
        ts: i64,
        total_pages: u64,
        used_pages: u64,
        dirty_pages: u64,
        hit_count: u64,
        miss_count: u64,
        eviction_count: u64,
        flush_count: u64,
        read_count: u64,
        write_count: u64,
        evictions_per_sec: f64,
    ) {
        I !self.config.collect_buffer_pool {
            R;
        }
        ~m = BufferPoolMetrics.new(ts);
        m.total_pages = total_pages;
        m.used_pages = used_pages;
        m.dirty_pages = dirty_pages;
        m.hit_count = hit_count;
        m.miss_count = miss_count;
        m.eviction_count = eviction_count;
        m.flush_count = flush_count;
        m.read_count = read_count;
        m.write_count = write_count;
        m.evictions_per_sec = evictions_per_sec;
        m.compute_hit_rate();

        ~guard = self.buffer_pool.write();
        *guard = m;
    }

    ## Get current buffer pool metrics
    F get_buffer_pool(self) -> BufferPoolMetrics {
        ~guard = self.buffer_pool.read();
        guard.clone()
    }

    # ========================================================================
    # WAL Metrics
    # ========================================================================

    ## Update WAL metrics snapshot
    F update_wal(
        ~self,
        ts: i64,
        total_size_bytes: u64,
        segment_count: u32,
        write_rate_bytes_sec: f64,
        records_written: u64,
        bytes_written: u64,
        fsync_count: u64,
        fsync_duration_avg_us: f64,
        group_commits: u64,
        last_checkpoint_lsn: u64,
        last_checkpoint_age_sec: u64,
        oldest_active_lsn: u64,
    ) {
        I !self.config.collect_wal {
            R;
        }
        ~m = WalMetrics.new(ts);
        m.total_size_bytes = total_size_bytes;
        m.segment_count = segment_count;
        m.write_rate_bytes_sec = write_rate_bytes_sec;
        m.records_written = records_written;
        m.bytes_written = bytes_written;
        m.fsync_count = fsync_count;
        m.fsync_duration_avg_us = fsync_duration_avg_us;
        m.group_commits = group_commits;
        m.last_checkpoint_lsn = last_checkpoint_lsn;
        m.last_checkpoint_age_sec = last_checkpoint_age_sec;
        m.oldest_active_lsn = oldest_active_lsn;

        ~guard = self.wal.write();
        *guard = m;
    }

    ## Get current WAL metrics
    F get_wal(self) -> WalMetrics {
        ~guard = self.wal.read();
        guard.clone()
    }

    # ========================================================================
    # Transaction Metrics
    # ========================================================================

    ## Update transaction metrics snapshot
    F update_txn(
        ~self,
        ts: i64,
        active_count: u32,
        total_committed: u64,
        total_aborted: u64,
        total_deadlocks: u64,
        longest_running_ms: u64,
        longest_running_txn_id: u64,
        commit_rate_per_sec: f64,
        rollback_rate_per_sec: f64,
        avg_duration_ms: f64,
    ) {
        I !self.config.collect_txn {
            R;
        }
        ~m = TxnMetrics.new(ts);
        m.active_count = active_count;
        m.total_committed = total_committed;
        m.total_aborted = total_aborted;
        m.total_deadlocks = total_deadlocks;
        m.longest_running_ms = longest_running_ms;
        m.longest_running_txn_id = longest_running_txn_id;
        m.commit_rate_per_sec = commit_rate_per_sec;
        m.rollback_rate_per_sec = rollback_rate_per_sec;
        m.avg_duration_ms = avg_duration_ms;

        ~guard = self.txn.write();
        *guard = m;
    }

    ## Get current transaction metrics
    F get_txn(self) -> TxnMetrics {
        ~guard = self.txn.read();
        guard.clone()
    }

    # ========================================================================
    # Vector Engine Metrics
    # ========================================================================

    ## Update vector engine metrics snapshot
    F update_vector(
        ~self,
        ts: i64,
        total_vectors: u64,
        hnsw_layers: u32,
        hnsw_entry_point: u64,
        dimension: u32,
        search_count: u64,
        insert_count: u64,
        delete_count: u64,
        avg_search_latency_us: f64,
        p99_search_latency_us: f64,
        memory_bytes: u64,
        disk_pages: u64,
    ) {
        I !self.config.collect_vector {
            R;
        }
        ~m = VectorEngineMetrics.new(ts);
        m.total_vectors = total_vectors;
        m.hnsw_layers = hnsw_layers;
        m.hnsw_entry_point = hnsw_entry_point;
        m.dimension = dimension;
        m.search_count = search_count;
        m.insert_count = insert_count;
        m.delete_count = delete_count;
        m.avg_search_latency_us = avg_search_latency_us;
        m.p99_search_latency_us = p99_search_latency_us;
        m.memory_bytes = memory_bytes;
        m.disk_pages = disk_pages;

        ~guard = self.vector.write();
        *guard = m;
    }

    ## Get current vector engine metrics
    F get_vector(self) -> VectorEngineMetrics {
        ~guard = self.vector.read();
        guard.clone()
    }

    # ========================================================================
    # Graph Engine Metrics
    # ========================================================================

    ## Update graph engine metrics snapshot
    F update_graph(
        ~self,
        ts: i64,
        total_nodes: u64,
        total_edges: u64,
        total_edge_types: u32,
        total_labels: u32,
        avg_degree: f64,
        max_degree: u64,
        traversal_count: u64,
        avg_traversal_depth: f64,
        avg_traversal_latency_us: f64,
        disk_pages: u64,
    ) {
        I !self.config.collect_graph {
            R;
        }
        ~m = GraphEngineMetrics.new(ts);
        m.total_nodes = total_nodes;
        m.total_edges = total_edges;
        m.total_edge_types = total_edge_types;
        m.total_labels = total_labels;
        m.avg_degree = avg_degree;
        m.max_degree = max_degree;
        m.traversal_count = traversal_count;
        m.avg_traversal_depth = avg_traversal_depth;
        m.avg_traversal_latency_us = avg_traversal_latency_us;
        m.disk_pages = disk_pages;

        ~guard = self.graph.write();
        *guard = m;
    }

    ## Get current graph engine metrics
    F get_graph(self) -> GraphEngineMetrics {
        ~guard = self.graph.read();
        guard.clone()
    }

    # ========================================================================
    # Full-Text Engine Metrics
    # ========================================================================

    ## Update full-text engine metrics snapshot
    F update_fulltext(
        ~self,
        ts: i64,
        total_documents: u64,
        total_terms: u64,
        total_tokens: u64,
        avg_doc_length: f64,
        search_count: u64,
        index_count: u64,
        avg_search_latency_us: f64,
        dictionary_pages: u64,
        posting_pages: u64,
    ) {
        I !self.config.collect_fulltext {
            R;
        }
        ~m = FullTextEngineMetrics.new(ts);
        m.total_documents = total_documents;
        m.total_terms = total_terms;
        m.total_tokens = total_tokens;
        m.avg_doc_length = avg_doc_length;
        m.search_count = search_count;
        m.index_count = index_count;
        m.avg_search_latency_us = avg_search_latency_us;
        m.dictionary_pages = dictionary_pages;
        m.posting_pages = posting_pages;

        ~guard = self.fulltext.write();
        *guard = m;
    }

    ## Get current full-text engine metrics
    F get_fulltext(self) -> FullTextEngineMetrics {
        ~guard = self.fulltext.read();
        guard.clone()
    }

    # ========================================================================
    # Aggregated Output
    # ========================================================================

    ## Export all engine metrics as a flat list of MetricValue entries
    ## Suitable for /metrics endpoint or Prometheus-style scraping
    F export_all(self, ts: i64) -> Vec<MetricValue> {
        ~values = Vec.new();

        # Buffer pool metrics
        I self.config.collect_buffer_pool {
            ~bp = self.get_buffer_pool();
            values.push(MetricValue.gauge("buffer_pool.hit_rate", bp.hit_rate, ts));
            values.push(MetricValue.counter("buffer_pool.hit_count", bp.hit_count, ts));
            values.push(MetricValue.counter("buffer_pool.miss_count", bp.miss_count, ts));
            values.push(MetricValue.gauge("buffer_pool.dirty_pages", bp.dirty_pages as f64, ts));
            values.push(MetricValue.gauge("buffer_pool.used_pages", bp.used_pages as f64, ts));
            values.push(MetricValue.counter("buffer_pool.eviction_count", bp.eviction_count, ts));
            values.push(MetricValue.gauge("buffer_pool.evictions_per_sec", bp.evictions_per_sec, ts));
            values.push(MetricValue.counter("buffer_pool.read_count", bp.read_count, ts));
            values.push(MetricValue.counter("buffer_pool.write_count", bp.write_count, ts));
        }

        # WAL metrics
        I self.config.collect_wal {
            ~w = self.get_wal();
            values.push(MetricValue.gauge("wal.total_size_bytes", w.total_size_bytes as f64, ts));
            values.push(MetricValue.gauge("wal.segment_count", w.segment_count as f64, ts));
            values.push(MetricValue.gauge("wal.write_rate_bytes_sec", w.write_rate_bytes_sec, ts));
            values.push(MetricValue.counter("wal.records_written", w.records_written, ts));
            values.push(MetricValue.counter("wal.bytes_written", w.bytes_written, ts));
            values.push(MetricValue.counter("wal.fsync_count", w.fsync_count, ts));
            values.push(MetricValue.gauge("wal.fsync_duration_avg_us", w.fsync_duration_avg_us, ts));
            values.push(MetricValue.counter("wal.group_commits", w.group_commits, ts));
            values.push(MetricValue.gauge("wal.last_checkpoint_age_sec", w.last_checkpoint_age_sec as f64, ts));
        }

        # Transaction metrics
        I self.config.collect_txn {
            ~t = self.get_txn();
            values.push(MetricValue.gauge("txn.active_count", t.active_count as f64, ts));
            values.push(MetricValue.counter("txn.total_committed", t.total_committed, ts));
            values.push(MetricValue.counter("txn.total_aborted", t.total_aborted, ts));
            values.push(MetricValue.counter("txn.total_deadlocks", t.total_deadlocks, ts));
            values.push(MetricValue.gauge("txn.longest_running_ms", t.longest_running_ms as f64, ts));
            values.push(MetricValue.gauge("txn.commit_rate_per_sec", t.commit_rate_per_sec, ts));
            values.push(MetricValue.gauge("txn.rollback_rate_per_sec", t.rollback_rate_per_sec, ts));
            values.push(MetricValue.gauge("txn.avg_duration_ms", t.avg_duration_ms, ts));
        }

        # Vector engine metrics
        I self.config.collect_vector {
            ~v = self.get_vector();
            values.push(MetricValue.gauge("vector.total_vectors", v.total_vectors as f64, ts));
            values.push(MetricValue.gauge("vector.hnsw_layers", v.hnsw_layers as f64, ts));
            values.push(MetricValue.gauge("vector.dimension", v.dimension as f64, ts));
            values.push(MetricValue.counter("vector.search_count", v.search_count, ts));
            values.push(MetricValue.counter("vector.insert_count", v.insert_count, ts));
            values.push(MetricValue.counter("vector.delete_count", v.delete_count, ts));
            values.push(MetricValue.gauge("vector.avg_search_latency_us", v.avg_search_latency_us, ts));
            values.push(MetricValue.gauge("vector.p99_search_latency_us", v.p99_search_latency_us, ts));
            values.push(MetricValue.gauge("vector.memory_bytes", v.memory_bytes as f64, ts));
            values.push(MetricValue.gauge("vector.disk_pages", v.disk_pages as f64, ts));
        }

        # Graph engine metrics
        I self.config.collect_graph {
            ~g = self.get_graph();
            values.push(MetricValue.gauge("graph.total_nodes", g.total_nodes as f64, ts));
            values.push(MetricValue.gauge("graph.total_edges", g.total_edges as f64, ts));
            values.push(MetricValue.gauge("graph.avg_degree", g.avg_degree, ts));
            values.push(MetricValue.gauge("graph.max_degree", g.max_degree as f64, ts));
            values.push(MetricValue.counter("graph.traversal_count", g.traversal_count, ts));
            values.push(MetricValue.gauge("graph.avg_traversal_depth", g.avg_traversal_depth, ts));
            values.push(MetricValue.gauge("graph.avg_traversal_latency_us", g.avg_traversal_latency_us, ts));
            values.push(MetricValue.gauge("graph.disk_pages", g.disk_pages as f64, ts));
        }

        # Full-text engine metrics
        I self.config.collect_fulltext {
            ~ft = self.get_fulltext();
            values.push(MetricValue.gauge("fulltext.total_documents", ft.total_documents as f64, ts));
            values.push(MetricValue.gauge("fulltext.total_terms", ft.total_terms as f64, ts));
            values.push(MetricValue.gauge("fulltext.avg_doc_length", ft.avg_doc_length, ts));
            values.push(MetricValue.counter("fulltext.search_count", ft.search_count, ts));
            values.push(MetricValue.counter("fulltext.index_count", ft.index_count, ts));
            values.push(MetricValue.gauge("fulltext.avg_search_latency_us", ft.avg_search_latency_us, ts));
            values.push(MetricValue.gauge("fulltext.dictionary_pages", ft.dictionary_pages as f64, ts));
            values.push(MetricValue.gauge("fulltext.posting_pages", ft.posting_pages as f64, ts));
        }

        values
    }

    ## Format all engine metrics as JSON for /metrics endpoint
    F to_json(self, ts: i64) -> Str {
        ~metrics = self.export_all(ts);
        ~parts = Vec.new();
        ~i: u64 = 0;
        W i < metrics.len() {
            ~m = &metrics[i];
            I m.metric_type == METRIC_TYPE_COUNTER {
                parts.push("\"{m.name}\":{m.value_u64}");
            } E {
                parts.push("\"{m.name}\":{m.value_f64}");
            }
            i = i + 1;
        }

        # Join parts with commas
        ~result = "{";
        ~j: u64 = 0;
        W j < parts.len() {
            I j > 0 {
                result = "{result},";
            }
            result = "{result}{parts[j]}";
            j = j + 1;
        }
        result = "{result}}";
        result
    }
}
