# CRC32C Checksum
# Hardware-accelerated CRC32C via C FFI (Intel CRC32 / ARM CRC extension)
# Software fallback for portability

U std/hash.{crc32c};

# Calculate CRC32C checksum for a page
# The checksum field (offset 20, 4 bytes) is zeroed before computation
F calculate_page_checksum(page_data: &[u8]) -> u32 {
    ~buf = page_data.clone();
    # Zero out checksum field at offset 20 (4 bytes)
    buf[20] = 0;
    buf[21] = 0;
    buf[22] = 0;
    buf[23] = 0;
    crc32c(&buf)
}

# Verify page checksum, returns true if valid
F verify_page_checksum(page_data: &[u8]) -> bool {
    ~stored = read_u32_le_at(page_data, 20);
    ~computed = calculate_page_checksum(page_data);
    stored == computed
}

# Calculate CRC32C checksum for a WAL record
# The checksum field (offset 36, 4 bytes) is zeroed before computation
F calculate_wal_checksum(record_data: &[u8]) -> u32 {
    ~buf = record_data.clone();
    # Zero out checksum field at offset 36 (4 bytes)
    buf[36] = 0;
    buf[37] = 0;
    buf[38] = 0;
    buf[39] = 0;
    crc32c(&buf)
}

# Verify WAL record checksum
F verify_wal_checksum(record_data: &[u8]) -> bool {
    ~stored = read_u32_le_at(record_data, 36);
    ~computed = calculate_wal_checksum(record_data);
    stored == computed
}

# Calculate CRC32C for WAL segment header
# Checksum field at offset 28 (4 bytes) zeroed before computation
F calculate_segment_header_checksum(header_data: &[u8]) -> u32 {
    ~buf = header_data.clone();
    buf[28] = 0;
    buf[29] = 0;
    buf[30] = 0;
    buf[31] = 0;
    crc32c(&buf)
}

# Verify WAL segment header checksum
F verify_segment_header_checksum(header_data: &[u8]) -> bool {
    ~stored = read_u32_le_at(header_data, 28);
    ~computed = calculate_segment_header_checksum(header_data);
    stored == computed
}

# Helper: read u32 little-endian at offset
F read_u32_le_at(data: &[u8], offset: u64) -> u32 {
    (data[offset] as u32) |
    ((data[offset + 1] as u32) << 8) |
    ((data[offset + 2] as u32) << 16) |
    ((data[offset + 3] as u32) << 24)
}

# Calculate CRC32C for arbitrary data
F checksum(data: &[u8]) -> u32 {
    crc32c(data)
}
