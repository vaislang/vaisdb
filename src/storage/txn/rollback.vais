# Transaction Rollback Executor
# Applies undo log chain to rollback transaction changes
# Based on Stage 3 Section 6 (Transaction Timeout) and Stage 1 Section 10

U std/bytes.{ByteBuffer};
U storage/constants.{
    NULL_UNDO_PTR, PAGE_HEADER_SIZE, SLOT_ENTRY_SIZE,
    MVCC_TUPLE_META_SIZE, FLAG_HAS_TOMBSTONES,
    UNDO_INSERT, UNDO_DELETE, UNDO_UPDATE
};
U storage/error.{VaisError, err_internal};
U storage/txn/undo.{UndoLog};
U storage/txn/undo_entry.{UndoEntry};
U storage/buffer/pool.{BufferPool};
U storage/page/header.{PageHeader};
U storage/page/slot.{HeapPageSlot};
U storage/page/mvcc.{MvccTupleMeta};

# Rollback executor: traverses undo chain and reverses operations
S RollbackExecutor {
    undo_log: UndoLog,
}

X RollbackExecutor {
    # Create a new rollback executor
    F new(undo_log: UndoLog) -> RollbackExecutor {
        RollbackExecutor { undo_log }
    }

    # Rollback a transaction by following its undo chain
    # Returns the number of undo entries processed
    F rollback_transaction(
        self,
        txn_id: u64,
        undo_ptr: u64,
        pool: &~BufferPool
    ) -> Result<u32, VaisError> {
        if undo_ptr == NULL_UNDO_PTR {
            # No undo entries, nothing to rollback
            return Ok(0);
        }

        # Read the entire undo chain
        ~entries = self.undo_log.read_chain(undo_ptr, pool)?;
        ~count = 0u32;

        # Process each undo entry in reverse chronological order (newest first)
        for entry in entries {
            # Verify this entry belongs to the transaction being rolled back
            if entry.txn_id != txn_id {
                return Err(err_internal(
                    "Undo entry txn_id mismatch: expected {txn_id}, got {entry.txn_id}"
                ));
            }

            # Apply the reverse operation
            M entry.entry_type {
                UNDO_INSERT => {
                    # Undo an INSERT: delete the tuple (mark slot dead)
                    self.undo_insert(&entry, pool)?;
                },
                UNDO_DELETE => {
                    # Undo a DELETE: restore the old tuple data
                    self.undo_delete(&entry, pool)?;
                },
                UNDO_UPDATE => {
                    # Undo an UPDATE: restore the old tuple data
                    self.undo_update(&entry, pool)?;
                },
                _ => {
                    return Err(err_internal("Invalid undo entry type: {entry.entry_type}"));
                }
            }

            count += 1;
        }

        Ok(count)
    }

    # Undo an INSERT operation: mark the slot as dead
    F undo_insert(self, entry: &UndoEntry, pool: &~BufferPool) -> Result<(), VaisError> {
        # Fetch the heap page containing the tuple
        ~frame_id = pool.fetch_page(entry.file_id, entry.page_id)?;
        ~frame = pool.get_frame_mut(frame_id);
        ~page_data = frame.get_data_mut();

        # Calculate slot offset
        ~slot_offset = PAGE_HEADER_SIZE as usize +
            (entry.slot_id as usize * SLOT_ENTRY_SIZE as usize);

        # Read the slot entry
        ~slot = HeapPageSlot.read_at_index(page_data, entry.slot_id)?;

        # Mark slot as dead (tuple_off = 0)
        ~dead_slot = HeapPageSlot.dead();
        dead_slot.write_at_index(page_data, entry.slot_id);

        # Update page header to set HAS_TOMBSTONES flag
        ~header = PageHeader.read_from_page(page_data)?;
        header.flags |= FLAG_HAS_TOMBSTONES;
        header.write_to_page(page_data);

        # Mark page as dirty
        frame.mark_dirty();

        # Unpin
        pool.unpin_page(frame_id)?;

        Ok(())
    }

    # Undo a DELETE operation: restore the old tuple data
    F undo_delete(self, entry: &UndoEntry, pool: &~BufferPool) -> Result<(), VaisError> {
        # Fetch the heap page
        ~frame_id = pool.fetch_page(entry.file_id, entry.page_id)?;
        ~frame = pool.get_frame_mut(frame_id);
        ~page_data = frame.get_data_mut();

        # Read the slot entry to find the tuple location
        ~slot = HeapPageSlot.read_at_index(page_data, entry.slot_id)?;

        if slot.tuple_off == 0 {
            return Err(err_internal("Cannot undo DELETE: slot is already dead"));
        }

        # Read the MVCC metadata at the tuple location
        ~tuple_offset = slot.tuple_off as usize;
        ~mvcc_data = &page_data[tuple_offset..(tuple_offset + MVCC_TUPLE_META_SIZE as usize)];
        ~mvcc_buf = ByteBuffer.from_slice(mvcc_data);
        ~mvcc = MvccTupleMeta.deserialize(&mvcc_buf)?;

        # Clear the expiration (restore to active state)
        mvcc.clear_expired();

        # Write back the MVCC metadata
        ~write_buf = ByteBuffer.with_capacity(MVCC_TUPLE_META_SIZE as usize);
        mvcc.serialize(&write_buf);
        page_data[tuple_offset..(tuple_offset + MVCC_TUPLE_META_SIZE as usize)]
            .copy_from_slice(write_buf.as_bytes());

        # Mark page as dirty
        frame.mark_dirty();

        # Unpin
        pool.unpin_page(frame_id)?;

        Ok(())
    }

    # Undo an UPDATE operation: restore the old tuple data
    F undo_update(self, entry: &UndoEntry, pool: &~BufferPool) -> Result<(), VaisError> {
        # Fetch the heap page
        ~frame_id = pool.fetch_page(entry.file_id, entry.page_id)?;
        ~frame = pool.get_frame_mut(frame_id);
        ~page_data = frame.get_data_mut();

        # Read the slot entry to find the tuple location
        ~slot = HeapPageSlot.read_at_index(page_data, entry.slot_id)?;

        if slot.tuple_off == 0 {
            return Err(err_internal("Cannot undo UPDATE: slot is dead"));
        }

        # Verify the old_data fits in the current slot
        if entry.data_len > slot.tuple_len as u32 {
            return Err(err_internal(
                "Undo UPDATE data too large: {entry.data_len} > {slot.tuple_len}"
            ));
        }

        # Restore the old tuple data (MVCC metadata + user data)
        ~tuple_offset = slot.tuple_off as usize;
        page_data[tuple_offset..(tuple_offset + entry.data_len as usize)]
            .copy_from_slice(&entry.old_data);

        # Update slot length if the old data is smaller
        if entry.data_len < slot.tuple_len as u32 {
            ~updated_slot = HeapPageSlot.new(slot.tuple_off, entry.data_len as u16);
            updated_slot.write_at_index(page_data, entry.slot_id);
        }

        # Mark page as dirty
        frame.mark_dirty();

        # Unpin
        pool.unpin_page(frame_id)?;

        Ok(())
    }
}
