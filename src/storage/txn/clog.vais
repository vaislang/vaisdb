# CLOG - Transaction Status Table (Commit Log)
# 2 bits per transaction: IN_PROGRESS(00), COMMITTED(01), ABORTED(10), RESERVED(11)
# Stored in dedicated pages within meta.vdb
# Based on Stage 3 Section 3

use std/bytes.{ByteBuffer};
use std/sync.{Mutex};
use storage/constants.{
    PAGE_HEADER_SIZE, TXN_STATUS_IN_PROGRESS,
    TXN_STATUS_COMMITTED, TXN_STATUS_ABORTED,
    TXN_STATUS_RESERVED, DEFAULT_CLOG_CACHE_PAGES,
};
use storage/error.{VaisError, err_internal};

# Transaction status enum
L TxnStatus = InProgress | Committed | Aborted | Reserved;

I TxnStatus {
    F from_u8(val: u8) -> TxnStatus {
        M val {
            0 => TxnStatus.InProgress,
            1 => TxnStatus.Committed,
            2 => TxnStatus.Aborted,
            3 => TxnStatus.Reserved,
            _ => TxnStatus.InProgress,
        }
    }

    F to_u8(self) -> u8 {
        M self {
            TxnStatus.InProgress => 0,
            TxnStatus.Committed => 1,
            TxnStatus.Aborted => 2,
            TxnStatus.Reserved => 3,
        }
    }

    F is_committed(self) -> bool {
        M self { TxnStatus.Committed => true, _ => false }
    }

    F is_aborted(self) -> bool {
        M self { TxnStatus.Aborted => true, _ => false }
    }

    F is_in_progress(self) -> bool {
        M self { TxnStatus.InProgress => true, _ => false }
    }
}

# CLOG page access helper
S ClogPage {
    data: Vec<u8>,  # PAGE_SIZE - 48 bytes of bitmap data
}

I ClogPage {
    F new(page_body_size: u32) -> ClogPage {
        ~data = Vec.with_capacity(page_body_size as usize);
        data.resize(page_body_size as usize, 0u8);
        ClogPage { data }
    }

    F from_bytes(bytes: &[u8]) -> ClogPage {
        ClogPage { data: bytes.to_vec() }
    }

    # Calculate transactions per CLOG page
    F txns_per_page(page_size: u32) -> u64 {
        ((page_size - PAGE_HEADER_SIZE) * 4) as u64
    }

    # Get status of a transaction within this page
    F get_status(self, txn_id: u64, txns_per_page: u64) -> TxnStatus {
        ~local_id = txn_id % txns_per_page;
        ~byte_offset = (local_id / 4) as usize;
        ~bit_offset = ((local_id % 4) * 2) as u8;
        ~bits = (self.data[byte_offset] >> bit_offset) & 0b11;
        TxnStatus.from_u8(bits)
    }

    # Set status of a transaction within this page
    F set_status(~self, txn_id: u64, txns_per_page: u64, status: TxnStatus) {
        ~local_id = txn_id % txns_per_page;
        ~byte_offset = (local_id / 4) as usize;
        ~bit_offset = ((local_id % 4) * 2) as u8;
        ~mask = !(0b11u8 << bit_offset);
        self.data[byte_offset] = (self.data[byte_offset] & mask) | (status.to_u8() << bit_offset);
    }
}

# CLOG manager: provides cached access to transaction status
S Clog {
    page_size: u32,
    txns_per_page: u64,
    cache: Vec<ClogPage>,      # Cached CLOG pages
    cache_base_page: u32,      # First CLOG page number in cache
    cache_size: u32,            # Number of cached pages
    lock: Mutex,
}

I Clog {
    # Create a new CLOG manager
    F new(page_size: u32, cache_pages: u32) -> Clog {
        ~txns_per_page = ClogPage.txns_per_page(page_size);
        ~cache = Vec.with_capacity(cache_pages as usize);
        for _ in 0..cache_pages {
            cache.push(ClogPage.new(page_size - PAGE_HEADER_SIZE));
        }

        Clog {
            page_size,
            txns_per_page,
            cache,
            cache_base_page: 0,
            cache_size: cache_pages,
            lock: Mutex.new(),
        }
    }

    # Get transaction status
    F get_status(self, txn_id: u64) -> TxnStatus {
        ~page_num = (txn_id / self.txns_per_page) as u32;
        ~cache_idx = self.page_to_cache_index(page_num);

        ~guard = self.lock.lock();
        M cache_idx {
            Some(idx) => {
                ~status = self.cache[idx].get_status(txn_id, self.txns_per_page);
                drop(guard);
                status
            },
            None => {
                drop(guard);
                # Page not in cache - would need disk I/O
                # For now return IN_PROGRESS (conservative)
                TxnStatus.InProgress
            },
        }
    }

    # Set transaction status
    F set_status(~self, txn_id: u64, status: TxnStatus) {
        ~page_num = (txn_id / self.txns_per_page) as u32;

        ~guard = self.lock.lock();

        # Ensure page is in cache, extending if needed
        self.ensure_page_cached(page_num);

        M self.page_to_cache_index(page_num) {
            Some(idx) => {
                self.cache[idx].set_status(txn_id, self.txns_per_page, status);
            },
            None => {},
        }

        drop(guard);
    }

    # Check if a transaction is committed
    F is_committed(self, txn_id: u64) -> bool {
        self.get_status(txn_id).is_committed()
    }

    # Check if a transaction is aborted
    F is_aborted(self, txn_id: u64) -> bool {
        self.get_status(txn_id).is_aborted()
    }

    # Map CLOG page number to cache index
    F page_to_cache_index(self, page_num: u32) -> Option<usize> {
        if page_num >= self.cache_base_page &&
           page_num < self.cache_base_page + self.cache_size {
            Some((page_num - self.cache_base_page) as usize)
        } else {
            None
        }
    }

    # Ensure a page is represented in the cache
    F ensure_page_cached(~self, page_num: u32) {
        if self.page_to_cache_index(page_num).is_none() {
            # Slide cache window to include this page
            if page_num >= self.cache_base_page + self.cache_size {
                ~new_base = page_num - self.cache_size + 1;
                if new_base > self.cache_base_page {
                    # Shift cache: drop old pages, add new ones
                    ~shift = (new_base - self.cache_base_page) as usize;
                    for _ in 0..shift.min(self.cache.len()) {
                        self.cache.remove(0);
                        self.cache.push(ClogPage.new(self.page_size - PAGE_HEADER_SIZE));
                    }
                    self.cache_base_page = new_base;
                }
            }
        }
    }

    # Load CLOG pages from raw data (used during recovery)
    F load_pages(~self, base_page: u32, pages_data: Vec<Vec<u8>>) {
        ~guard = self.lock.lock();
        self.cache_base_page = base_page;
        self.cache.clear();
        for page_data in &pages_data {
            # Skip page header (48 bytes), use rest as CLOG data
            ~body = page_data[PAGE_HEADER_SIZE as usize..].to_vec();
            self.cache.push(ClogPage.from_bytes(&body));
        }
        self.cache_size = self.cache.len() as u32;
        drop(guard);
    }

    # Get serialized CLOG pages (for checkpoint)
    F get_pages(self) -> Vec<&[u8]> {
        ~result = Vec.new();
        for page in &self.cache {
            result.push(&page.data);
        }
        result
    }
}
