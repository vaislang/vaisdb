# B+Tree Key Encoding and Comparison
# Handles composite keys, type-aware encoding, and prefix compression
# Keys are stored as byte slices with type-aware comparison

U storage/error.{VaisError, err_internal};
U storage/btree/entry.{compare_keys, key_less_than, key_equal, KeyCmp};
U std/bytes.{ByteBuffer};

# Key types for type-aware comparison
L KeyType = Integer | Float | String | Bytes | Composite;

# Encode an integer key (i64) as big-endian bytes for correct lexicographic order
# Flip the sign bit so negative sorts before positive
F encode_i64_key(value: i64) -> Vec<u8> {
    ~encoded = Vec.with_capacity(8);
    encoded.resize(8, 0u8);

    # Flip sign bit for correct sort order: XOR with 0x80 on high byte
    ~v = (value as u64) ^ 0x8000000000000000;
    encoded[0] = ((v >> 56) & 0xFF) as u8;
    encoded[1] = ((v >> 48) & 0xFF) as u8;
    encoded[2] = ((v >> 40) & 0xFF) as u8;
    encoded[3] = ((v >> 32) & 0xFF) as u8;
    encoded[4] = ((v >> 24) & 0xFF) as u8;
    encoded[5] = ((v >> 16) & 0xFF) as u8;
    encoded[6] = ((v >> 8) & 0xFF) as u8;
    encoded[7] = (v & 0xFF) as u8;
    encoded
}

# Decode a big-endian encoded integer key back to i64
F decode_i64_key(data: &[u8]) -> i64 {
    ~v: u64 = 0;
    v |= (data[0] as u64) << 56;
    v |= (data[1] as u64) << 48;
    v |= (data[2] as u64) << 40;
    v |= (data[3] as u64) << 32;
    v |= (data[4] as u64) << 24;
    v |= (data[5] as u64) << 16;
    v |= (data[6] as u64) << 8;
    v |= data[7] as u64;
    # Flip sign bit back
    (v ^ 0x8000000000000000) as i64
}

# Encode a u64 key as big-endian bytes
F encode_u64_key(value: u64) -> Vec<u8> {
    ~encoded = Vec.with_capacity(8);
    encoded.resize(8, 0u8);
    encoded[0] = ((value >> 56) & 0xFF) as u8;
    encoded[1] = ((value >> 48) & 0xFF) as u8;
    encoded[2] = ((value >> 40) & 0xFF) as u8;
    encoded[3] = ((value >> 32) & 0xFF) as u8;
    encoded[4] = ((value >> 24) & 0xFF) as u8;
    encoded[5] = ((value >> 16) & 0xFF) as u8;
    encoded[6] = ((value >> 8) & 0xFF) as u8;
    encoded[7] = (value & 0xFF) as u8;
    encoded
}

# Decode a big-endian u64 key
F decode_u64_key(data: &[u8]) -> u64 {
    ~v: u64 = 0;
    v |= (data[0] as u64) << 56;
    v |= (data[1] as u64) << 48;
    v |= (data[2] as u64) << 40;
    v |= (data[3] as u64) << 32;
    v |= (data[4] as u64) << 24;
    v |= (data[5] as u64) << 16;
    v |= (data[6] as u64) << 8;
    v |= data[7] as u64;
    v
}

# Encode a string key with null-termination
# Strings sort lexicographically as raw bytes (UTF-8 preserves order for ASCII)
F encode_string_key(value: &str) -> Vec<u8> {
    ~encoded = Vec.with_capacity(value.len());
    for b in value.as_bytes() {
        encoded.push(b);
    }
    encoded
}

# Encode a composite key (multiple columns)
# Each component is length-prefixed: [u16 len][key bytes]
F encode_composite_key(components: &[&[u8]]) -> Vec<u8> {
    ~total_len: usize = 0;
    for comp in components {
        total_len += 2 + comp.len();
    }

    ~encoded = Vec.with_capacity(total_len);
    for comp in components {
        ~len = comp.len() as u16;
        encoded.push((len >> 8) as u8);
        encoded.push((len & 0xFF) as u8);
        for b in *comp {
            encoded.push(b);
        }
    }
    encoded
}

# Decode a composite key into its components
F decode_composite_key(data: &[u8]) -> Vec<Vec<u8>> {
    ~components = Vec.new();
    ~pos: usize = 0;

    while pos + 2 <= data.len() {
        ~len = ((data[pos] as u16) << 8) | (data[pos + 1] as u16);
        pos += 2;
        if pos + len as usize > data.len() {
            break;
        }
        ~comp = data[pos..pos + len as usize].to_vec();
        components.push(comp);
        pos += len as usize;
    }

    components
}

# Calculate common prefix length between two keys
F common_prefix_length(a: &[u8], b: &[u8]) -> usize {
    ~min_len = if a.len() < b.len() { a.len() } else { b.len() };
    ~prefix_len: usize = 0;
    for i in 0..min_len {
        if a[i] != b[i] {
            break;
        }
        prefix_len += 1;
    }
    prefix_len
}

# Strip common prefix from a key (for prefix compression)
# Returns (prefix_len, suffix)
F strip_prefix(key: &[u8], prev_key: &[u8]) -> (u16, Vec<u8>) {
    ~prefix_len = common_prefix_length(key, prev_key);
    ~suffix = key[prefix_len..].to_vec();
    (prefix_len as u16, suffix)
}

# Reconstruct a key from prefix length and suffix
F reconstruct_key(prev_key: &[u8], prefix_len: u16, suffix: &[u8]) -> Vec<u8> {
    ~key = Vec.with_capacity(prefix_len as usize + suffix.len());
    for i in 0..prefix_len as usize {
        key.push(prev_key[i]);
    }
    for b in suffix {
        key.push(b);
    }
    key
}

# Key range for scans
S KeyRange {
    start: Option<Vec<u8>>,    # None = negative infinity
    end: Option<Vec<u8>>,      # None = positive infinity
    start_inclusive: bool,
    end_inclusive: bool,
}

X KeyRange {
    # Full range (all keys)
    F all() -> KeyRange {
        KeyRange {
            start: None,
            end: None,
            start_inclusive: true,
            end_inclusive: true,
        }
    }

    # Range [start, end]
    F closed(start: Vec<u8>, end: Vec<u8>) -> KeyRange {
        KeyRange {
            start: Some(start),
            end: Some(end),
            start_inclusive: true,
            end_inclusive: true,
        }
    }

    # Range [start, end)
    F half_open(start: Vec<u8>, end: Vec<u8>) -> KeyRange {
        KeyRange {
            start: Some(start),
            end: Some(end),
            start_inclusive: true,
            end_inclusive: false,
        }
    }

    # Check if a key is within this range
    F contains(self, key: &[u8]) -> bool {
        # Check start bound
        M &self.start {
            Some(ref start_key) => {
                M compare_keys(key, start_key) {
                    KeyCmp.Less => { return false; },
                    KeyCmp.Equal => {
                        if !self.start_inclusive { return false; }
                    },
                    KeyCmp.Greater => {},
                }
            },
            None => {},
        }

        # Check end bound
        M &self.end {
            Some(ref end_key) => {
                M compare_keys(key, end_key) {
                    KeyCmp.Greater => { return false; },
                    KeyCmp.Equal => {
                        if !self.end_inclusive { return false; }
                    },
                    KeyCmp.Less => {},
                }
            },
            None => {},
        }

        true
    }

    # Check if key is past end of range
    F is_past_end(self, key: &[u8]) -> bool {
        M &self.end {
            Some(ref end_key) => {
                M compare_keys(key, end_key) {
                    KeyCmp.Greater => true,
                    KeyCmp.Equal => !self.end_inclusive,
                    KeyCmp.Less => false,
                }
            },
            None => false,
        }
    }
}
