# B+Tree Entry Types
# Internal node entries (8B directory + variable key) and leaf entries (8B + variable key)
# Based on Stage 1 Section 9 and Stage 7 Patterns

U std/bytes.{ByteBuffer};
U storage/constants.{BTREE_INTERNAL_ENTRY_SIZE, BTREE_LEAF_ENTRY_SIZE, TID_PAGE_BITS, TID_SLOT_BITS};
U storage/error.{VaisError};

# Internal node key directory entry (8 bytes)
S BTreeInternalEntry {
    key_off: u16,      # Offset from page body start to key data
    key_len: u16,      # Key length in bytes
    child_page: u32,   # Child page ID to the RIGHT of this key
}

X BTreeInternalEntry {
    F new(key_off: u16, key_len: u16, child_page: u32) -> BTreeInternalEntry {
        BTreeInternalEntry { key_off, key_len, child_page }
    }

    F serialize(self, buf: &~ByteBuffer) {
        buf.put_u16_le(self.key_off);
        buf.put_u16_le(self.key_len);
        buf.put_u32_le(self.child_page);
    }

    F deserialize(buf: &ByteBuffer) -> Result<BTreeInternalEntry, VaisError> {
        Ok(BTreeInternalEntry {
            key_off: buf.get_u16_le()?,
            key_len: buf.get_u16_le()?,
            child_page: buf.get_u32_le()?,
        })
    }

    F entry_size() -> u32 {
        BTREE_INTERNAL_ENTRY_SIZE
    }
}

# Leaf node entry directory entry (8 bytes)
S BTreeLeafEntry {
    key_off: u16,      # Offset from page body start to key data
    key_len: u16,      # Key length in bytes
    tid: u32,          # Tuple ID: page_id (upper 20 bits) + slot (lower 12 bits)
}

X BTreeLeafEntry {
    F new(key_off: u16, key_len: u16, tid: u32) -> BTreeLeafEntry {
        BTreeLeafEntry { key_off, key_len, tid }
    }

    F serialize(self, buf: &~ByteBuffer) {
        buf.put_u16_le(self.key_off);
        buf.put_u16_le(self.key_len);
        buf.put_u32_le(self.tid);
    }

    F deserialize(buf: &ByteBuffer) -> Result<BTreeLeafEntry, VaisError> {
        Ok(BTreeLeafEntry {
            key_off: buf.get_u16_le()?,
            key_len: buf.get_u16_le()?,
            tid: buf.get_u32_le()?,
        })
    }

    # TID encoding: upper 20 bits = page_id, lower 12 bits = slot_id
    F encode_tid(page_id: u32, slot_id: u16) -> u32 {
        ((page_id & 0xFFFFF) << 12) | ((slot_id & 0xFFF) as u32)
    }

    F decode_tid(tid: u32) -> (u32, u16) {
        ~page_id = (tid >> 12) & 0xFFFFF;
        ~slot_id = (tid & 0xFFF) as u16;
        (page_id, slot_id)
    }

    F get_page_id(self) -> u32 {
        (self.tid >> 12) & 0xFFFFF
    }

    F get_slot_id(self) -> u16 {
        (self.tid & 0xFFF) as u16
    }

    F entry_size() -> u32 {
        BTREE_LEAF_ENTRY_SIZE
    }
}

# Key comparison result
L KeyCmp = Less | Equal | Greater;

# Compare two byte-slice keys lexicographically
F compare_keys(a: &[u8], b: &[u8]) -> KeyCmp {
    ~min_len = if a.len() < b.len() { a.len() } else { b.len() };
    for i in 0..min_len {
        if a[i] < b[i] { return KeyCmp.Less; }
        if a[i] > b[i] { return KeyCmp.Greater; }
    }
    if a.len() < b.len() { KeyCmp.Less }
    else if a.len() > b.len() { KeyCmp.Greater }
    else { KeyCmp.Equal }
}

# Check if key a < key b
F key_less_than(a: &[u8], b: &[u8]) -> bool {
    M compare_keys(a, b) {
        KeyCmp.Less => true,
        _ => false,
    }
}

# Check if key a == key b
F key_equal(a: &[u8], b: &[u8]) -> bool {
    M compare_keys(a, b) {
        KeyCmp.Equal => true,
        _ => false,
    }
}
