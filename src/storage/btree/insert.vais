# B+Tree Insert Operations
# Insert key-TID pairs with automatic page split detection
# Follows the descent-then-split approach from Stage 1 Section 9

use storage/constants.{NULL_PAGE, PAGE_HEADER_SIZE};
use storage/error.{VaisError, err_internal, err_page_full, err_key_exists};
use storage/buffer/pool.{BufferPool};
use storage/btree/tree.{BTree};
use storage/btree/node.{BTreeInternalNode, BTreeLeafNode};
use storage/btree/entry.{BTreeLeafEntry, BTreeInternalEntry, compare_keys, key_equal, KeyCmp};

# Result of an insert that may need to propagate upward
L InsertResult =
    Done                                      # Insert completed, no split needed
  | NeedsSplit(Vec<u8>, u32);                 # (separator_key, new_page_id) to propagate up

# Insert a key-TID pair into the B+Tree
# Returns Ok(true) if inserted, Ok(false) if key already exists (duplicate)
F btree_insert(
    tree: &~BTree,
    key: &[u8],
    tid: u32,
    pool: &~BufferPool,
) -> Result<bool, VaisError> {
    # Check for duplicate key first
    M tree.search(key, pool)? {
        Some(_) => { return Ok(false); },
        None => {},
    }

    # Collect the path from root to leaf (for potential splits)
    ~path = collect_insert_path(tree, key, pool)?;

    # Insert into the leaf
    ~leaf_info = &path[path.len() - 1];
    ~leaf_frame = pool.fetch_page(tree.file_id, leaf_info.page_id)?;
    ~page_data = pool.get_page(leaf_frame);
    ~leaf = BTreeLeafNode.from_page_data(page_data, tree.page_size)?;

    if leaf.can_fit(key.len() as u32) {
        # Simple case: leaf has space
        leaf.insert(key, tid)?;
        ~flushed = leaf.flush();
        pool.write_page(leaf_frame, flushed)?;
        pool.unpin_page(leaf_frame, true);
        tree.inc_entries();
        return Ok(true);
    }

    # Leaf is full, need to split
    # First do the split, then propagate separator up
    ~split_result = split_leaf(tree, &leaf, key, tid, leaf_frame, pool)?;

    # Propagate split up through internal nodes
    M split_result {
        InsertResult.Done => {},
        InsertResult.NeedsSplit(separator, new_page_id) => {
            propagate_split(tree, &path, separator, new_page_id, pool)?;
        },
    }

    pool.unpin_page(leaf_frame, true);
    tree.inc_entries();
    Ok(true)
}

# Path entry recording the descent through the tree
S PathEntry {
    page_id: u32,
    index: usize,     # Which child slot was followed (for internal nodes)
}

# Collect the path from root to the target leaf
F collect_insert_path(
    tree: &BTree,
    key: &[u8],
    pool: &~BufferPool,
) -> Result<Vec<PathEntry>, VaisError> {
    ~path = Vec.with_capacity(tree.height as usize);
    ~current_page = tree.root_page_id;

    for level in 0..(tree.height - 1) {
        ~frame_id = pool.fetch_page(tree.file_id, current_page)?;
        ~page_data = pool.get_page(frame_id);
        ~internal = BTreeInternalNode.from_page_data(page_data, tree.page_size)?;

        # Find which child to descend to and record the child index
        ~child_index = find_child_index(&internal, key);
        ~next_page = if child_index == 0 {
            internal.leftmost_child
        } else {
            internal.entries[child_index - 1].child_page
        };

        path.push(PathEntry { page_id: current_page, index: child_index });
        pool.unpin_page(frame_id, false);
        current_page = next_page;
    }

    # Add leaf to path
    path.push(PathEntry { page_id: current_page, index: 0 });

    Ok(path)
}

# Find the child index for descent (0 = leftmost_child, N = entries[N-1].child_page)
F find_child_index(internal: &BTreeInternalNode, key: &[u8]) -> usize {
    ~lo: usize = 0;
    ~hi: usize = internal.entries.len();

    while lo < hi {
        ~mid = lo + (hi - lo) / 2;
        ~mid_key = internal.get_key(mid);
        M compare_keys(key, mid_key) {
            KeyCmp.Less => { hi = mid; },
            KeyCmp.Equal | KeyCmp.Greater => { lo = mid + 1; },
        }
    }
    lo
}

# Split a leaf node and insert the new key
# Returns the split result to propagate upward
F split_leaf(
    tree: &BTree,
    leaf: &BTreeLeafNode,
    key: &[u8],
    tid: u32,
    leaf_frame: u32,
    pool: &~BufferPool,
) -> Result<InsertResult, VaisError> {
    # Find split point (median)
    ~mid = leaf.median_index();

    # Allocate a new page for the right sibling
    ~new_page_id = pool.allocate_page(tree.file_id)?;
    ~new_frame = pool.fetch_page(tree.file_id, new_page_id)?;

    # Create the new leaf node
    ~new_leaf = BTreeLeafNode.new(new_page_id, tree.page_size, false);

    # Determine where the new key goes (left or right of split point)
    ~insert_pos = leaf.lower_bound(key);
    ~goes_right = insert_pos >= mid;

    # Move entries [mid..] to new leaf
    # Plus insert the new key at the right position
    ~all_keys = Vec.new();
    ~all_tids = Vec.new();

    for i in 0..leaf.entry_count() as usize {
        if i == insert_pos {
            all_keys.push(key.to_vec());
            all_tids.push(tid);
        }
        all_keys.push(leaf.get_key(i).to_vec());
        all_tids.push(leaf.entries[i].tid);
    }
    if insert_pos >= leaf.entry_count() as usize {
        all_keys.push(key.to_vec());
        all_tids.push(tid);
    }

    # Split: left gets [0..mid], right gets [mid..]
    ~total = all_keys.len();
    ~split_at = total / 2;

    # Rebuild left leaf (reuse original)
    ~left_leaf = BTreeLeafNode.new(leaf.header.page_id, tree.page_size, leaf.is_root());
    for i in 0..split_at {
        left_leaf.insert(&all_keys[i], all_tids[i])?;
    }

    # Build right leaf
    for i in split_at..total {
        new_leaf.insert(&all_keys[i], all_tids[i])?;
    }

    # Update leaf chain pointers
    ~old_next = leaf.next_leaf();
    left_leaf.set_next_leaf(new_page_id);
    new_leaf.set_prev_leaf(leaf.header.page_id);
    new_leaf.set_next_leaf(old_next);

    # Update the next leaf's prev pointer
    if old_next != NULL_PAGE {
        ~next_frame = pool.fetch_page(tree.file_id, old_next)?;
        ~next_data = pool.get_page(next_frame);
        ~next_leaf = BTreeLeafNode.from_page_data(next_data, tree.page_size)?;
        next_leaf.set_prev_leaf(new_page_id);
        ~next_flushed = next_leaf.flush();
        pool.write_page(next_frame, next_flushed)?;
        pool.unpin_page(next_frame, true);
    }

    # Write both leaves
    ~left_flushed = left_leaf.flush();
    pool.write_page(leaf_frame, left_flushed)?;

    ~new_flushed = new_leaf.flush();
    pool.write_page(new_frame, new_flushed)?;
    pool.unpin_page(new_frame, true);

    # Separator key = first key of right leaf
    ~separator = all_keys[split_at].clone();

    Ok(InsertResult.NeedsSplit(separator, new_page_id))
}

# Propagate a split upward through the internal nodes
F propagate_split(
    tree: &~BTree,
    path: &[PathEntry],
    separator: Vec<u8>,
    new_child_page: u32,
    pool: &~BufferPool,
) -> Result<(), VaisError> {
    ~current_sep = separator;
    ~current_child = new_child_page;

    # Walk up from the parent of the leaf (path[len-2]) to root
    ~level = path.len() as i32 - 2;  # Start at parent of leaf

    while level >= 0 {
        ~parent_info = &path[level as usize];
        ~parent_frame = pool.fetch_page(tree.file_id, parent_info.page_id)?;
        ~parent_data = pool.get_page(parent_frame);
        ~internal = BTreeInternalNode.from_page_data(parent_data, tree.page_size)?;

        if internal.can_fit(current_sep.len() as u32) {
            # Parent has space, insert separator
            internal.insert_entry(&current_sep, current_child)?;
            ~flushed = internal.flush();
            pool.write_page(parent_frame, flushed)?;
            pool.unpin_page(parent_frame, true);
            return Ok(());
        }

        # Parent is full, need to split internal node
        ~(new_sep, new_internal_page) = split_internal(
            tree, &internal, &current_sep, current_child, parent_frame, pool
        )?;
        pool.unpin_page(parent_frame, true);

        current_sep = new_sep;
        current_child = new_internal_page;
        level -= 1;
    }

    # If we get here, the root itself was split â€” need a new root
    create_new_root(tree, &current_sep, tree.root_page_id, current_child, pool)?;

    Ok(())
}

# Split an internal node
# Returns (separator_to_push_up, new_page_id)
F split_internal(
    tree: &BTree,
    internal: &BTreeInternalNode,
    new_key: &[u8],
    new_child: u32,
    internal_frame: u32,
    pool: &~BufferPool,
) -> Result<(Vec<u8>, u32), VaisError> {
    # Collect all keys + the new key in sorted order
    ~all_keys = Vec.new();
    ~all_children = Vec.new();

    # leftmost_child goes first
    all_children.push(internal.leftmost_child);

    ~inserted = false;
    for i in 0..internal.entry_count() as usize {
        ~entry_key = internal.get_key(i).to_vec();
        if !inserted && compare_keys(new_key, &entry_key) == KeyCmp.Less {
            all_keys.push(new_key.to_vec());
            all_children.push(new_child);
            inserted = true;
        }
        all_keys.push(entry_key);
        all_children.push(internal.entries[i].child_page);
    }
    if !inserted {
        all_keys.push(new_key.to_vec());
        all_children.push(new_child);
    }

    # Split point: median key goes up, not into either node
    ~mid = all_keys.len() / 2;
    ~push_up_key = all_keys[mid].clone();

    # Allocate new internal node
    ~new_page_id = pool.allocate_page(tree.file_id)?;
    ~new_frame = pool.fetch_page(tree.file_id, new_page_id)?;

    # Left internal: keys [0..mid], children [0..mid+1]
    ~left = BTreeInternalNode.new(internal.header.page_id, tree.page_size, internal.is_root());
    left.set_leftmost_child(all_children[0]);
    for i in 0..mid {
        left.insert_entry(&all_keys[i], all_children[i + 1])?;
    }

    # Right internal: keys [mid+1..], children [mid+1..]
    ~right = BTreeInternalNode.new(new_page_id, tree.page_size, false);
    right.set_leftmost_child(all_children[mid + 1]);
    for i in (mid + 1)..all_keys.len() {
        right.insert_entry(&all_keys[i], all_children[i + 1])?;
    }

    # Write both nodes
    ~left_flushed = left.flush();
    pool.write_page(internal_frame, left_flushed)?;

    ~right_flushed = right.flush();
    pool.write_page(new_frame, right_flushed)?;
    pool.unpin_page(new_frame, true);

    Ok((push_up_key, new_page_id))
}

# Create a new root node when the old root splits
F create_new_root(
    tree: &~BTree,
    separator: &[u8],
    left_child: u32,
    right_child: u32,
    pool: &~BufferPool,
) -> Result<(), VaisError> {
    ~new_root_page = pool.allocate_page(tree.file_id)?;
    ~new_root_frame = pool.fetch_page(tree.file_id, new_root_page)?;

    ~root = BTreeInternalNode.new(new_root_page, tree.page_size, true);
    root.set_leftmost_child(left_child);
    root.insert_entry(separator, right_child)?;

    ~flushed = root.flush();
    pool.write_page(new_root_frame, flushed)?;
    pool.unpin_page(new_root_frame, true);

    # Clear root flag on old root
    # (handled at higher level or by page type)

    tree.set_root(new_root_page);
    Ok(())
}
