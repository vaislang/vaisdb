# Vector Engine WAL Record Payloads (0x20-0x2F)
# Based on Stage 2: WAL Design
# HNSW uses logical logging: record the result, not the process

U storage/error.{VaisError};
U storage/bytes.{write_bytes, read_bytes, write_vec_u64, read_vec_u64};
U std/bytes.{ByteBuffer};

# ============================================================================
# HNSW_INSERT_NODE (0x20) - Insert node into HNSW index
# ============================================================================

S HnswInsertNodePayload {
    node_id: u64,
    layer: u8,
    neighbors: Vec<(u64, f32)>,     # (neighbor_id, distance) pairs
    file_id: u8,
    page_id: u32,
    affected_pages: Vec<(u8, u32)>, # All (file_id, page_id) pairs affected
}

X HnswInsertNodePayload {
    F serialize(self, buf: &~ByteBuffer) {
        buf.put_u64_le(self.node_id);
        buf.put_u8(self.layer);

        # Serialize neighbors
        buf.put_u32_le(self.neighbors.len() as u32);
        L (neighbor_id, distance): &self.neighbors {
            buf.put_u64_le(neighbor_id);
            buf.put_f32_le(distance);
        }

        buf.put_u8(self.file_id);
        buf.put_u32_le(self.page_id);

        # Serialize affected_pages
        buf.put_u32_le(self.affected_pages.len() as u32);
        L (fid, pid): &self.affected_pages {
            buf.put_u8(fid);
            buf.put_u32_le(pid);
        }
    }

    F deserialize(buf: &ByteBuffer) -> Result<HnswInsertNodePayload, VaisError> {
        ~node_id = buf.get_u64_le()?;
        ~layer = buf.get_u8()?;

        # Deserialize neighbors
        ~neighbors_count = buf.get_u32_le()? as u64;
        ~neighbors = Vec.with_capacity(neighbors_count);
        L _: 0..neighbors_count {
            ~neighbor_id = buf.get_u64_le()?;
            ~distance = buf.get_f32_le()?;
            neighbors.push((neighbor_id, distance));
        }

        ~file_id = buf.get_u8()?;
        ~page_id = buf.get_u32_le()?;

        # Deserialize affected_pages
        ~affected_count = buf.get_u32_le()? as u64;
        ~affected_pages = Vec.with_capacity(affected_count);
        L _: 0..affected_count {
            ~fid = buf.get_u8()?;
            ~pid = buf.get_u32_le()?;
            affected_pages.push((fid, pid));
        }

        Ok(HnswInsertNodePayload {
            node_id,
            layer,
            neighbors,
            file_id,
            page_id,
            affected_pages,
        })
    }
}

# ============================================================================
# HNSW_DELETE_NODE (0x21) - Delete node from HNSW index
# ============================================================================

S HnswDeleteNodePayload {
    node_id: u64,
    layers_affected: Vec<u8>,
    file_id: u8,
    page_id: u32,
}

X HnswDeleteNodePayload {
    F serialize(self, buf: &~ByteBuffer) {
        buf.put_u64_le(self.node_id);

        # Serialize layers_affected
        buf.put_u32_le(self.layers_affected.len() as u32);
        L layer: &self.layers_affected {
            buf.put_u8(layer);
        }

        buf.put_u8(self.file_id);
        buf.put_u32_le(self.page_id);
    }

    F deserialize(buf: &ByteBuffer) -> Result<HnswDeleteNodePayload, VaisError> {
        ~node_id = buf.get_u64_le()?;

        # Deserialize layers_affected
        ~layers_count = buf.get_u32_le()? as u64;
        ~layers_affected = Vec.with_capacity(layers_count);
        L _: 0..layers_count {
            layers_affected.push(buf.get_u8()?);
        }

        ~file_id = buf.get_u8()?;
        ~page_id = buf.get_u32_le()?;

        Ok(HnswDeleteNodePayload {
            node_id,
            layers_affected,
            file_id,
            page_id,
        })
    }
}

# ============================================================================
# HNSW_UPDATE_EDGES (0x22) - Update edge connections
# ============================================================================

S HnswUpdateEdgesPayload {
    node_id: u64,
    layer: u8,
    old_neighbors: Vec<u64>,
    new_neighbors: Vec<u64>,
    file_id: u8,
    page_id: u32,
}

X HnswUpdateEdgesPayload {
    F serialize(self, buf: &~ByteBuffer) {
        buf.put_u64_le(self.node_id);
        buf.put_u8(self.layer);
        write_vec_u64(buf, &self.old_neighbors);
        write_vec_u64(buf, &self.new_neighbors);
        buf.put_u8(self.file_id);
        buf.put_u32_le(self.page_id);
    }

    F deserialize(buf: &ByteBuffer) -> Result<HnswUpdateEdgesPayload, VaisError> {
        ~node_id = buf.get_u64_le()?;
        ~layer = buf.get_u8()?;
        ~old_neighbors = read_vec_u64(buf)?;
        ~new_neighbors = read_vec_u64(buf)?;
        ~file_id = buf.get_u8()?;
        ~page_id = buf.get_u32_le()?;

        Ok(HnswUpdateEdgesPayload {
            node_id,
            layer,
            old_neighbors,
            new_neighbors,
            file_id,
            page_id,
        })
    }
}

# ============================================================================
# HNSW_LAYER_PROMOTE (0x23) - Promote node to higher layer
# ============================================================================

S HnswLayerPromotePayload {
    node_id: u64,
    new_max_layer: u8,
    file_id: u8,
    page_id: u32,
}

X HnswLayerPromotePayload {
    F serialize(self, buf: &~ByteBuffer) {
        buf.put_u64_le(self.node_id);
        buf.put_u8(self.new_max_layer);
        buf.put_u8(self.file_id);
        buf.put_u32_le(self.page_id);
    }

    F deserialize(buf: &ByteBuffer) -> Result<HnswLayerPromotePayload, VaisError> {
        ~node_id = buf.get_u64_le()?;
        ~new_max_layer = buf.get_u8()?;
        ~file_id = buf.get_u8()?;
        ~page_id = buf.get_u32_le()?;

        Ok(HnswLayerPromotePayload {
            node_id,
            new_max_layer,
            file_id,
            page_id,
        })
    }
}

# ============================================================================
# VECTOR_DATA_WRITE (0x24) - Write vector data
# ============================================================================

S VectorDataWritePayload {
    file_id: u8,
    page_id: u32,
    offset: u16,
    vector_data: Vec<u8>,
}

X VectorDataWritePayload {
    F serialize(self, buf: &~ByteBuffer) {
        buf.put_u8(self.file_id);
        buf.put_u32_le(self.page_id);
        buf.put_u16_le(self.offset);
        write_bytes(buf, &self.vector_data);
    }

    F deserialize(buf: &ByteBuffer) -> Result<VectorDataWritePayload, VaisError> {
        ~file_id = buf.get_u8()?;
        ~page_id = buf.get_u32_le()?;
        ~offset = buf.get_u16_le()?;
        ~vector_data = read_bytes(buf)?;

        Ok(VectorDataWritePayload {
            file_id,
            page_id,
            offset,
            vector_data,
        })
    }
}

# ============================================================================
# QUANTIZATION_UPDATE (0x25) - Update quantization codebook
# ============================================================================

S QuantizationUpdatePayload {
    index_id: u32,
    codebook: Vec<u8>,
}

X QuantizationUpdatePayload {
    F serialize(self, buf: &~ByteBuffer) {
        buf.put_u32_le(self.index_id);
        write_bytes(buf, &self.codebook);
    }

    F deserialize(buf: &ByteBuffer) -> Result<QuantizationUpdatePayload, VaisError> {
        ~index_id = buf.get_u32_le()?;
        ~codebook = read_bytes(buf)?;

        Ok(QuantizationUpdatePayload {
            index_id,
            codebook,
        })
    }
}
