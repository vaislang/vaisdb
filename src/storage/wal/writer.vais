# WAL Writer
# Single writer thread that appends records to WAL segment files
# Based on Stage 2: WAL Design
# Manages segment creation, record serialization, prev_lsn chain per txn

use std/file.{File, OpenMode, fsync};
use std/sync.{Mutex};
use std/hashmap.{HashMap};
use std/bytes.{ByteBuffer};

use storage/error.{VaisError, err_internal, err_wal_corruption};
use storage/constants.{
    WAL_RECORD_HEADER_SIZE, DEFAULT_WAL_SEGMENT_SIZE,
    WAL_SEGMENT_HEADER_SIZE,
};
use storage/wal/header.{WalRecordHeader};
use storage/wal/segment.{WalSegmentHeader, segment_filename};
use storage/wal/lsn.{LsnAllocator, NULL_LSN};
use storage/wal/buffer.{WalBuffer};
use storage/checksum.{calculate_wal_checksum};

# WAL Writer - manages appending records to WAL segment files
S WalWriter {
    wal_dir: Str,                     # Directory for WAL segment files
    segment_size: u32,                # Max segment size (default 256MB)
    lsn_allocator: LsnAllocator,      # Thread-safe LSN allocation
    prev_lsn_map: HashMap<u64, u64>,  # txn_id -> last LSN for that txn (undo chain)
    current_segment: u32,             # Current segment number
    current_file: Option<File>,       # Current open segment file
    current_segment_header: Option<WalSegmentHeader>,
    buffer: WalBuffer,                # Write buffer for batching
    lock: Mutex,
    is_open: bool,
}

I WalWriter {
    # Create a new WAL writer
    F new(wal_dir: Str, segment_size: u32) -> Result<WalWriter, VaisError> {
        ~lsn_allocator = LsnAllocator.new(segment_size);

        Ok(WalWriter {
            wal_dir,
            segment_size,
            lsn_allocator,
            prev_lsn_map: HashMap.new(),
            current_segment: 0,
            current_file: None,
            current_segment_header: None,
            buffer: WalBuffer.new(),
            lock: Mutex.new(),
            is_open: false,
        })
    }

    # Open or resume WAL writer from last known LSN
    F open(~self) -> Result<(), VaisError> {
        ~guard = self.lock.lock();

        # Create WAL directory if it doesn't exist
        std/file.create_dir_all(&self.wal_dir)?;

        # Find the latest segment
        ~latest_segment = self.find_latest_segment()?;
        if latest_segment > 0 {
            # Resume from existing segment
            self.current_segment = latest_segment;
            ~seg_path = self.segment_path(latest_segment);
            ~file = File.open(&seg_path, OpenMode.ReadWrite)?;

            # Read segment header to find last LSN
            ~header_buf = Vec.with_capacity(WAL_SEGMENT_HEADER_SIZE as usize);
            header_buf.resize(WAL_SEGMENT_HEADER_SIZE as usize, 0u8);
            file.read_at(0, &header_buf)?;
            ~seg_header = WalSegmentHeader.deserialize(&header_buf)?;

            # Resume LSN allocator from last LSN
            if seg_header.last_lsn != NULL_LSN {
                self.lsn_allocator = LsnAllocator.resume(seg_header.last_lsn, self.segment_size);
            }

            self.current_file = Some(file);
            self.current_segment_header = Some(seg_header);
        } else {
            # Create first segment
            self.create_new_segment()?;
        }

        self.is_open = true;
        drop(guard);
        Ok(())
    }

    # Write a WAL record
    # Returns the assigned LSN
    F write_record(
        ~self,
        txn_id: u64,
        record_type: u8,
        engine_type: u8,
        payload: &[u8],
    ) -> Result<u64, VaisError> {
        ~guard = self.lock.lock();

        ~record_length = WAL_RECORD_HEADER_SIZE + payload.len() as u32;

        # Allocate LSN
        ~(lsn, needs_new_segment) = self.lsn_allocator.allocate(record_length);

        if needs_new_segment {
            self.finalize_current_segment()?;
            self.create_new_segment()?;
        }

        # Get prev_lsn for this transaction (undo chain)
        ~prev_lsn = M self.prev_lsn_map.get(&txn_id) {
            Some(&prev) => prev,
            None => NULL_LSN,
        };

        # Build WAL record header
        ~header = WalRecordHeader.new(
            lsn,
            txn_id,
            prev_lsn,
            record_type,
            engine_type,
            record_length,
        );

        # Serialize header + payload
        ~record_buf = Vec.with_capacity(record_length as usize);
        record_buf.resize(record_length as usize, 0u8);
        ~buf = ByteBuffer.wrap(&record_buf);
        header.serialize(&buf);

        # Write payload after header
        for i in 0..payload.len() {
            record_buf[WAL_RECORD_HEADER_SIZE as usize + i] = payload[i];
        }

        # Compute CRC32C checksum over entire record (with checksum field zeroed)
        ~checksum = calculate_wal_checksum(&record_buf);
        # Write checksum at offset 36 (little-endian)
        record_buf[36] = (checksum & 0xFF) as u8;
        record_buf[37] = ((checksum >> 8) & 0xFF) as u8;
        record_buf[38] = ((checksum >> 16) & 0xFF) as u8;
        record_buf[39] = ((checksum >> 24) & 0xFF) as u8;

        # Append to buffer or write directly
        if self.buffer.can_fit(record_length) {
            self.buffer.append(&record_buf)?;
        } else {
            # Flush existing buffer first
            self.flush_buffer()?;
            self.buffer.append(&record_buf)?;
        }

        # Update prev_lsn for this transaction
        self.prev_lsn_map.insert(txn_id, lsn);

        # Update segment header's last_lsn
        if ~seg_header = &self.current_segment_header {
            if M seg_header {
                Some(ref ~h) => {
                    h.last_lsn = lsn;
                },
                None => {},
            }
        }

        drop(guard);
        Ok(lsn)
    }

    # Flush buffered records to disk
    F flush(~self) -> Result<(), VaisError> {
        ~guard = self.lock.lock();
        self.flush_buffer()?;
        drop(guard);
        Ok(())
    }

    # Flush and fsync to disk (durable write)
    F sync(~self) -> Result<(), VaisError> {
        ~guard = self.lock.lock();
        self.flush_buffer()?;
        M &self.current_file {
            Some(ref file) => {
                fsync(file)?;
            },
            None => {},
        }
        drop(guard);
        Ok(())
    }

    # Remove transaction from prev_lsn map (after commit/abort)
    F clear_txn(~self, txn_id: u64) {
        ~guard = self.lock.lock();
        self.prev_lsn_map.remove(&txn_id);
        drop(guard);
    }

    # Get the current LSN
    F current_lsn(self) -> u64 {
        self.lsn_allocator.current_lsn()
    }

    # Close the WAL writer
    F close(~self) -> Result<(), VaisError> {
        ~guard = self.lock.lock();
        if self.is_open {
            self.flush_buffer()?;
            self.finalize_current_segment()?;
            self.current_file = None;
            self.is_open = false;
        }
        drop(guard);
        Ok(())
    }

    # --- Private helpers ---

    # Flush the in-memory buffer to disk
    F flush_buffer(~self) -> Result<(), VaisError> {
        if self.buffer.is_empty() {
            return Ok(());
        }

        M &self.current_file {
            Some(ref file) => {
                file.write_all(self.buffer.contents())?;
            },
            None => {
                return Err(err_internal("WAL writer: no open segment file"));
            },
        }

        self.buffer.clear();
        Ok(())
    }

    # Create a new WAL segment file
    F create_new_segment(~self) -> Result<(), VaisError> {
        ~seg_num = self.lsn_allocator.current_segment_number();
        self.current_segment = seg_num;
        ~seg_path = self.segment_path(seg_num);

        ~file = File.create(&seg_path)?;

        # Write segment header
        ~first_lsn = self.lsn_allocator.current_lsn();
        ~seg_header = WalSegmentHeader.new(seg_num, first_lsn);

        ~header_buf = Vec.with_capacity(WAL_SEGMENT_HEADER_SIZE as usize);
        header_buf.resize(WAL_SEGMENT_HEADER_SIZE as usize, 0u8);
        seg_header.serialize_to(&header_buf);
        file.write_all(&header_buf)?;

        self.current_file = Some(file);
        self.current_segment_header = Some(seg_header);

        Ok(())
    }

    # Finalize the current segment (update header with last_lsn)
    F finalize_current_segment(~self) -> Result<(), VaisError> {
        M (&self.current_file, &self.current_segment_header) {
            (Some(ref file), Some(ref seg_header)) => {
                ~header_buf = Vec.with_capacity(WAL_SEGMENT_HEADER_SIZE as usize);
                header_buf.resize(WAL_SEGMENT_HEADER_SIZE as usize, 0u8);
                seg_header.serialize_to(&header_buf);
                file.write_at(0, &header_buf)?;
                fsync(file)?;
            },
            _ => {},
        }
        Ok(())
    }

    # Find the latest segment number in the WAL directory
    F find_latest_segment(self) -> Result<u32, VaisError> {
        ~entries = std/file.read_dir(&self.wal_dir)?;
        ~max_segment: u32 = 0;

        for entry in &entries {
            ~name = entry.file_name();
            # Segment files are named NNNNNN.wal (e.g., 000001.wal)
            if name.ends_with(".wal") && name.len() == 10 {
                M name[0..6].parse_u32() {
                    Ok(num) => {
                        if num > max_segment { max_segment = num; }
                    },
                    Err(_) => {},
                }
            }
        }

        Ok(max_segment)
    }

    # Build the full path for a segment file
    F segment_path(self, segment_number: u32) -> Str {
        ~filename = segment_filename(segment_number);
        self.wal_dir + "/" + &filename
    }
}
