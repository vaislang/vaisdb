# Memory-Mapped I/O for page access
# Uses mmap/munmap via std/file.vais (with C FFI fallback)
# Provides zero-copy page reads when possible

U std/file.{File};
U storage/constants.{DEFAULT_PAGE_SIZE};
U storage/error.{VaisError, err_mmap_failed, err_io};

# Memory-mapped file region
S MmapRegion {
    file: File,
    base_addr: u64,     # Base address of mmap region (0 if not mapped)
    length: u64,         # Length of mapped region
    page_size: u32,
}

X MmapRegion {
    # Create a new mmap region for a file
    F open(file: File, page_size: u32) -> Result<MmapRegion, VaisError> {
        ~file_size = file.size()?;
        if file_size == 0 {
            return Ok(MmapRegion {
                file,
                base_addr: 0,
                length: 0,
                page_size,
            });
        }

        ~addr = file.mmap(0, file_size as usize)?;
        Ok(MmapRegion {
            file,
            base_addr: addr,
            length: file_size,
            page_size,
        })
    }

    # Read a page via mmap (zero-copy slice reference)
    F read_page(self, page_id: u32) -> Result<&[u8], VaisError> {
        ~offset = (page_id as u64) * (self.page_size as u64);
        if offset + (self.page_size as u64) > self.length {
            return Err(err_io("mmap", "Page beyond mapped region"));
        }

        ~page_ptr = self.base_addr + offset;
        Ok(unsafe_slice_from_addr(page_ptr, self.page_size as usize))
    }

    # Write a page via mmap (copy into mapped region)
    F write_page(~self, page_id: u32, data: &[u8]) -> Result<(), VaisError> {
        ~offset = (page_id as u64) * (self.page_size as u64);
        if offset + (self.page_size as u64) > self.length {
            return Err(err_io("mmap", "Page beyond mapped region"));
        }

        ~page_ptr = self.base_addr + offset;
        unsafe_copy_to_addr(page_ptr, data, self.page_size as usize);
        Ok(())
    }

    # Sync mapped pages to disk
    F sync(self) -> Result<(), VaisError> {
        if self.base_addr != 0 {
            self.file.fsync()?;
        }
        Ok(())
    }

    # Remap after file extension
    F remap(~self) -> Result<(), VaisError> {
        if self.base_addr != 0 {
            self.file.munmap(self.base_addr, self.length as usize)?;
        }
        ~file_size = self.file.size()?;
        if file_size > 0 {
            self.base_addr = self.file.mmap(0, file_size as usize)?;
            self.length = file_size;
        }
        Ok(())
    }

    # Prefetch hint for sequential scan
    F advise_sequential(self, page_id: u32, count: u32) -> Result<(), VaisError> {
        ~offset = (page_id as u64) * (self.page_size as u64);
        ~length = (count as u64) * (self.page_size as u64);
        self.file.madvise(offset, length as usize, "sequential")?;
        Ok(())
    }

    # Close and unmap
    F close(~self) -> Result<(), VaisError> {
        if self.base_addr != 0 {
            self.file.munmap(self.base_addr, self.length as usize)?;
            self.base_addr = 0;
            self.length = 0;
        }
        Ok(())
    }

    # Check if a page is within the mapped region
    F is_page_mapped(self, page_id: u32) -> bool {
        ~offset = (page_id as u64) * (self.page_size as u64);
        offset + (self.page_size as u64) <= self.length
    }
}

# Extern C FFI helpers for raw pointer operations
extern "C" {
    F unsafe_slice_from_addr(addr: u64, len: usize) -> &[u8];
    F unsafe_copy_to_addr(addr: u64, data: &[u8], len: usize);
}
