# Tuple Layout Within Heap Page
# Each tuple: [MvccTupleMeta (32B)] + [User Data (variable)]
# Handles overflow detection and inline prefix for large tuples

U storage/constants.{MVCC_TUPLE_META_SIZE, PAGE_HEADER_SIZE, SLOT_ENTRY_SIZE};
U storage/error.{VaisError, err_internal};
U storage/page/mvcc.{MvccTupleMeta};

# Overflow threshold: inline prefix size for overflowed tuples
L OVERFLOW_INLINE_PREFIX: u32 = 64;

# Overflow pointer size: page_id (u32) + total_len (u32) = 8 bytes
L OVERFLOW_POINTER_SIZE: u32 = 8;

# Tuple overflow flag (stored in first byte of user data area as a marker)
L TUPLE_FLAG_OVERFLOW: u8 = 0x01;
L TUPLE_FLAG_NORMAL: u8 = 0x00;

# Represents a tuple stored in a heap page
S Tuple {
    mvcc: MvccTupleMeta,
    user_data: Vec<u8>,
    is_overflow: bool,
    overflow_page_id: u32,      # First overflow page (0 if not overflow)
    overflow_total_len: u32,    # Total user data length (for overflow)
}

X Tuple {
    # Create a new tuple with user data
    F new(mvcc: MvccTupleMeta, user_data: Vec<u8>) -> Tuple {
        Tuple {
            mvcc,
            user_data,
            is_overflow: false,
            overflow_page_id: 0,
            overflow_total_len: 0,
        }
    }

    # Create a tuple with overflow pointer
    F new_overflow(mvcc: MvccTupleMeta, inline_prefix: Vec<u8>,
                   overflow_page_id: u32, overflow_total_len: u32) -> Tuple {
        Tuple {
            mvcc,
            user_data: inline_prefix,
            is_overflow: true,
            overflow_page_id,
            overflow_total_len,
        }
    }

    # Calculate on-page size of this tuple
    F on_page_size(self) -> u32 {
        I self.is_overflow {
            # MVCC (32B) + flag (1B) + inline prefix + overflow pointer (8B)
            MVCC_TUPLE_META_SIZE + 1 + self.user_data.len() as u32 + OVERFLOW_POINTER_SIZE
        } E {
            # MVCC (32B) + flag (1B) + user data
            MVCC_TUPLE_META_SIZE + 1 + self.user_data.len() as u32
        }
    }

    # Check if user data needs overflow for given page size
    F needs_overflow(user_data_len: u32, page_size: u32) -> bool {
        ~max_tuple = page_size - PAGE_HEADER_SIZE - SLOT_ENTRY_SIZE;
        ~normal_size = MVCC_TUPLE_META_SIZE + 1 + user_data_len;
        normal_size > max_tuple
    }

    # Calculate maximum inline user data size for a page
    F max_inline_size(page_size: u32) -> u32 {
        # page_size - header(48) - one_slot(4) - mvcc(32) - flag(1)
        page_size - PAGE_HEADER_SIZE - SLOT_ENTRY_SIZE - MVCC_TUPLE_META_SIZE - 1
    }

    # Write tuple to a byte slice at the given offset
    F write_to(self, page_data: &~[u8], offset: u64) {
        ~buf = ByteBuffer.wrap(&page_data[offset..]);
        self.mvcc.serialize(&buf);

        I self.is_overflow {
            buf.put_u8(TUPLE_FLAG_OVERFLOW);
            buf.put_bytes(&self.user_data);
            buf.put_u32_le(self.overflow_page_id);
            buf.put_u32_le(self.overflow_total_len);
        } E {
            buf.put_u8(TUPLE_FLAG_NORMAL);
            buf.put_bytes(&self.user_data);
        }
    }

    # Read tuple from a byte slice at the given offset with known length
    F read_from(page_data: &[u8], offset: u64, len: u64) -> Result<Tuple, VaisError> {
        ~buf = ByteBuffer.wrap_readonly(&page_data[offset..offset + len]);
        ~mvcc = MvccTupleMeta.deserialize(&buf)?;
        ~flag = buf.get_u8()?;

        I flag == TUPLE_FLAG_OVERFLOW {
            ~remaining = len - MVCC_TUPLE_META_SIZE as u64 - 1 - OVERFLOW_POINTER_SIZE as u64;
            ~inline_data = buf.get_bytes(remaining)?;
            ~overflow_page_id = buf.get_u32_le()?;
            ~overflow_total_len = buf.get_u32_le()?;
            Ok(Tuple.new_overflow(mvcc, inline_data, overflow_page_id, overflow_total_len))
        } E {
            ~remaining = len - MVCC_TUPLE_META_SIZE as u64 - 1;
            ~user_data = buf.get_bytes(remaining)?;
            Ok(Tuple.new(mvcc, user_data))
        }
    }

    # Get reference to MVCC metadata
    F get_mvcc(self) -> &MvccTupleMeta {
        &self.mvcc
    }

    # Get mutable reference to MVCC metadata
    F get_mvcc_mut(~self) -> &~MvccTupleMeta {
        &self.mvcc
    }

    # Get user data reference
    F get_data(self) -> &Vec<u8> {
        &self.user_data
    }
}
