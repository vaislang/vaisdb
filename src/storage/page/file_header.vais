# File Header for non-data files
# vectors.vdb, graph.vdb, fulltext.vdb, undo.vdb each have this at page 0
# Total used: 256 bytes (48 header + rest as data)

U std/bytes.{ByteBuffer};
U storage/constants.{
    VAISDB_MAGIC, DB_FORMAT_VERSION, PAGE_HEADER_SIZE,
    FILE_HEADER_RESERVED_SIZE,
};
U storage/error.{VaisError, err_invalid_magic, err_internal};
U storage/page/header.{PageHeader};
U storage/page/types.{PAGE_TYPE_META, ENGINE_TAG_COMMON};

# File header data (after 48B page header)
S FileHeader {
    magic: u64,                # 0x5641495344422031 ("VAISDB 1")
    db_format_version: u32,    # Database format version
    page_size: u32,            # Page size in bytes
    file_id: u8,               # This file's ID (1=vectors, 2=graph, 3=fulltext, 4=undo)
    total_pages: u32,          # Total pages allocated in this file
    freelist_page: u32,        # Page ID of first freelist page (always 1)
    reserved: [u8; 183],       # Reserved (must be 0)
}

X FileHeader {
    # Create a new file header
    F new(file_id: u8, page_size: u32, total_pages: u32) -> FileHeader {
        FileHeader {
            magic: VAISDB_MAGIC,
            db_format_version: DB_FORMAT_VERSION,
            page_size,
            file_id,
            total_pages,
            freelist_page: 1,  # Freelist always at page 1
            reserved: [0u8; 183],
        }
    }

    # Serialize file header data (after page header)
    F serialize(self, buf: &~ByteBuffer) {
        buf.put_u64_le(self.magic);
        buf.put_u32_le(self.db_format_version);
        buf.put_u32_le(self.page_size);
        buf.put_u8(self.file_id);
        buf.put_u32_le(self.total_pages);
        buf.put_u32_le(self.freelist_page);
        buf.put_bytes(&self.reserved);
    }

    # Deserialize file header data
    F deserialize(buf: &ByteBuffer) -> Result<FileHeader, VaisError> {
        ~magic = buf.get_u64_le()?;
        I magic != VAISDB_MAGIC {
            R Err(err_invalid_magic());
        }
        Ok(FileHeader {
            magic,
            db_format_version: buf.get_u32_le()?,
            page_size: buf.get_u32_le()?,
            file_id: buf.get_u8()?,
            total_pages: buf.get_u32_le()?,
            freelist_page: buf.get_u32_le()?,
            reserved: buf.get_bytes(183)?.try_into()?,
        })
    }

    # Write complete file header page to a page-sized buffer
    F write_to_page(self, page_data: &~[u8]) {
        ~header = PageHeader.new(0, PAGE_TYPE_META, ENGINE_TAG_COMMON);
        ~buf = ByteBuffer.wrap(page_data);
        header.serialize(&buf);
        self.serialize(&buf);
    }

    # Read file header from a page-sized buffer
    F read_from_page(page_data: &[u8]) -> Result<FileHeader, VaisError> {
        ~buf = ByteBuffer.wrap_readonly(page_data);
        buf.set_position(PAGE_HEADER_SIZE as u64);
        FileHeader.deserialize(&buf)
    }

    # Validate file header
    F validate(self) -> Result<(), VaisError> {
        I self.magic != VAISDB_MAGIC {
            R Err(err_invalid_magic());
        }
        I self.page_size != 8192 && self.page_size != 16384 {
            R Err(err_internal("Invalid page size in file header"));
        }
        I self.file_id > 4 {
            R Err(err_internal("Invalid file_id in file header"));
        }
        Ok(())
    }

    # Update total page count
    F set_total_pages(~self, total: u32) {
        self.total_pages = total;
    }
}

# Get file name for a given file_id
F file_name_for_id(file_id: u8) -> Str {
    M file_id {
        0 => "data.vdb",
        1 => "vectors.vdb",
        2 => "graph.vdb",
        3 => "fulltext.vdb",
        4 => "undo.vdb",
        _ => "unknown.vdb",
    }
}

# Get engine tag for a file_id
F engine_tag_for_file(file_id: u8) -> u8 {
    M file_id {
        0 => 0x01,  # sql
        1 => 0x02,  # vector
        2 => 0x03,  # graph
        3 => 0x04,  # fulltext
        4 => 0x00,  # common (undo)
        _ => 0x00,
    }
}
