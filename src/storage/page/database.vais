# Database Open/Create
# Implements the 7-step startup sequence from Stage 1 Section 11

use std/file.{File};
use std/dir.{Dir};
use std/time.{Time};
use std/random.{Random};
use storage/constants.{
    DEFAULT_PAGE_SIZE, FILE_ID_DATA, FILE_ID_VECTORS,
    FILE_ID_GRAPH, FILE_ID_FULLTEXT, FILE_ID_UNDO,
    FILE_NAME_DATA, FILE_NAME_VECTORS, FILE_NAME_GRAPH,
    FILE_NAME_FULLTEXT, FILE_NAME_UNDO, FILE_NAME_META,
    FILE_NAME_LOCK, DIR_NAME_WAL, DIR_NAME_TMP,
    FILE_EXTENSION_INCREMENT,
};
use storage/error.{VaisError, err_file_not_found, err_flock_failed, err_io, err_internal};
use storage/page/header.{PageHeader};
use storage/page/meta.{MetaPageHeader};
use storage/page/bootstrap.{BootstrapPage};
use storage/page/file_header.{FileHeader};
use storage/page/types.{PAGE_TYPE_FREELIST, ENGINE_TAG_COMMON};
use storage/checksum.{calculate_page_checksum};

# Database handle - manages all files in the .vaisdb directory
S Database {
    db_path: Str,              # Path to .vaisdb directory
    page_size: u32,            # Page size (8192 or 16384)
    meta: MetaPageHeader,      # Cached meta page header
    data_file: File,           # data.vdb handle
    vectors_file: File,        # vectors.vdb handle
    graph_file: File,          # graph.vdb handle
    fulltext_file: File,       # fulltext.vdb handle
    undo_file: File,           # undo.vdb handle
    meta_file: File,           # meta.vdb handle
    lock_file: File,           # lock file handle
}

I Database {
    # Create a new database at the given path
    F create(db_path: Str, page_size: u32) -> Result<Database, VaisError> {
        # Validate page size
        if page_size != 8192 && page_size != 16384 {
            return Err(err_internal("Page size must be 8192 or 16384"));
        }

        # Create directory structure
        Dir.create(db_path)?;
        Dir.create("{db_path}/{DIR_NAME_WAL}")?;
        Dir.create("{db_path}/{DIR_NAME_TMP}")?;

        # Generate UUID and timestamp
        ~db_uuid = generate_uuid();
        ~creation_ts = Time.now_micros();

        # Create and write meta.vdb (authoritative metadata)
        ~meta_header = MetaPageHeader.new(page_size, db_uuid, creation_ts);
        ~meta_file = File.open("{db_path}/{FILE_NAME_META}", "rw+")?;
        ~meta_page = Vec.with_capacity(page_size as usize);
        meta_page.resize(page_size as usize, 0u8);
        meta_header.write_to_page(&meta_page);
        PageHeader.update_checksum(&meta_page);
        meta_file.write_at(0, &meta_page)?;
        meta_file.fsync()?;

        # Create and write data.vdb with bootstrap page + freelist
        ~data_file = File.open("{db_path}/{FILE_NAME_DATA}", "rw+")?;
        write_bootstrap_page(&data_file, page_size)?;
        write_initial_freelist(&data_file, page_size, FILE_ID_DATA)?;
        data_file.fsync()?;

        # Create engine files with headers + freelists
        ~vectors_file = create_engine_file(db_path, FILE_NAME_VECTORS, FILE_ID_VECTORS, page_size)?;
        ~graph_file = create_engine_file(db_path, FILE_NAME_GRAPH, FILE_ID_GRAPH, page_size)?;
        ~fulltext_file = create_engine_file(db_path, FILE_NAME_FULLTEXT, FILE_ID_FULLTEXT, page_size)?;
        ~undo_file = create_engine_file(db_path, FILE_NAME_UNDO, FILE_ID_UNDO, page_size)?;

        # Create lock file
        ~lock_file = File.open("{db_path}/{FILE_NAME_LOCK}", "rw+")?;
        lock_file.flock()?;

        Ok(Database {
            db_path,
            page_size,
            meta: meta_header,
            data_file,
            vectors_file,
            graph_file,
            fulltext_file,
            undo_file,
            meta_file,
            lock_file,
        })
    }

    # Open an existing database (7-step startup sequence)
    F open(db_path: Str) -> Result<Database, VaisError> {
        # Step 1: Open data.vdb → read page 0 → verify magic → extract page_size
        ~data_file = File.open("{db_path}/{FILE_NAME_DATA}", "rw")?;
        ~page0_buf = data_file.read_at(0, 8192)?;  # Read min page size first
        ~bootstrap = BootstrapPage.read_from_page(&page0_buf)?;
        bootstrap.validate()?;
        ~page_size = bootstrap.page_size;

        # Step 2: Open meta.vdb → read page 0 → verify magic → load database header
        ~meta_file = File.open("{db_path}/{FILE_NAME_META}", "rw")?;
        ~meta_buf = meta_file.read_at(0, page_size as usize)?;
        ~meta = MetaPageHeader.read_from_page(&meta_buf)?;
        meta.validate()?;

        # Step 3-4: CLOG and config loading deferred to recovery phase

        # Step 5: Open remaining files → verify headers
        ~vectors_file = open_and_verify_file(db_path, FILE_NAME_VECTORS, FILE_ID_VECTORS, page_size)?;
        ~graph_file = open_and_verify_file(db_path, FILE_NAME_GRAPH, FILE_ID_GRAPH, page_size)?;
        ~fulltext_file = open_and_verify_file(db_path, FILE_NAME_FULLTEXT, FILE_ID_FULLTEXT, page_size)?;
        ~undo_file = open_and_verify_file(db_path, FILE_NAME_UNDO, FILE_ID_UNDO, page_size)?;

        # Acquire lock
        ~lock_file = File.open("{db_path}/{FILE_NAME_LOCK}", "rw+")?;
        lock_file.flock()?;

        # Clean tmp directory
        Dir.remove_contents("{db_path}/{DIR_NAME_TMP}")?;

        # Steps 6-7: Recovery and accept connections handled by caller

        Ok(Database {
            db_path,
            page_size,
            meta,
            data_file,
            vectors_file,
            graph_file,
            fulltext_file,
            undo_file,
            meta_file,
            lock_file,
        })
    }

    # Get file handle by file_id
    F get_file(self, file_id: u8) -> &File {
        M file_id {
            0 => &self.data_file,
            1 => &self.vectors_file,
            2 => &self.graph_file,
            3 => &self.fulltext_file,
            4 => &self.undo_file,
            _ => &self.data_file,  # Should not happen
        }
    }

    # Get mutable file handle by file_id
    F get_file_mut(~self, file_id: u8) -> &~File {
        M file_id {
            0 => &self.data_file,
            1 => &self.vectors_file,
            2 => &self.graph_file,
            3 => &self.fulltext_file,
            4 => &self.undo_file,
            _ => &self.data_file,
        }
    }

    # Flush meta page to disk
    F flush_meta(~self) -> Result<(), VaisError> {
        ~page_buf = Vec.with_capacity(self.page_size as usize);
        page_buf.resize(self.page_size as usize, 0u8);
        self.meta.write_to_page(&page_buf);
        PageHeader.update_checksum(&page_buf);
        self.meta_file.write_at(0, &page_buf)?;
        self.meta_file.fsync()?;
        Ok(())
    }

    # Close the database (release lock, close files)
    F close(~self) -> Result<(), VaisError> {
        self.flush_meta()?;
        self.lock_file.flock_unlock()?;
        Ok(())
    }

    # Get database path
    F path(self) -> &Str {
        &self.db_path
    }

    # Get page size
    F get_page_size(self) -> u32 {
        self.page_size
    }

    # Get meta header reference
    F get_meta(self) -> &MetaPageHeader {
        &self.meta
    }

    # Get mutable meta header
    F get_meta_mut(~self) -> &~MetaPageHeader {
        &self.meta
    }
}

# Helper: write bootstrap page to data.vdb
F write_bootstrap_page(file: &File, page_size: u32) -> Result<(), VaisError> {
    ~bootstrap = BootstrapPage.new(page_size);
    ~page_buf = Vec.with_capacity(page_size as usize);
    page_buf.resize(page_size as usize, 0u8);
    bootstrap.write_to_page(&page_buf);
    PageHeader.update_checksum(&page_buf);
    file.write_at(0, &page_buf)?;
    Ok(())
}

# Helper: write initial empty freelist page at page 1
F write_initial_freelist(file: &File, page_size: u32, file_id: u8) -> Result<(), VaisError> {
    ~header = PageHeader.new(1, PAGE_TYPE_FREELIST, ENGINE_TAG_COMMON);
    ~page_buf = Vec.with_capacity(page_size as usize);
    page_buf.resize(page_size as usize, 0u8);

    ~buf = ByteBuffer.wrap(&page_buf);
    header.serialize(&buf);

    # Mark pages 0 (header/bootstrap) and 1 (freelist) as allocated (bit=0)
    # All other bits default to 0 (allocated) - new pages start allocated
    # File extension will mark new pages as free

    PageHeader.update_checksum(&page_buf);
    file.write_at(page_size as u64, &page_buf)?;
    Ok(())
}

# Helper: create an engine file with header + freelist
F create_engine_file(db_path: &Str, file_name: &Str, file_id: u8, page_size: u32) -> Result<File, VaisError> {
    ~file = File.open("{db_path}/{file_name}", "rw+")?;

    # Write file header at page 0
    ~file_header = FileHeader.new(file_id, page_size, FILE_EXTENSION_INCREMENT + 2);
    ~page_buf = Vec.with_capacity(page_size as usize);
    page_buf.resize(page_size as usize, 0u8);
    file_header.write_to_page(&page_buf);
    PageHeader.update_checksum(&page_buf);
    file.write_at(0, &page_buf)?;

    # Write freelist at page 1
    write_initial_freelist(&file, page_size, file_id)?;

    file.fsync()?;
    Ok(file)
}

# Helper: open and verify an engine file
F open_and_verify_file(db_path: &Str, file_name: &Str, expected_file_id: u8, page_size: u32) -> Result<File, VaisError> {
    ~file = File.open("{db_path}/{file_name}", "rw")?;
    ~page_buf = file.read_at(0, page_size as usize)?;
    ~file_header = FileHeader.read_from_page(&page_buf)?;
    file_header.validate()?;

    if file_header.file_id != expected_file_id {
        return Err(err_internal("File ID mismatch in {file_name}"));
    }
    if file_header.page_size != page_size {
        return Err(err_internal("Page size mismatch in {file_name}"));
    }

    Ok(file)
}

# Generate a random UUID v4
F generate_uuid() -> [u8; 16] {
    ~uuid = [0u8; 16];
    ~rng = Random.new();
    for i in 0..16 {
        uuid[i] = rng.uniform(0, 255) as u8;
    }
    # Set version 4 (bits 4-7 of byte 6)
    uuid[6] = (uuid[6] & 0x0F) | 0x40;
    # Set variant 1 (bits 6-7 of byte 8)
    uuid[8] = (uuid[8] & 0x3F) | 0x80;
    uuid
}
