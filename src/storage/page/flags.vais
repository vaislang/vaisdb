# Page Flags (u16 bit field)
# Bit operations for the flags field in PageHeader

U storage/constants.{
    FLAG_IS_LEAF, FLAG_IS_ROOT, FLAG_IS_OVERFLOW,
    FLAG_IS_COMPRESSED, FLAG_NEEDS_COMPACTION,
    FLAG_IS_PINNED, FLAG_HAS_TOMBSTONES,
};

# Page flags wrapper for convenient bit manipulation
S PageFlags {
    bits: u16,
}

X PageFlags {
    F new() -> PageFlags {
        PageFlags { bits: 0 }
    }

    F from_bits(bits: u16) -> PageFlags {
        PageFlags { bits }
    }

    # Individual flag getters
    F is_leaf(self) -> bool {
        (self.bits & FLAG_IS_LEAF) != 0
    }

    F is_root(self) -> bool {
        (self.bits & FLAG_IS_ROOT) != 0
    }

    F is_overflow(self) -> bool {
        (self.bits & FLAG_IS_OVERFLOW) != 0
    }

    F is_compressed(self) -> bool {
        (self.bits & FLAG_IS_COMPRESSED) != 0
    }

    F needs_compaction(self) -> bool {
        (self.bits & FLAG_NEEDS_COMPACTION) != 0
    }

    F is_pinned(self) -> bool {
        (self.bits & FLAG_IS_PINNED) != 0
    }

    F has_tombstones(self) -> bool {
        (self.bits & FLAG_HAS_TOMBSTONES) != 0
    }

    # Individual flag setters
    F set_leaf(~self, val: bool) {
        I val { self.bits |=FLAG_IS_LEAF; }
        E { self.bits &= !FLAG_IS_LEAF; }
    }

    F set_root(~self, val: bool) {
        I val { self.bits |=FLAG_IS_ROOT; }
        E { self.bits &= !FLAG_IS_ROOT; }
    }

    F set_overflow(~self, val: bool) {
        I val { self.bits |=FLAG_IS_OVERFLOW; }
        E { self.bits &= !FLAG_IS_OVERFLOW; }
    }

    F set_compressed(~self, val: bool) {
        I val { self.bits |=FLAG_IS_COMPRESSED; }
        E { self.bits &= !FLAG_IS_COMPRESSED; }
    }

    F set_needs_compaction(~self, val: bool) {
        I val { self.bits |=FLAG_NEEDS_COMPACTION; }
        E { self.bits &= !FLAG_NEEDS_COMPACTION; }
    }

    F set_pinned(~self, val: bool) {
        I val { self.bits |=FLAG_IS_PINNED; }
        E { self.bits &= !FLAG_IS_PINNED; }
    }

    F set_tombstones(~self, val: bool) {
        I val { self.bits |=FLAG_HAS_TOMBSTONES; }
        E { self.bits &= !FLAG_HAS_TOMBSTONES; }
    }

    # Bulk operations
    F set_flag(~self, flag: u16) {
        self.bits |= flag;
    }

    F clear_flag(~self, flag: u16) {
        self.bits &= !flag;
    }

    F has_flag(self, flag: u16) -> bool {
        (self.bits & flag) != 0
    }

    F to_bits(self) -> u16 {
        self.bits
    }
}
