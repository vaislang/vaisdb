# Page Allocator - Allocates and deallocates pages from per-file freelists
# Based on Stage 1 Section 8: Free Page Management
# Manages allocation hints and file extension

use std/sync.{Mutex};
use storage/constants.{
    NULL_PAGE, FILE_EXTENSION_INCREMENT,
    FILE_ID_DATA, FILE_ID_VECTORS, FILE_ID_GRAPH, FILE_ID_FULLTEXT, FILE_ID_UNDO
};
use storage/error.{VaisError, err_freelist_empty, err_internal};
use storage/page/freelist.{FreelistBitmap, pages_per_bitmap_page};

# Per-file allocation state
S FileAllocState {
    file_id: u8,                    # Which file this state tracks
    last_alloc_position: u32,       # Hint for sequential allocation
    total_pages: u32,               # Total pages in this file
    freelist_pages: u32,            # Number of freelist pages in chain
    freelist_head: u32,             # First freelist page (usually 1)
}

I FileAllocState {
    F new(file_id: u8, freelist_head: u32) -> FileAllocState {
        FileAllocState {
            file_id,
            last_alloc_position: 0,
            total_pages: 256,  # Initial file size
            freelist_pages: 1,
            freelist_head,
        }
    }
}

# Page allocator - manages allocation across all files
S PageAllocator {
    file_states: [FileAllocState; 5],  # One per file (data, vectors, graph, fulltext, undo)
    page_size: u32,                     # Page size (8KB or 16KB)
    pages_per_bitmap: u32,              # Cached: how many pages per freelist page
    extension_increment: u32,           # How many pages to add when extending
}

I PageAllocator {
    # Create a new page allocator
    F new(page_size: u32) -> PageAllocator {
        ~pages_per_bitmap = pages_per_bitmap_page(page_size);

        PageAllocator {
            file_states: [
                FileAllocState.new(FILE_ID_DATA, 1),
                FileAllocState.new(FILE_ID_VECTORS, 1),
                FileAllocState.new(FILE_ID_GRAPH, 1),
                FileAllocState.new(FILE_ID_FULLTEXT, 1),
                FileAllocState.new(FILE_ID_UNDO, 1),
            ],
            page_size,
            pages_per_bitmap,
            extension_increment: FILE_EXTENSION_INCREMENT,
        }
    }

    # Get file state for a given file_id
    F get_file_state(~self, file_id: u8) -> Result<&~FileAllocState, VaisError> {
        if file_id >= 5 {
            return Err(err_internal("Invalid file_id: {file_id}"));
        }
        Ok(&self.file_states[file_id as usize])
    }

    # Allocate a single page from the specified file
    # Returns the allocated page_id
    # NOTE: This is a simplified version - in real implementation, this would
    # interact with buffer pool to read/write freelist pages
    F allocate_page(~self, file_id: u8, bitmap: &~FreelistBitmap) -> Result<u32, VaisError> {
        ~state = self.get_file_state(file_id)?;

        # Try to find a free page starting from last allocation position
        M bitmap.find_first_free_fast(self.pages_per_bitmap, state.last_alloc_position) {
            Some(page_id) => {
                # Mark page as allocated
                bitmap.set_bit(page_id, self.pages_per_bitmap, false);

                # Update allocation hint
                state.last_alloc_position = page_id + 1;

                Ok(page_id)
            }
            None => {
                # No free pages available
                Err(err_freelist_empty())
            }
        }
    }

    # Deallocate a page, returning it to the free pool
    # NOTE: Caller must zero out the page data before deallocating
    F deallocate_page(~self, file_id: u8, page_id: u32, bitmap: &~FreelistBitmap) -> Result<(), VaisError> {
        # Verify file_id is valid
        if file_id >= 5 {
            return Err(err_internal("Invalid file_id: {file_id}"));
        }

        # Mark page as free
        bitmap.set_bit(page_id, self.pages_per_bitmap, true);

        Ok(())
    }

    # Allocate multiple pages (bulk allocation)
    # Attempts to allocate contiguous or near-contiguous pages for better locality
    # Returns Vec of allocated page_ids (may be fewer than requested)
    F allocate_bulk(~self, file_id: u8, count: u32, bitmap: &~FreelistBitmap) -> Result<Vec<u32>, VaisError> {
        ~state = self.get_file_state(file_id)?;

        # Use bitmap's bulk allocation
        ~allocated = bitmap.allocate_bulk(self.pages_per_bitmap, count);

        # Update allocation hint to end of allocated range
        if allocated.len() > 0 {
            ~last_allocated = allocated[allocated.len() - 1];
            state.last_alloc_position = last_allocated + 1;
        }

        Ok(allocated)
    }

    # Check if file needs extension (no free pages available)
    F needs_extension(self, file_id: u8, bitmap: &FreelistBitmap) -> bool {
        bitmap.count_free(self.pages_per_bitmap) == 0
    }

    # Calculate how many pages are needed after extension
    F pages_after_extension(self, file_id: u8) -> Result<u32, VaisError> {
        ~state = self.get_file_state_readonly(file_id)?;
        Ok(state.total_pages + self.extension_increment)
    }

    # Mark pages as free after file extension
    # Called after physical file has been extended
    F mark_extended_pages_free(
        ~self,
        file_id: u8,
        old_total: u32,
        new_total: u32,
        bitmap: &~FreelistBitmap
    ) -> Result<(), VaisError> {
        ~state = self.get_file_state(file_id)?;

        # Mark all new pages as free
        for page_id in old_total..new_total {
            bitmap.set_bit(page_id, self.pages_per_bitmap, true);
        }

        # Update total pages count
        state.total_pages = new_total;

        Ok(())
    }

    # Get readonly file state (for queries)
    F get_file_state_readonly(self, file_id: u8) -> Result<&FileAllocState, VaisError> {
        if file_id >= 5 {
            return Err(err_internal("Invalid file_id: {file_id}"));
        }
        Ok(&self.file_states[file_id as usize])
    }

    # Get allocation statistics for a file
    F get_stats(self, file_id: u8, bitmap: &FreelistBitmap) -> Result<AllocStats, VaisError> {
        ~state = self.get_file_state_readonly(file_id)?;
        ~free_pages = bitmap.count_free(self.pages_per_bitmap);
        ~allocated_pages = state.total_pages - free_pages;

        Ok(AllocStats {
            file_id,
            total_pages: state.total_pages,
            allocated_pages,
            free_pages,
            freelist_pages: state.freelist_pages,
            utilization_percent: if state.total_pages > 0 {
                (allocated_pages * 100) / state.total_pages
            } else {
                0
            },
        })
    }

    # Reset allocation hint to beginning (for testing or after major compaction)
    F reset_allocation_hint(~self, file_id: u8) -> Result<(), VaisError> {
        ~state = self.get_file_state(file_id)?;
        state.last_alloc_position = 0;
        Ok(())
    }
}

# Allocation statistics structure
S AllocStats {
    file_id: u8,
    total_pages: u32,
    allocated_pages: u32,
    free_pages: u32,
    freelist_pages: u32,
    utilization_percent: u32,
}

I AllocStats {
    F to_string(self) -> Str {
        "File {self.file_id}: {self.allocated_pages}/{self.total_pages} pages allocated ({self.utilization_percent}%), {self.free_pages} free"
    }
}

# Thread-safe page allocator wrapper
# In real implementation, this would coordinate with buffer pool
S ThreadSafeAllocator {
    inner: Mutex<PageAllocator>,
}

I ThreadSafeAllocator {
    F new(page_size: u32) -> ThreadSafeAllocator {
        ThreadSafeAllocator {
            inner: Mutex.new(PageAllocator.new(page_size)),
        }
    }

    # Thread-safe allocation
    F allocate_page(self, file_id: u8, bitmap: &~FreelistBitmap) -> Result<u32, VaisError> {
        ~guard = self.inner.lock();
        guard.allocate_page(file_id, bitmap)
    }

    # Thread-safe deallocation
    F deallocate_page(self, file_id: u8, page_id: u32, bitmap: &~FreelistBitmap) -> Result<(), VaisError> {
        ~guard = self.inner.lock();
        guard.deallocate_page(file_id, page_id, bitmap)
    }

    # Thread-safe bulk allocation
    F allocate_bulk(self, file_id: u8, count: u32, bitmap: &~FreelistBitmap) -> Result<Vec<u32>, VaisError> {
        ~guard = self.inner.lock();
        guard.allocate_bulk(file_id, count, bitmap)
    }

    # Thread-safe statistics query
    F get_stats(self, file_id: u8, bitmap: &FreelistBitmap) -> Result<AllocStats, VaisError> {
        ~guard = self.inner.lock();
        guard.get_stats(file_id, bitmap)
    }
}
