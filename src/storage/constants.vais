# Storage Engine Constants
# All magic numbers, sizes, and IDs used across the storage layer

# Page sizes
L PAGE_SIZE_8K: u32 = 8192;
L PAGE_SIZE_16K: u32 = 16384;
L DEFAULT_PAGE_SIZE: u32 = 8192;
L PAGE_HEADER_SIZE: u32 = 48;
L PAGE_BODY_SIZE_8K: u32 = 8144;   # 8192 - 48
L PAGE_BODY_SIZE_16K: u32 = 16336;  # 16384 - 48

# Database magic number: "VAISDB 1" in ASCII
L VAISDB_MAGIC: u64 = 0x5641495344422031;

# WAL segment magic: "VALW" in ASCII
L WAL_SEGMENT_MAGIC: u32 = 0x56414C57;

# Format versions
L DB_FORMAT_VERSION: u32 = 1;
L WAL_FORMAT_VERSION: u32 = 1;
L FILE_LAYOUT_VERSION: u32 = 1;

# File IDs
L FILE_ID_DATA: u8 = 0;
L FILE_ID_VECTORS: u8 = 1;
L FILE_ID_GRAPH: u8 = 2;
L FILE_ID_FULLTEXT: u8 = 3;
L FILE_ID_UNDO: u8 = 4;
L FILE_ID_SECURITY: u8 = 6;

# File names within .vaisdb directory
L FILE_NAME_DATA: Str = "data.vdb";
L FILE_NAME_VECTORS: Str = "vectors.vdb";
L FILE_NAME_GRAPH: Str = "graph.vdb";
L FILE_NAME_FULLTEXT: Str = "fulltext.vdb";
L FILE_NAME_UNDO: Str = "undo.vdb";
L FILE_NAME_META: Str = "meta.vdb";
L FILE_NAME_SECURITY: Str = "security.vdb";
L FILE_NAME_LOCK: Str = "lock";
L DIR_NAME_WAL: Str = "wal";
L DIR_NAME_TMP: Str = "tmp";

# WAL segment size
L DEFAULT_WAL_SEGMENT_SIZE: u32 = 67108864;  # 64MB

# WAL buffer size
L DEFAULT_WAL_BUFFER_SIZE: u32 = 16777216;  # 16MB

# Group commit timeout (microseconds)
L DEFAULT_GROUP_COMMIT_TIMEOUT_US: u32 = 1000;  # 1ms

# MVCC tuple metadata size
L MVCC_TUPLE_META_SIZE: u32 = 32;

# Heap page slot directory entry size
L SLOT_ENTRY_SIZE: u32 = 4;

# B+Tree entry sizes
L BTREE_INTERNAL_ENTRY_SIZE: u32 = 8;
L BTREE_LEAF_ENTRY_SIZE: u32 = 8;
L BTREE_LEFTMOST_CHILD_SIZE: u32 = 4;

# Undo entry fixed header size
L UNDO_ENTRY_HEADER_SIZE: u32 = 28;

# Meta page header size (after page header)
L META_PAGE_DATA_SIZE: u32 = 208;  # 256 total - 48 page header
L META_PAGE_RESERVED_SIZE: u32 = 128;

# Bootstrap/file header data size
L BOOTSTRAP_DATA_SIZE: u32 = 208;
L BOOTSTRAP_META_PATH_SIZE: u32 = 32;

# File header data size
L FILE_HEADER_RESERVED_SIZE: u32 = 183;

# WAL record header size
L WAL_RECORD_HEADER_SIZE: u32 = 48;

# WAL segment header size
L WAL_SEGMENT_HEADER_SIZE: u32 = 32;

# CLOG bits per transaction
L CLOG_BITS_PER_TXN: u32 = 2;

# Transaction status values (2 bits each)
L TXN_STATUS_IN_PROGRESS: u8 = 0;
L TXN_STATUS_COMMITTED: u8 = 1;
L TXN_STATUS_ABORTED: u8 = 2;
L TXN_STATUS_RESERVED: u8 = 3;

# File extension allocation increment (pages)
L FILE_EXTENSION_INCREMENT: u32 = 256;  # 256 pages = 2MB at 8KB

# B+Tree merge threshold
L BTREE_MERGE_THRESHOLD_PERCENT: u32 = 40;

# Page flags (u16 bit field)
L FLAG_IS_LEAF: u16 = 0x0002;         # Bit 1
L FLAG_IS_ROOT: u16 = 0x0004;         # Bit 2
L FLAG_IS_OVERFLOW: u16 = 0x0008;     # Bit 3
L FLAG_IS_COMPRESSED: u16 = 0x0010;   # Bit 4
L FLAG_NEEDS_COMPACTION: u16 = 0x0020; # Bit 5
L FLAG_IS_PINNED: u16 = 0x0040;       # Bit 6
L FLAG_HAS_TOMBSTONES: u16 = 0x0080;  # Bit 7

# Compression algorithms
L COMPRESSION_NONE: u8 = 0;
L COMPRESSION_LZ4: u8 = 1;
L COMPRESSION_ZSTD: u8 = 2;

# Undo entry types
L UNDO_INSERT: u8 = 0x01;
L UNDO_UPDATE: u8 = 0x02;
L UNDO_DELETE: u8 = 0x03;

# Transaction timeout default (seconds)
L DEFAULT_TXN_TIMEOUT_SEC: u32 = 300;

# Checkpoint interval default (seconds)
L DEFAULT_CHECKPOINT_INTERVAL_SEC: u32 = 300;

# Checkpoint WAL size trigger (bytes) - 256MB
L DEFAULT_CHECKPOINT_WAL_SIZE: u64 = 268435456;

# Max TID values (compact 4-byte encoding)
L TID_PAGE_BITS: u32 = 20;
L TID_SLOT_BITS: u32 = 12;
L TID_MAX_PAGE_ID: u32 = 0xFFFFF;     # 1M pages
L TID_MAX_SLOT_ID: u16 = 0xFFF;       # 4096 slots

# Null/invalid page reference
L NULL_PAGE: u32 = 0;
L INVALID_TXN_ID: u64 = 0;
L NULL_UNDO_PTR: u64 = 0;

# CLOG cache default pages
L DEFAULT_CLOG_CACHE_PAGES: u32 = 8;

# Helper: calculate CLOG transactions per page
F clog_txns_per_page(page_size: u32) -> u32 {
    (page_size - PAGE_HEADER_SIZE) * 4
}

# Helper: calculate freelist pages per bitmap page
F freelist_pages_per_bitmap(page_size: u32) -> u32 {
    (page_size - PAGE_HEADER_SIZE) * 8
}

# Helper: calculate page body size
F page_body_size(page_size: u32) -> u32 {
    page_size - PAGE_HEADER_SIZE
}

# Helper: calculate maximum overflow data per page
F max_overflow_data_per_page(page_size: u32) -> u32 {
    page_size - PAGE_HEADER_SIZE
}
