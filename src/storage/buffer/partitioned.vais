# Partitioned Buffer Pool
# Splits total capacity across N partitions to reduce lock contention
# Each partition is an independent BufferPool

U std/sync.{Mutex};
U std/hashmap.{HashMap};
U storage/error.{VaisError, err_internal};
U storage/page/manager.{PageManager};
U storage/buffer/pool.{BufferPool};

# Partitioned buffer pool: N independent pools to reduce contention
S PartitionedBufferPool {
    partitions: Vec<BufferPool>,
    partition_count: u32,
    page_manager: PageManager,
}

X PartitionedBufferPool {
    # Create a new partitioned buffer pool
    # total_capacity is divided evenly across partitions
    F new(page_manager: PageManager, total_capacity: u32, partition_count: u32) -> PartitionedBufferPool {
        if partition_count == 0 {
            partition_count = 4;  # Default to 4 partitions
        }

        ~per_partition = total_capacity / partition_count;
        if per_partition == 0 {
            per_partition = 1;
        }

        ~partitions = Vec.with_capacity(partition_count as usize);
        for i in 0..partition_count {
            ~pool = BufferPool.new(page_manager.clone(), per_partition);
            partitions.push(pool);
        }

        PartitionedBufferPool {
            partitions,
            partition_count,
            page_manager,
        }
    }

    # Fetch a page into the buffer pool
    # Returns (partition_id, frame_id)
    F fetch_page(~self, file_id: u8, page_id: u32) -> Result<(u32, u32), VaisError> {
        ~partition_id = self.partition_for_page(file_id, page_id);
        ~frame_id = self.partitions[partition_id as usize].fetch_page(file_id, page_id)?;
        Ok((partition_id, frame_id))
    }

    # Unpin a page in a specific partition
    F unpin_page(~self, partition_id: u32, frame_id: u32, is_dirty: bool) {
        if partition_id >= self.partition_count {
            return;  # Invalid partition
        }
        self.partitions[partition_id as usize].unpin_page(frame_id, is_dirty);
    }

    # Get read-only reference to page data
    F get_page(self, partition_id: u32, frame_id: u32) -> &[u8] {
        self.partitions[partition_id as usize].get_page(frame_id)
    }

    # Get mutable reference to page data
    F get_page_mut(~self, partition_id: u32, frame_id: u32) -> &~[u8] {
        self.partitions[partition_id as usize].get_page_mut(frame_id)
    }

    # Flush a specific page
    F flush_page(~self, partition_id: u32, frame_id: u32) -> Result<(), VaisError> {
        self.partitions[partition_id as usize].flush_page(frame_id)
    }

    # Flush all dirty pages across all partitions
    F flush_all(~self) -> Result<(), VaisError> {
        for partition in &self.partitions {
            partition.flush_all()?;
        }
        Ok(())
    }

    # Release a page from the buffer pool
    F release_page(~self, partition_id: u32, frame_id: u32) {
        if partition_id >= self.partition_count {
            return;  # Invalid partition
        }
        self.partitions[partition_id as usize].release_page(frame_id);
    }

    # Determine which partition a page belongs to
    F partition_for_page(self, file_id: u8, page_id: u32) -> u32 {
        ~hash = hash_page_location(file_id, page_id);
        hash % self.partition_count
    }

    # Get total capacity across all partitions
    F get_capacity(self) -> u32 {
        ~total: u32 = 0;
        for partition in &self.partitions {
            total += partition.get_capacity();
        }
        total
    }

    # Get total used frames across all partitions
    F used_count(self) -> u32 {
        ~total: u32 = 0;
        for partition in &self.partitions {
            total += partition.used_count();
        }
        total
    }

    # Get total dirty page count across all partitions
    F dirty_count(self) -> u32 {
        ~total: u32 = 0;
        for partition in &self.partitions {
            total += partition.dirty_count();
        }
        total
    }

    # Get partition count
    F get_partition_count(self) -> u32 {
        self.partition_count
    }

    # Set FPI flag on all loaded frames (called after checkpoint)
    F set_all_needs_fpi(~self) {
        for partition in &self.partitions {
            partition.set_all_needs_fpi();
        }
    }

    # Check if a page needs FPI
    F needs_fpi(self, partition_id: u32, frame_id: u32) -> bool {
        self.partitions[partition_id as usize].needs_fpi(frame_id)
    }

    # Clear FPI flag for a frame
    F clear_fpi(~self, partition_id: u32, frame_id: u32) {
        self.partitions[partition_id as usize].clear_fpi(frame_id);
    }

    # Get partition reference (for stats collection)
    F get_partition(self, partition_id: u32) -> &BufferPool {
        &self.partitions[partition_id as usize]
    }
}

# Hash function for page location
# Uses FNV-1a hash for good distribution
F hash_page_location(file_id: u8, page_id: u32) -> u32 {
    ~hash: u64 = 14695981039346656037u64;  # FNV offset basis
    ~prime: u64 = 1099511628211u64;        # FNV prime

    # Hash file_id
    hash = hash ^ (file_id as u64);
    hash = hash * prime;

    # Hash page_id bytes
    hash = hash ^ ((page_id & 0xFF) as u64);
    hash = hash * prime;
    hash = hash ^ (((page_id >> 8) & 0xFF) as u64);
    hash = hash * prime;
    hash = hash ^ (((page_id >> 16) & 0xFF) as u64);
    hash = hash * prime;
    hash = hash ^ (((page_id >> 24) & 0xFF) as u64);
    hash = hash * prime;

    (hash & 0xFFFFFFFF) as u32
}
