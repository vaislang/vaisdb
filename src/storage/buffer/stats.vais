# Buffer Pool Statistics Collector
# Aggregates stats across partitioned buffer pools
# Provides metrics for monitoring and diagnostics

U storage/buffer/pool.{BufferPool, BufferPoolStats};
U storage/buffer/partitioned.{PartitionedBufferPool};

# Aggregated buffer pool statistics
S AggregatedStats {
    # Hit/miss metrics
    total_hits: u64,
    total_misses: u64,
    hit_rate: f64,

    # Capacity metrics
    total_capacity: u32,
    total_used: u32,
    usage_ratio: f64,

    # Dirty page metrics
    total_dirty: u32,
    dirty_ratio: f64,

    # Eviction metrics
    total_evictions: u64,
    total_flushes: u64,

    # Partition distribution (for partitioned pools)
    partition_count: u32,
    per_partition_usage: Vec<u32>,
}

X AggregatedStats {
    # Create empty stats
    F new() -> AggregatedStats {
        AggregatedStats {
            total_hits: 0,
            total_misses: 0,
            hit_rate: 0.0,
            total_capacity: 0,
            total_used: 0,
            usage_ratio: 0.0,
            total_dirty: 0,
            dirty_ratio: 0.0,
            total_evictions: 0,
            total_flushes: 0,
            partition_count: 0,
            per_partition_usage: Vec.new(),
        }
    }

    # Format statistics as human-readable string
    F format(self) -> Str {
        ~output = "Buffer Pool Statistics\n";
        output += "====================\n\n";

        # Hit/miss metrics
        output += "Cache Performance:\n";
        output += "  Hits:          {self.total_hits}\n";
        output += "  Misses:        {self.total_misses}\n";
        output += "  Hit Rate:      {self.hit_rate:.2}%\n\n";

        # Capacity metrics
        output += "Capacity:\n";
        output += "  Total Frames:  {self.total_capacity}\n";
        output += "  Used Frames:   {self.total_used}\n";
        output += "  Usage:         {self.usage_ratio:.2}%\n\n";

        # Dirty page metrics
        output += "Dirty Pages:\n";
        output += "  Dirty Count:   {self.total_dirty}\n";
        output += "  Dirty Ratio:   {self.dirty_ratio:.2}%\n\n";

        # Eviction metrics
        output += "Eviction:\n";
        output += "  Evictions:     {self.total_evictions}\n";
        output += "  Flushes:       {self.total_flushes}\n\n";

        # Partition distribution (if partitioned)
        if self.partition_count > 1 {
            output += "Partition Distribution:\n";
            for i in 0..self.partition_count {
                ~usage = self.per_partition_usage[i as usize];
                ~capacity = self.total_capacity / self.partition_count;
                ~ratio = if capacity > 0 {
                    (usage as f64) / (capacity as f64) * 100.0
                } else {
                    0.0
                };
                output += "  Partition {i}: {usage}/{capacity} ({ratio:.1}%)\n";
            }
            output += "\n";
        }

        output
    }

    # Format as single-line summary
    F format_summary(self) -> Str {
        "BufferPool: hit_rate={self.hit_rate:.1}% usage={self.usage_ratio:.1}% dirty={self.dirty_ratio:.1}%"
    }
}

# Buffer pool statistics collector
S BufferPoolStatsCollector {
}

X BufferPoolStatsCollector {
    # Create a new stats collector
    F new() -> BufferPoolStatsCollector {
        BufferPoolStatsCollector {}
    }

    # Collect stats from a single BufferPool
    F collect_single(self, pool: &BufferPool) -> AggregatedStats {
        ~stats = pool.get_stats();
        ~capacity = pool.get_capacity();
        ~used = pool.used_count();
        ~dirty = pool.dirty_count();

        ~total_accesses = stats.hits + stats.misses;
        ~hit_rate = if total_accesses > 0 {
            (stats.hits as f64) / (total_accesses as f64) * 100.0
        } else {
            100.0
        };

        ~usage_ratio = if capacity > 0 {
            (used as f64) / (capacity as f64) * 100.0
        } else {
            0.0
        };

        ~dirty_ratio = if used > 0 {
            (dirty as f64) / (used as f64) * 100.0
        } else {
            0.0
        };

        AggregatedStats {
            total_hits: stats.hits,
            total_misses: stats.misses,
            hit_rate,
            total_capacity: capacity,
            total_used: used,
            usage_ratio,
            total_dirty: dirty,
            dirty_ratio,
            total_evictions: stats.evictions,
            total_flushes: stats.flushes,
            partition_count: 1,
            per_partition_usage: vec![used],
        }
    }

    # Collect stats from a PartitionedBufferPool
    F collect_partitioned(self, pool: &PartitionedBufferPool) -> AggregatedStats {
        ~partition_count = pool.get_partition_count();
        ~total_capacity = pool.get_capacity();
        ~total_used = pool.used_count();
        ~total_dirty = pool.dirty_count();

        # Aggregate stats from all partitions
        ~total_hits: u64 = 0;
        ~total_misses: u64 = 0;
        ~total_evictions: u64 = 0;
        ~total_flushes: u64 = 0;
        ~per_partition_usage = Vec.with_capacity(partition_count as usize);

        for i in 0..partition_count {
            ~partition = pool.get_partition(i);
            ~partition_stats = partition.get_stats();
            ~partition_used = partition.used_count();

            total_hits += partition_stats.hits;
            total_misses += partition_stats.misses;
            total_evictions += partition_stats.evictions;
            total_flushes += partition_stats.flushes;
            per_partition_usage.push(partition_used);
        }

        # Calculate ratios
        ~total_accesses = total_hits + total_misses;
        ~hit_rate = if total_accesses > 0 {
            (total_hits as f64) / (total_accesses as f64) * 100.0
        } else {
            100.0
        };

        ~usage_ratio = if total_capacity > 0 {
            (total_used as f64) / (total_capacity as f64) * 100.0
        } else {
            0.0
        };

        ~dirty_ratio = if total_used > 0 {
            (total_dirty as f64) / (total_used as f64) * 100.0
        } else {
            0.0
        };

        AggregatedStats {
            total_hits,
            total_misses,
            hit_rate,
            total_capacity,
            total_used,
            usage_ratio,
            total_dirty,
            dirty_ratio,
            total_evictions,
            total_flushes,
            partition_count,
            per_partition_usage,
        }
    }
}

# Snapshot of buffer pool state for monitoring
S BufferPoolSnapshot {
    timestamp: u64,           # Unix timestamp
    stats: AggregatedStats,
}

X BufferPoolSnapshot {
    F new(stats: AggregatedStats) -> BufferPoolSnapshot {
        # In real implementation, would use std/time for timestamp
        BufferPoolSnapshot {
            timestamp: 0,  # Placeholder
            stats,
        }
    }

    F format(self) -> Str {
        ~header = "Snapshot at timestamp {self.timestamp}\n";
        header + self.stats.format()
    }
}

# Time-series stats collector (for monitoring trends)
S BufferPoolMonitor {
    snapshots: Vec<BufferPoolSnapshot>,
    max_snapshots: usize,
}

X BufferPoolMonitor {
    F new() -> BufferPoolMonitor {
        BufferPoolMonitor {
            snapshots: Vec.new(),
            max_snapshots: 60,  # Keep last 60 snapshots (e.g., 1 per minute)
        }
    }

    # Record a snapshot
    F record(~self, stats: AggregatedStats) {
        ~snapshot = BufferPoolSnapshot.new(stats);
        self.snapshots.push(snapshot);

        # Keep only the last N snapshots
        if self.snapshots.len() > self.max_snapshots {
            self.snapshots.remove(0);
        }
    }

    # Get the most recent snapshot
    F latest(self) -> Option<&BufferPoolSnapshot> {
        if self.snapshots.is_empty() {
            None
        } else {
            Some(&self.snapshots[self.snapshots.len() - 1])
        }
    }

    # Calculate hit rate trend (increase/decrease over time)
    F hit_rate_trend(self) -> Option<f64> {
        if self.snapshots.len() < 2 {
            return None;
        }

        ~first = &self.snapshots[0];
        ~last = &self.snapshots[self.snapshots.len() - 1];

        Some(last.stats.hit_rate - first.stats.hit_rate)
    }

    # Get average hit rate over all snapshots
    F average_hit_rate(self) -> f64 {
        if self.snapshots.is_empty() {
            return 0.0;
        }

        ~sum: f64 = 0.0;
        for snapshot in &self.snapshots {
            sum += snapshot.stats.hit_rate;
        }

        sum / (self.snapshots.len() as f64)
    }

    # Clear all snapshots
    F clear(~self) {
        self.snapshots.clear();
    }
}
