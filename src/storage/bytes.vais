# ByteBuffer - Binary serialization/deserialization
# All on-disk formats use little-endian, ByteBuffer-based serialization
# Based on Stage 7: Implementation Mapping, Pattern 1-13

U std/bytes.{ByteBuffer};

# Re-export ByteBuffer from std for convenience and add storage-specific helpers

# Encode a TID (Tuple ID) from page_id and slot_id
# Upper 20 bits = page_id, lower 12 bits = slot_id
F encode_tid(page_id: u32, slot_id: u16) -> u32 {
    ((page_id & 0xFFFFF) << 12) | ((slot_id & 0xFFF) as u32)
}

# Decode a TID into (page_id, slot_id)
F decode_tid(tid: u32) -> (u32, u16) {
    ~page_id = (tid >> 12) & 0xFFFFF;
    ~slot_id = (tid & 0xFFF) as u16;
    (page_id, slot_id)
}

# Encode an undo pointer from components
# Bits 63-56: file_id (u8)
# Bits 55-24: page_id (u32)
# Bits 23-8:  offset  (u16)
# Bits 7-0:   padding (u8) - always 0
F encode_undo_ptr(file_id: u8, page_id: u32, offset: u16) -> u64 {
    ((file_id as u64) << 56) |
    ((page_id as u64) << 24) |
    ((offset as u64) << 8)
}

# Decode an undo pointer into (file_id, page_id, offset)
F decode_undo_ptr(undo_ptr: u64) -> (u8, u32, u16) {
    ~file_id = ((undo_ptr >> 56) & 0xFF) as u8;
    ~page_id = ((undo_ptr >> 24) & 0xFFFFFFFF) as u32;
    ~offset = ((undo_ptr >> 8) & 0xFFFF) as u16;
    (file_id, page_id, offset)
}

# Encode an LSN from segment_number and offset_in_segment
F encode_lsn(segment_number: u32, offset: u32) -> u64 {
    ((segment_number as u64) << 32) | (offset as u64)
}

# Decode an LSN into (segment_number, offset_in_segment)
F decode_lsn(lsn: u64) -> (u32, u32) {
    ~segment_number = ((lsn >> 32) & 0xFFFFFFFF) as u32;
    ~offset = (lsn & 0xFFFFFFFF) as u32;
    (segment_number, offset)
}

# Write a length-prefixed string to ByteBuffer
F write_string(buf: &~ByteBuffer, s: &Str) {
    ~bytes = s.as_bytes();
    buf.put_u32_le(bytes.len() as u32);
    buf.put_bytes(bytes);
}

# Read a length-prefixed string from ByteBuffer
F read_string(buf: &ByteBuffer) -> Result<Str, VaisError> {
    ~len = buf.get_u32_le()? as usize;
    ~bytes = buf.get_bytes(len)?;
    Str.from_utf8(bytes)
}

# Write a length-prefixed byte array to ByteBuffer
F write_bytes(buf: &~ByteBuffer, data: &[u8]) {
    buf.put_u32_le(data.len() as u32);
    buf.put_bytes(data);
}

# Read a length-prefixed byte array from ByteBuffer
F read_bytes(buf: &ByteBuffer) -> Result<Vec<u8>, VaisError> {
    ~len = buf.get_u32_le()? as usize;
    buf.get_bytes(len)
}

# Write a Vec<u32> with length prefix
F write_vec_u32(buf: &~ByteBuffer, vec: &Vec<u32>) {
    buf.put_u32_le(vec.len() as u32);
    for val in vec {
        buf.put_u32_le(val);
    }
}

# Read a Vec<u32> with length prefix
F read_vec_u32(buf: &ByteBuffer) -> Result<Vec<u32>, VaisError> {
    ~count = buf.get_u32_le()? as usize;
    ~vec = Vec.with_capacity(count);
    for _ in 0..count {
        vec.push(buf.get_u32_le()?);
    }
    Ok(vec)
}

# Write a Vec<u64> with length prefix
F write_vec_u64(buf: &~ByteBuffer, vec: &Vec<u64>) {
    buf.put_u32_le(vec.len() as u32);
    for val in vec {
        buf.put_u64_le(val);
    }
}

# Read a Vec<u64> with length prefix
F read_vec_u64(buf: &ByteBuffer) -> Result<Vec<u64>, VaisError> {
    ~count = buf.get_u32_le()? as usize;
    ~vec = Vec.with_capacity(count);
    for _ in 0..count {
        vec.push(buf.get_u64_le()?);
    }
    Ok(vec)
}

# Zero a range in a byte slice (used for checksum computation)
F zero_range(data: &~[u8], offset: usize, len: usize) {
    for i in offset..(offset + len) {
        data[i] = 0;
    }
}
