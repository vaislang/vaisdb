# Client Types
# Connection string parsing, client configuration, result sets, row data access
# Error codes: EE=07 (client), CC=01

U std/vec.Vec;
U std/string.Str;
U std/option.{Option, Some, None};
U std/bytes.ByteBuffer;
U storage/error.{VaisError, ErrorSeverity};

# ============================================================================
# Connection String
# ============================================================================

# Parsed connection parameters from "vaisdb://user:pass@host:port/dbname"
S ConnectionString {
    host: Str,
    port: u16,
    database: Str,
    user: Str,
    password: Str,
    application_name: Str,
}

X ConnectionString {
    F new() -> ConnectionString {
        ConnectionString {
            host: "localhost",
            port: 5433,
            database: "vaisdb",
            user: "vaisdb",
            password: "",
            application_name: "",
        }
    }

    # Parse "vaisdb://user:pass@host:port/dbname"
    F parse(conn_str: &Str) -> Result<ConnectionString, VaisError> {
        ~bytes = conn_str.as_bytes();
        ~len = bytes.len();

        # Check scheme: "vaisdb://" = 9 chars
        I len < 10 {
            R Err(err_client_parse_error("Connection string too short"));
        }

        # Verify scheme prefix: v=118, a=97, i=105, s=115, d=100, b=98
        I bytes[0] != 118 || bytes[1] != 97 || bytes[2] != 105 || bytes[3] != 115 ||
          bytes[4] != 100 || bytes[5] != 98 || bytes[6] != 58 || bytes[7] != 47 || bytes[8] != 47 {
            R Err(err_client_parse_error("Missing 'vaisdb://' scheme"));
        }

        ~pos: u64 = 9;  # after "vaisdb://"
        ~host = "localhost";
        ~port: u16 = 5433;
        ~database = "vaisdb";
        ~user = "vaisdb";
        ~password = "";

        # Find '@' to split auth from host
        ~at_pos: i64 = -1;
        ~scan: u64 = pos;
        W scan < len {
            I bytes[scan] == 64 {  # '@'
                at_pos = scan as i64;
                scan = len;  # exit loop
            }
            scan += 1;
        }

        # Parse auth part (user:password) if '@' found
        I at_pos >= 0 {
            ~auth_start = pos;
            ~auth_end = at_pos as u64;

            # Find ':' in auth part
            ~colon_pos: i64 = -1;
            ~s: u64 = auth_start;
            W s < auth_end {
                I bytes[s] == 58 {  # ':'
                    colon_pos = s as i64;
                    s = auth_end;  # exit loop
                }
                s += 1;
            }

            I colon_pos >= 0 {
                ~user_bytes = Vec.new();
                ~u: u64 = auth_start;
                W u < colon_pos as u64 {
                    user_bytes.push(bytes[u]);
                    u += 1;
                }
                user = Str.from_utf8(user_bytes)?;

                ~pass_bytes = Vec.new();
                ~p: u64 = (colon_pos + 1) as u64;
                W p < auth_end {
                    pass_bytes.push(bytes[p]);
                    p += 1;
                }
                password = Str.from_utf8(pass_bytes)?;
            } E {
                ~user_bytes = Vec.new();
                ~u: u64 = auth_start;
                W u < auth_end {
                    user_bytes.push(bytes[u]);
                    u += 1;
                }
                user = Str.from_utf8(user_bytes)?;
            }

            pos = (at_pos + 1) as u64;
        }

        # Parse host:port/database
        # Find '/' for database separator
        ~slash_pos: i64 = -1;
        ~s2: u64 = pos;
        W s2 < len {
            I bytes[s2] == 47 {  # '/'
                slash_pos = s2 as i64;
                s2 = len;
            }
            s2 += 1;
        }

        ~host_port_end = I slash_pos >= 0 { slash_pos as u64 } E { len };

        # Find ':' in host:port section
        ~colon_pos2: i64 = -1;
        ~s3: u64 = pos;
        W s3 < host_port_end {
            I bytes[s3] == 58 {  # ':'
                colon_pos2 = s3 as i64;
                s3 = host_port_end;
            }
            s3 += 1;
        }

        I colon_pos2 >= 0 {
            ~host_bytes = Vec.new();
            ~h: u64 = pos;
            W h < colon_pos2 as u64 {
                host_bytes.push(bytes[h]);
                h += 1;
            }
            host = Str.from_utf8(host_bytes)?;

            # Parse port number
            ~port_val: u32 = 0;
            ~pp: u64 = (colon_pos2 + 1) as u64;
            W pp < host_port_end {
                ~ch = bytes[pp];
                I ch < 48 || ch > 57 {
                    R Err(err_client_parse_error("Invalid port number"));
                }
                port_val = port_val * 10 + (ch - 48) as u32;
                pp += 1;
            }
            I port_val > 65535 || port_val == 0 {
                R Err(err_client_parse_error("Port out of range (1-65535)"));
            }
            port = port_val as u16;
        } E {
            ~host_bytes = Vec.new();
            ~h: u64 = pos;
            W h < host_port_end {
                host_bytes.push(bytes[h]);
                h += 1;
            }
            I host_bytes.len() > 0 {
                host = Str.from_utf8(host_bytes)?;
            }
        }

        # Parse database name after '/'
        I slash_pos >= 0 {
            ~db_start = (slash_pos + 1) as u64;
            I db_start < len {
                ~db_bytes = Vec.new();
                ~d: u64 = db_start;
                W d < len {
                    db_bytes.push(bytes[d]);
                    d += 1;
                }
                I db_bytes.len() > 0 {
                    database = Str.from_utf8(db_bytes)?;
                }
            }
        }

        Ok(ConnectionString {
            host,
            port,
            database,
            user,
            password,
            application_name: "",
        })
    }

    F with_application_name(~self, name: Str) -> ConnectionString {
        self.application_name = name;
        self
    }
}

# ============================================================================
# Client Config
# ============================================================================

S ClientConfig {
    connection: ConnectionString,
    connect_timeout_sec: u32,
    query_timeout_sec: u32,
    pool_size: u32,
}

X ClientConfig {
    F new() -> ClientConfig {
        ClientConfig {
            connection: ConnectionString.new(),
            connect_timeout_sec: 10,
            query_timeout_sec: 30,
            pool_size: 5,
        }
    }

    F from_connection_string(conn_str: &Str) -> Result<ClientConfig, VaisError> {
        ~parsed = ConnectionString.parse(conn_str)?;
        Ok(ClientConfig {
            connection: parsed,
            connect_timeout_sec: 10,
            query_timeout_sec: 30,
            pool_size: 5,
        })
    }

    F with_connect_timeout(~self, seconds: u32) -> ClientConfig {
        self.connect_timeout_sec = seconds;
        self
    }

    F with_query_timeout(~self, seconds: u32) -> ClientConfig {
        self.query_timeout_sec = seconds;
        self
    }

    F with_pool_size(~self, size: u32) -> ClientConfig {
        self.pool_size = size;
        self
    }
}

# ============================================================================
# Column Info & Row
# ============================================================================

S ColumnInfo {
    name: Str,
    type_tag: u8,
}

X ColumnInfo {
    F new(name: Str, type_tag: u8) -> ColumnInfo {
        ColumnInfo { name, type_tag }
    }
}

# Row â€” raw cell data (None = NULL)
S ClientRow {
    values: Vec<Option<Vec<u8>>>,
}

X ClientRow {
    F new() -> ClientRow {
        ClientRow { values: Vec.new() }
    }

    F from_values(values: Vec<Option<Vec<u8>>>) -> ClientRow {
        ClientRow { values }
    }

    F is_null(self, index: u64) -> bool {
        I index >= self.values.len() {
            R true;
        }
        M &self.values[index] {
            None => true,
            Some(_) => false,
        }
    }

    # Get string value (decode from UTF-8)
    F get_string(self, index: u64) -> Option<Str> {
        I index >= self.values.len() {
            R None;
        }
        M &self.values[index] {
            None => None,
            Some(data) => {
                M Str.from_utf8(data.clone()) {
                    Ok(s) => Some(s),
                    Err(_) => None,
                }
            },
        }
    }

    # Get i64 value (little-endian 8 bytes via ByteBuffer)
    F get_int(self, index: u64) -> Option<i64> {
        I index >= self.values.len() {
            R None;
        }
        M &self.values[index] {
            None => None,
            Some(data) => {
                I data.len() != 8 {
                    R None;
                }
                ~buf = ByteBuffer.from_slice(data);
                M buf.get_u64_le() {
                    Ok(raw) => Some(raw as i64),
                    Err(_) => None,
                }
            },
        }
    }

    # Get f64 value (8 bytes via ByteBuffer, bit-cast)
    F get_float(self, index: u64) -> Option<f64> {
        I index >= self.values.len() {
            R None;
        }
        M &self.values[index] {
            None => None,
            Some(data) => {
                I data.len() != 8 {
                    R None;
                }
                ~buf = ByteBuffer.from_slice(data);
                M buf.get_u64_le() {
                    Ok(raw) => Some(raw as f64),
                    Err(_) => None,
                }
            },
        }
    }

    # Get bool value (1 byte: 0 or 1)
    F get_bool(self, index: u64) -> Option<bool> {
        I index >= self.values.len() {
            R None;
        }
        M &self.values[index] {
            None => None,
            Some(data) => {
                I data.len() < 1 {
                    R None;
                }
                Some(data[0] != 0)
            },
        }
    }

    F column_count(self) -> u64 {
        self.values.len()
    }
}

# ============================================================================
# Client Result
# ============================================================================

S ClientResult {
    columns: Vec<ColumnInfo>,
    rows: Vec<ClientRow>,
    affected_rows: u64,
    tag: Str,
}

X ClientResult {
    F new() -> ClientResult {
        ClientResult {
            columns: Vec.new(),
            rows: Vec.new(),
            affected_rows: 0,
            tag: "",
        }
    }

    F with_rows(columns: Vec<ColumnInfo>, rows: Vec<ClientRow>, tag: Str) -> ClientResult {
        ClientResult { columns, rows, affected_rows: 0, tag }
    }

    F with_affected(affected: u64, tag: Str) -> ClientResult {
        ClientResult {
            columns: Vec.new(),
            rows: Vec.new(),
            affected_rows: affected,
            tag,
        }
    }

    F column_count(self) -> u64 {
        self.columns.len()
    }

    F row_count(self) -> u64 {
        self.rows.len()
    }
}

# ============================================================================
# Client State
# ============================================================================

L ClientState = Disconnected | Connected | InTransaction;

# ============================================================================
# Error Constructors (EE=07 client, CC=01)
# ============================================================================

F err_client_connect_failed(host: Str, port: u16) -> VaisError {
    VaisError.new(
        "VAIS-0701001",
        "Connection failed to {host}:{port}"
    ).with_hint("Check network connectivity and server status")
}

F err_client_timeout(seconds: u32) -> VaisError {
    VaisError.new(
        "VAIS-0701002",
        "Client operation timeout after {seconds} seconds"
    ).with_hint("Increase timeout or check server load")
}

F err_client_parse_error(detail: Str) -> VaisError {
    VaisError.new(
        "VAIS-0701003",
        "Connection string parse error: {detail}"
    ).with_hint("Expected format: vaisdb://user:pass@host:port/dbname")
}

F err_client_not_connected() -> VaisError {
    VaisError.new(
        "VAIS-0701004",
        "Client is not connected to server"
    ).with_hint("Call connect() before executing queries")
}

F err_client_not_in_transaction() -> VaisError {
    VaisError.new(
        "VAIS-0701005",
        "Not in transaction"
    ).with_hint("Call begin() first")
}

F err_client_already_in_transaction() -> VaisError {
    VaisError.new(
        "VAIS-0701006",
        "Already in transaction"
    ).with_hint("Commit or rollback current transaction first")
}

F err_client_prepared_not_found(name: Str) -> VaisError {
    VaisError.new(
        "VAIS-0701007",
        "Prepared statement not found: '{name}'"
    ).with_hint("Call prepare() first")
}
