# VaisDB Native Client
# Connection management, query execution, prepared statements, transaction control
# FUTURE(std/net): Implement TCP networking

U std/vec.Vec;
U std/string.Str;
U std/option.{Option, Some, None};
U std/hashmap.HashMap;
U storage/error.VaisError;
U client/types.{
    ClientConfig, ClientResult, ClientState,
    err_client_not_connected, err_client_not_in_transaction,
    err_client_already_in_transaction, err_client_prepared_not_found,
};

# ============================================================================
# VaisClient
# ============================================================================

S VaisClient {
    config: ClientConfig,
    state: ClientState,
    # FUTURE(std/net): TCP socket handle
    prepared_statements: HashMap<Str, Str>,  # name -> SQL
}

X VaisClient {
    F new(config: ClientConfig) -> VaisClient {
        VaisClient {
            config,
            state: ClientState.Disconnected,
            prepared_statements: HashMap.new(),
        }
    }

    # Connect to VaisDB server
    # FUTURE(std/net): Implement TCP connection, startup handshake, authentication
    F connect(~self) -> Result<(), VaisError> {
        I self.is_connected() {
            R Ok(());
        }

        # Placeholder: transition state without actual TCP connection
        self.state = ClientState.Connected;
        Ok(())
    }

    # Close connection
    # FUTURE(std/net): Send Terminate message before closing
    F close(~self) {
        self.state = ClientState.Disconnected;
        self.prepared_statements.clear();
    }

    F is_connected(self) -> bool {
        M &self.state {
            ClientState.Disconnected => false,
            ClientState.Connected => true,
            ClientState.InTransaction => true,
        }
    }

    # Execute query and return result set
    # FUTURE(std/net): Send Query message, receive RowDescription/DataRow/CommandComplete/ReadyForQuery
    F query(~self, sql: &Str) -> Result<ClientResult, VaisError> {
        I !self.is_connected() {
            R Err(err_client_not_connected());
        }

        # Placeholder: return empty result
        Ok(ClientResult.new())
    }

    # Execute DML statement and return affected rows
    # FUTURE(std/net): Send Query message, receive CommandComplete with row count
    F execute(~self, sql: &Str) -> Result<u64, VaisError> {
        I !self.is_connected() {
            R Err(err_client_not_connected());
        }

        # Placeholder: return 0 affected rows
        Ok(0)
    }

    # Prepare a named statement
    F prepare(~self, name: &Str, sql: &Str) -> Result<(), VaisError> {
        I !self.is_connected() {
            R Err(err_client_not_connected());
        }

        # FUTURE(std/net): Send Parse/Describe/Sync, receive ParseComplete/ParameterDescription/RowDescription
        self.prepared_statements.insert(name.clone(), sql.clone());
        Ok(())
    }

    # Execute prepared statement with parameters
    # FUTURE(std/net): Send Bind/Execute/Sync, receive BindComplete/DataRow/CommandComplete/ReadyForQuery
    F execute_prepared(~self, name: &Str, params: &Vec<Vec<u8>>) -> Result<ClientResult, VaisError> {
        I !self.is_connected() {
            R Err(err_client_not_connected());
        }

        I !self.prepared_statements.contains_key(name) {
            R Err(err_client_prepared_not_found(name.clone()));
        }

        # Placeholder: return empty result
        Ok(ClientResult.new())
    }

    # Begin transaction
    F begin(~self) -> Result<(), VaisError> {
        I !self.is_connected() {
            R Err(err_client_not_connected());
        }

        M &self.state {
            ClientState.InTransaction => {
                R Err(err_client_already_in_transaction());
            },
            _ => {},
        }

        # FUTURE(std/net): Send Query "BEGIN" over wire protocol
        self.state = ClientState.InTransaction;
        Ok(())
    }

    # Commit transaction
    F commit(~self) -> Result<(), VaisError> {
        I !self.is_connected() {
            R Err(err_client_not_connected());
        }

        M &self.state {
            ClientState.InTransaction => {},
            _ => {
                R Err(err_client_not_in_transaction());
            },
        }

        # FUTURE(std/net): Send Query "COMMIT" over wire protocol
        self.state = ClientState.Connected;
        Ok(())
    }

    # Rollback transaction
    F rollback(~self) -> Result<(), VaisError> {
        I !self.is_connected() {
            R Err(err_client_not_connected());
        }

        M &self.state {
            ClientState.InTransaction => {},
            _ => {
                R Err(err_client_not_in_transaction());
            },
        }

        # FUTURE(std/net): Send Query "ROLLBACK" over wire protocol
        self.state = ClientState.Connected;
        Ok(())
    }
}

# Convenience: create client from connection string
F create_client(conn_str: &Str) -> Result<VaisClient, VaisError> {
    ~config = ClientConfig.from_connection_string(conn_str)?;
    Ok(VaisClient.new(config))
}
