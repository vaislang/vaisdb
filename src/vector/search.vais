# search.vais - VECTOR_SEARCH() SQL function executor for VaisDB
# Provides Volcano-style iterator that wraps HNSW MVCC-filtered search

use std/result.{Result, Ok, Err};
use std/option.{Option, Some, None};
use std/vec.Vec;
use std/string.Str;

use crate/error.{VaisError, error_code};
use crate/sql/executor/mod.{ExecContext, ExecutorRow, ExecStats};
use crate/sql/types.{SqlValue, Expr};
use crate/sql/row.Row;
use crate/hnsw/search.{knn_search, SearchResult, SearchResultEntry};
use crate/hnsw/delete.{mvcc_filtered_search, MvccSearchResult};
use crate/hnsw/meta.HnswMeta;
use crate/hnsw/distance.{DistanceComputer, create_distance_computer};
use crate/storage/buffer_pool.BufferPool;
use crate/sql/catalog/manager.CatalogManager;

# Error codes: EE=02 (vector), CC=03 (search)
# 02-03-007: Invalid VECTOR_SEARCH arguments
# 02-03-008: Vector dimension mismatch
# 02-03-009: Search execution failed

# VectorSearchParams: parsed parameters from SQL VECTOR_SEARCH() call
S VectorSearchParams {
    table_name: Str,
    column_name: Str,       # VECTOR column to search
    query_vector: Vec<f32>, # Query embedding
    top_k: usize,           # Number of results to return
    ef_search: Option<u32>, # Optional ef_search override
    index_id: u32,          # Resolved from catalog (set during open())
    table_id: u32,          # Resolved table ID
}

# VectorSearchRow: materialized result row with distance and original data
S VectorSearchRow {
    node_id: u64,
    distance: f32,
    row: Row,  # Original row data from table
}

# VectorSearchExecutor: Volcano-style iterator for VECTOR_SEARCH()
S VectorSearchExecutor {
    params: VectorSearchParams,
    results: Option<Vec<VectorSearchRow>>,
    cursor: usize,
    stats: ExecStats,
    ctx: &ExecContext,
}

I VectorSearchExecutor {
    # Create new executor with parsed parameters
    F new(params: VectorSearchParams, ctx: &ExecContext) -> VectorSearchExecutor {
        VectorSearchExecutor {
            params: params,
            results: None,
            cursor: 0,
            stats: ExecStats::new(),
            ctx: ctx,
        }
    }

    # Open: resolve index, execute MVCC-filtered search, materialize results
    F open(~self) -> Result<(), VaisError> {
        # 1. Resolve table and column from catalog
        let table_meta = self.ctx.catalog.get_table(&self.params.table_name)
            .ok_or(error_code(2, 3, 7, "Table not found for VECTOR_SEARCH"))?;

        self.params.table_id = table_meta.table_id;

        # 2. Find VECTOR column and its index
        let ~column_found = false;
        let ~vector_index_id = 0u32;
        let ~column_idx = 0usize;

        for col in table_meta.columns.iter() {
            M col.col_type {
                SqlValue::VectorVal { .. } => {
                    if col.name == self.params.column_name {
                        column_found = true;
                        column_idx = col.column_id as usize;
                        # Find associated HNSW index
                        let index_meta = self.ctx.catalog.get_vector_index(
                            self.params.table_id,
                            col.column_id
                        ).ok_or(error_code(2, 3, 7, "No HNSW index found for column"))?;
                        vector_index_id = index_meta.index_id;
                        break;
                    }
                },
                _ => {}
            }
        }

        if !column_found {
            return Err(error_code(2, 3, 7, "VECTOR column not found"));
        }

        self.params.index_id = vector_index_id;

        # 3. Load HNSW metadata and verify dimension
        let index_meta = self.ctx.catalog.get_hnsw_metadata(vector_index_id)
            .ok_or(error_code(2, 3, 7, "HNSW metadata not found"))?;

        if self.params.query_vector.len() != index_meta.dimension as usize {
            return Err(error_code(2, 3, 8, "Query vector dimension mismatch"));
        }

        # 4. Create distance computer from index config
        let distance_computer = create_distance_computer(
            &index_meta.metric_type,
            index_meta.dimension
        )?;

        # 5. Determine ef_search value (use override or default)
        let ef_search = M self.params.ef_search {
            Some(ef) => ef,
            None => index_meta.ef_construction * 2,  # Default heuristic
        };

        # 6. Get node store from buffer pool
        let node_store = self.ctx.pool.get_hnsw_node_store(vector_index_id)?;

        # 7. Execute MVCC-filtered search
        let search_result = mvcc_filtered_search(
            &self.params.query_vector,
            self.params.top_k,
            ef_search,
            &index_meta,
            node_store,
            &distance_computer,
            &self.ctx.snapshot,
            self.ctx.catalog.get_clog(),
        ).map_err(|e| error_code(2, 3, 9, "MVCC search failed"))?;

        self.stats.add_scanned(search_result.total_candidates);

        # 8. Materialize results by loading original rows
        let ~materialized = Vec::with_capacity(search_result.results.len());

        for entry in search_result.results.iter() {
            # Load original row from table using node_id as TID
            let row = self.load_row_by_node_id(entry.node_id)?;

            materialized.push(VectorSearchRow {
                node_id: entry.node_id,
                distance: entry.distance,
                row: row,
            });

            self.stats.add_produced();
        }

        self.results = Some(materialized);
        self.cursor = 0;

        Ok(())
    }

    # Next: return next result row as ExecutorRow
    F next(~self) -> Result<Option<ExecutorRow>, VaisError> {
        M &self.results {
            None => Err(error_code(2, 3, 9, "VectorSearchExecutor not opened")),
            Some(results) => {
                if self.cursor >= results.len() {
                    return Ok(None);
                }

                let result_row = &results[self.cursor];
                self.cursor += 1;

                # Build output row: (distance, ...original_columns)
                let ~output_row = Row::new();

                # First column: distance
                output_row.add_column(SqlValue::FloatVal { v: result_row.distance as f64 });

                # Append all original columns
                for i in 0..result_row.row.column_count() {
                    output_row.add_column(result_row.row.get(i).clone());
                }

                # Return as virtual ExecutorRow (no physical TID)
                Ok(Some(ExecutorRow::virtual(output_row)))
            }
        }
    }

    # Close: release resources
    F close(~self) -> Result<(), VaisError> {
        self.results = None;
        self.cursor = 0;
        Ok(())
    }

    # Stats: return execution statistics
    F stats(self) -> &ExecStats {
        &self.stats
    }

    # Helper: load row by node_id (maps to physical TID)
    F load_row_by_node_id(self, node_id: u64) -> Result<Row, VaisError> {
        # node_id encoding: high 24 bits = page_id, low 16 bits = slot_id
        let page_id = (node_id >> 16) as u32;
        let slot_id = (node_id & 0xFFFF) as u16;

        # Get table file_id from catalog
        let table_meta = self.ctx.catalog.get_table_by_id(self.params.table_id)
            .ok_or(error_code(2, 3, 9, "Table metadata not found"))?;

        let file_id = table_meta.file_id;

        # Read page from buffer pool
        let page = self.ctx.pool.fetch_page(file_id, page_id)?;
        let page_guard = page.read();

        # Parse heap page and extract slot
        let heap_page = HeapPage::from_bytes(page_guard.data())?;
        let tuple_data = heap_page.get_slot(slot_id)
            .ok_or(error_code(2, 3, 9, "Slot not found in heap page"))?;

        # Deserialize row
        let row = Row::deserialize(tuple_data, &table_meta.columns)?;

        # Check MVCC visibility
        let mvcc_tuple = heap_page.get_mvcc_tuple(slot_id)
            .ok_or(error_code(2, 3, 9, "MVCC tuple not found"))?;

        if !is_visible(
            mvcc_tuple,
            self.ctx.txn_id,
            0,  # cmd_id (not used for read-only search)
            &self.ctx.snapshot,
            self.ctx.catalog.get_clog()
        ) {
            return Err(error_code(2, 3, 9, "Row not visible to snapshot"));
        }

        Ok(row)
    }
}

# parse_vector_search_args: parse VECTOR_SEARCH(column, query_vector, top_k, [ef_search])
# Expected signature:
#   VECTOR_SEARCH(table.column, ARRAY[0.1, 0.2, ...], 10)
#   VECTOR_SEARCH(table.column, ARRAY[0.1, 0.2, ...], 10, 200)  -- with ef_search
F parse_vector_search_args(
    args: &[Expr],
    ctx: &ExecContext
) -> Result<VectorSearchParams, VaisError> {
    if args.len() < 3 || args.len() > 4 {
        return Err(error_code(2, 3, 7, "VECTOR_SEARCH requires 3 or 4 arguments"));
    }

    # Argument 1: table.column reference
    let (table_name, column_name) = M &args[0] {
        Expr::ColumnRef { table, column } => {
            (table.clone(), column.clone())
        },
        _ => return Err(error_code(2, 3, 7, "First arg must be column reference"))
    };

    # Argument 2: query vector (ARRAY[...] or vector literal)
    let query_vector = M &args[1] {
        Expr::ArrayLiteral { elements } => {
            let ~vec = Vec::with_capacity(elements.len());
            for elem in elements.iter() {
                M elem {
                    Expr::Literal { value: SqlValue::FloatVal { v } } => {
                        vec.push(*v as f32);
                    },
                    Expr::Literal { value: SqlValue::IntVal { v } } => {
                        vec.push(*v as f32);
                    },
                    _ => return Err(error_code(2, 3, 7, "Array elements must be numeric"))
                }
            }
            vec
        },
        Expr::Literal { value: SqlValue::VectorVal { v } } => v.clone(),
        _ => return Err(error_code(2, 3, 7, "Second arg must be vector"))
    };

    # Argument 3: top_k
    let top_k = M &args[2] {
        Expr::Literal { value: SqlValue::IntVal { v } } => {
            if *v <= 0 {
                return Err(error_code(2, 3, 7, "top_k must be positive"));
            }
            *v as usize
        },
        _ => return Err(error_code(2, 3, 7, "Third arg must be integer"))
    };

    # Argument 4: ef_search (optional)
    let ef_search = if args.len() == 4 {
        M &args[3] {
            Expr::Literal { value: SqlValue::IntVal { v } } => {
                if *v <= 0 {
                    return Err(error_code(2, 3, 7, "ef_search must be positive"));
                }
                Some(*v as u32)
            },
            _ => return Err(error_code(2, 3, 7, "Fourth arg must be integer"))
        }
    } else {
        None
    };

    Ok(VectorSearchParams {
        table_name: table_name,
        column_name: column_name,
        query_vector: query_vector,
        top_k: top_k,
        ef_search: ef_search,
        index_id: 0,  # Resolved during open()
        table_id: 0,  # Resolved during open()
    })
}

# execute_vector_search: standalone helper for direct execution
# (Used when VECTOR_SEARCH is called outside Volcano iterator context)
F execute_vector_search(
    params: &VectorSearchParams,
    ctx: &ExecContext
) -> Result<Vec<VectorSearchRow>, VaisError> {
    let ~executor = VectorSearchExecutor::new(params.clone(), ctx);
    executor.open()?;

    let ~results = Vec::new();
    L {
        M executor.next()? {
            Some(exec_row) => {
                # Extract VectorSearchRow from ExecutorRow
                # (This path is simplified - normally we'd convert back)
                # For standalone execution, we access internal results directly
                break;
            },
            None => break
        }
    }

    M executor.results {
        Some(materialized) => Ok(materialized),
        None => Ok(Vec::new())
    }
}

# Helper imports for row loading (would be in actual implementation)
use crate/storage/heap_page.HeapPage;
use crate/sql/visibility.is_visible;

# VectorSearchBuilder: fluent API for constructing searches
S VectorSearchBuilder {
    table: Option<Str>,
    column: Option<Str>,
    query: Option<Vec<f32>>,
    k: Option<usize>,
    ef: Option<u32>,
}

I VectorSearchBuilder {
    F new() -> VectorSearchBuilder {
        VectorSearchBuilder {
            table: None,
            column: None,
            query: None,
            k: None,
            ef: None,
        }
    }

    F table(~self, name: Str) -> ~VectorSearchBuilder {
        self.table = Some(name);
        self
    }

    F column(~self, name: Str) -> ~VectorSearchBuilder {
        self.column = Some(name);
        self
    }

    F query(~self, vec: Vec<f32>) -> ~VectorSearchBuilder {
        self.query = Some(vec);
        self
    }

    F top_k(~self, k: usize) -> ~VectorSearchBuilder {
        self.k = Some(k);
        self
    }

    F ef_search(~self, ef: u32) -> ~VectorSearchBuilder {
        self.ef = Some(ef);
        self
    }

    F build(self) -> Result<VectorSearchParams, VaisError> {
        Ok(VectorSearchParams {
            table_name: self.table.ok_or(error_code(2, 3, 7, "Missing table"))?,
            column_name: self.column.ok_or(error_code(2, 3, 7, "Missing column"))?,
            query_vector: self.query.ok_or(error_code(2, 3, 7, "Missing query vector"))?,
            top_k: self.k.ok_or(error_code(2, 3, 7, "Missing top_k"))?,
            ef_search: self.ef,
            index_id: 0,
            table_id: 0,
        })
    }
}

# Export public API
pub use {
    VectorSearchParams,
    VectorSearchRow,
    VectorSearchExecutor,
    VectorSearchBuilder,
    parse_vector_search_args,
    execute_vector_search,
};
