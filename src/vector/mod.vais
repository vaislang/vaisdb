# Vector Engine
# HNSW index, quantization, similarity search
# Entry point and high-level facade for vector operations

# ============================================================================
# Module exports
# ============================================================================

# Distance metrics
pub mod distance;
pub use distance.{DistanceMetric, DistanceComputer};

# Vector storage
pub mod storage;
pub use storage.{VectorStore, VectorPage, VectorPageHeader};

# Search functionality
pub mod search;
pub use search.{VectorSearchExecutor, VectorSearchParams, VectorSearchRow};

# Filtered search
pub mod filter;
pub use filter.{FilteredVectorSearch, FilterStrategy, FilterConfig};

# Concurrency control
pub mod concurrency;
pub use concurrency.{ConcurrentHnswIndex, HnswLock, HnswReadGuard, HnswWriteGuard};

# HNSW submodules
pub mod hnsw;
pub use hnsw/types.{
    HnswConfig, HnswMeta, HnswNode, HnswNeighbor, SearchCandidate, LayerRng,
    INVALID_NODE_ID, DISTANCE_COSINE, DISTANCE_L2, DISTANCE_DOT_PRODUCT,
    DEFAULT_M, DEFAULT_M_MAX_0, DEFAULT_EF_CONSTRUCTION, DEFAULT_EF_SEARCH,
};
pub use hnsw/insert.{hnsw_insert, NodeStore};
pub use hnsw/search.{knn_search, SearchResult, SearchResultEntry};
pub use hnsw/delete.{hnsw_delete, mvcc_filtered_search, is_vector_visible, is_gc_ready};
pub use hnsw/layer.{LayerManager, PinnedLayer};
pub use hnsw/wal.{HnswWalManager};
pub use hnsw/cow.{CowNeighborStore, EpochManager, CowNeighborList};
pub use hnsw/bulk.{BulkLoader, BulkLoadConfig, BulkLoadResult};

# Quantization
pub mod quantize;
pub use quantize/mod.{QuantizationManager, QuantizationStrategy};

# Dependencies
use std/option.{Option, Some, None};
use std/vec.Vec;
use std/string.Str;
use storage/error.{VaisError, ErrorSeverity};
use storage/buffer/pool.{BufferPool};
use storage/page/allocator.{PageAllocator};
use storage/wal/group_commit.{GroupCommitManager};
use storage/txn/snapshot.{Snapshot};
use storage/constants.{FILE_ID_VECTORS, PAGE_TYPE_HNSW_META, NULL_PAGE};
use sql/catalog/manager.{CatalogManager};
use sql/catalog/schema.{IndexInfo, INDEX_TYPE_HNSW};
use sql/types.{Expr};
use sql/executor/mod.{ExecContext};

# ============================================================================
# Error Codes: EE=02 (vector), CC=10 (module), NNN=001-003
# ============================================================================

F err_vector_engine_closed() -> VaisError {
    VaisError.new(
        "VAIS-0210001",
        "Vector engine is not open"
    )
}

F err_vector_dim_mismatch(expected: u32, actual: u32) -> VaisError {
    VaisError.new(
        "VAIS-0210002",
        "Vector dimension mismatch: expected {expected}, got {actual}"
    )
}

F err_vector_index_creation_failed(detail: Str) -> VaisError {
    VaisError.new(
        "VAIS-0210003",
        "Failed to create vector index: {detail}"
    )
}

# ============================================================================
# VectorEngine — High-level facade for all vector operations
# ============================================================================

# VectorEngine manages a single HNSW index instance
# Integrates: storage, HNSW graph, quantization, WAL, concurrency, layers
S VectorEngine {
    config: HnswConfig,              # HNSW configuration (M, ef_construction, etc.)
    meta: HnswMeta,                  # Metadata (entry_point, max_layer, node_count)
    store: VectorStore,              # Raw vector data storage
    layer_mgr: LayerManager,         # Upper layer (1+) pinning manager
    wal_mgr: HnswWalManager,         # WAL logging for HNSW operations
    cow_store: CowNeighborStore,     # Copy-on-write neighbor lists (epoch-based)
    quantization: QuantizationManager, # Quantization (scalar/PQ)
    lock: HnswLock,                  # Concurrency control (RwLock)
    index_id: u32,                   # Catalog index ID
    is_open: bool,                   # Engine open state
    pool: &BufferPool,               # Shared buffer pool
    allocator: &PageAllocator,       # Shared page allocator
    gcm: &GroupCommitManager,        # Shared group commit manager
}

I VectorEngine {
    # ========================================================================
    # Constructor — Create new vector engine instance
    # ========================================================================

    # Create new VectorEngine instance (does not load from disk)
    # Call open() to load metadata and upper layers
    F new(
        config: HnswConfig,
        index_id: u32,
        pool: &BufferPool,
        allocator: &PageAllocator,
        gcm: &GroupCommitManager,
    ) -> Result<VectorEngine, VaisError> {
        # Validate configuration
        if config.m == 0 || config.m_max_0 == 0 {
            return Err(err_hnsw_invalid_config("M and M_max_0 must be > 0"));
        }
        if config.ef_construction < config.m {
            return Err(err_hnsw_invalid_config("ef_construction must be >= M"));
        }
        if config.dim == 0 {
            return Err(err_hnsw_invalid_config("dimension must be > 0"));
        }

        # Initialize metadata (empty index)
        let meta = HnswMeta.new(config.dim, config.metric);

        # Initialize components
        let store = VectorStore.new(pool, allocator, FILE_ID_VECTORS)?;
        let layer_mgr = LayerManager.new(pool, allocator)?;
        let wal_mgr = HnswWalManager.new(gcm)?;
        let cow_store = CowNeighborStore.new()?;
        let quantization = QuantizationManager.new(config.quantization_strategy)?;
        let lock = HnswLock.new();

        Ok(VectorEngine {
            config,
            meta,
            store,
            layer_mgr,
            wal_mgr,
            cow_store,
            quantization,
            lock,
            index_id,
            is_open: false,
            pool,
            allocator,
            gcm,
        })
    }

    # ========================================================================
    # Lifecycle — Open/Close
    # ========================================================================

    # Open engine: load meta page and upper layers from disk
    F open(~self) -> Result<(), VaisError> {
        if self.is_open {
            return Ok(());
        }

        # Load metadata page
        let meta_page_id = self.index_id;  # Meta page is first page of index
        let meta_data = self.pool.read_page(FILE_ID_VECTORS, meta_page_id)?;
        self.meta = HnswMeta.deserialize(&meta_data)?;

        # Validate meta matches config
        if self.meta.dim != self.config.dim {
            return Err(err_vector_dim_mismatch(self.config.dim, self.meta.dim));
        }

        # Load upper layers (layer 1+) into memory
        for layer in 1..(self.meta.max_layer + 1) {
            self.layer_mgr.pin_layer(layer, &self.meta, self.pool)?;
        }

        # Initialize quantization with stored vectors
        self.quantization.initialize(&self.store)?;

        self.is_open = true;
        Ok(())
    }

    # Close engine: flush dirty pages, release resources
    F close(~self) -> Result<(), VaisError> {
        if !self.is_open {
            return Ok(());
        }

        # Flush metadata page
        let ~meta_buf = ByteBuffer.new();
        self.meta.serialize(&~meta_buf)?;
        self.pool.write_page(FILE_ID_VECTORS, self.index_id, &meta_buf.to_vec())?;

        # Unpin all upper layers
        for layer in 1..(self.meta.max_layer + 1) {
            self.layer_mgr.unpin_layer(layer)?;
        }

        # Flush all dirty pages
        self.pool.flush_file(FILE_ID_VECTORS)?;

        self.is_open = false;
        Ok(())
    }

    # ========================================================================
    # Index Management — Create/Drop
    # ========================================================================

    # Create new HNSW index: allocate meta page, register in catalog
    F create_index(
        config: HnswConfig,
        catalog: &~CatalogManager,
        pool: &BufferPool,
        allocator: &PageAllocator,
        gcm: &GroupCommitManager,
        txn_id: u64,
        index_name: Str,
        table_id: u32,
        column_id: u32,
    ) -> Result<VectorEngine, VaisError> {
        # Allocate metadata page
        let meta_page_id = allocator.allocate_page(FILE_ID_VECTORS)?;

        # Register index in catalog
        let index_info = IndexInfo {
            index_id: meta_page_id,
            index_name: index_name.clone(),
            table_id,
            column_ids: vec![column_id],
            index_type: INDEX_TYPE_HNSW,
            is_unique: false,
            is_primary: false,
            root_page: meta_page_id,
        };
        catalog.create_index(index_info, txn_id)?;

        # Create engine instance
        let ~engine = VectorEngine.new(config, meta_page_id, pool, allocator, gcm)?;

        # Initialize metadata page
        let ~meta_buf = ByteBuffer.new();
        engine.meta.serialize(&~meta_buf)?;
        pool.write_page(FILE_ID_VECTORS, meta_page_id, &meta_buf.to_vec())?;

        # WAL-log index creation
        engine.wal_mgr.log_index_created(
            meta_page_id,
            config.dim,
            config.metric,
            txn_id,
        )?;

        # Mark as open
        engine.is_open = true;

        Ok(engine)
    }

    # Drop index: mark as deleted, release pages
    F drop_index(~self, catalog: &~CatalogManager, txn_id: u64) -> Result<(), VaisError> {
        if !self.is_open {
            return Err(err_vector_engine_closed());
        }

        # WAL-log drop operation
        self.wal_mgr.log_index_dropped(self.index_id, txn_id)?;

        # Remove from catalog
        catalog.drop_index(self.index_id, txn_id)?;

        # Release all pages (meta + vector pages + layer pages)
        # Meta page
        self.allocator.free_page(FILE_ID_VECTORS, self.index_id)?;

        # Vector pages
        for page_id in self.store.get_all_page_ids() {
            self.allocator.free_page(FILE_ID_VECTORS, page_id)?;
        }

        # Layer pages
        for layer in 1..(self.meta.max_layer + 1) {
            let layer_page_ids = self.layer_mgr.get_page_ids_for_layer(layer)?;
            for page_id in layer_page_ids {
                self.allocator.free_page(FILE_ID_VECTORS, page_id)?;
            }
        }

        # Close engine
        self.close()?;

        Ok(())
    }

    # ========================================================================
    # Vector Operations — Insert/Delete
    # ========================================================================

    # Insert vector: write to storage → insert into HNSW → WAL-log
    # Returns node_id (unique identifier for this vector)
    F insert(
        ~self,
        vector: &[f32],
        txn_id: u64,
        cmd_id: u32,
    ) -> Result<u64, VaisError> {
        if !self.is_open {
            return Err(err_vector_engine_closed());
        }

        # Validate dimension
        if vector.len() != self.config.dim as usize {
            return Err(err_vector_dim_mismatch(
                self.config.dim,
                vector.len() as u32,
            ));
        }

        # Acquire write lock
        let ~write_guard = self.lock.write_lock(txn_id)?;

        # 1. Write vector to storage (allocate page space)
        let node_id = self.store.write_vector(vector, txn_id, cmd_id)?;

        # 2. Insert into HNSW graph
        hnsw_insert(
            node_id,
            vector,
            &~self.meta,
            &self.config,
            &self.store,
            &~self.layer_mgr,
            &~self.cow_store,
            self.pool,
            txn_id,
        )?;

        # 3. WAL-log insert operation
        self.wal_mgr.log_insert(
            self.index_id,
            node_id,
            vector,
            txn_id,
            cmd_id,
        )?;

        # 4. Update meta (increment node count)
        self.meta.total_nodes += 1;

        Ok(node_id)
    }

    # Soft-delete vector: mark as deleted → WAL-log
    # Actual removal happens during GC
    F delete(
        ~self,
        node_id: u64,
        txn_id: u64,
        cmd_id: u32,
    ) -> Result<(), VaisError> {
        if !self.is_open {
            return Err(err_vector_engine_closed());
        }

        # Acquire write lock
        let ~write_guard = self.lock.write_lock(txn_id)?;

        # Soft-delete in storage (set txn_id_expire)
        self.store.delete_vector(node_id, txn_id, cmd_id)?;

        # HNSW delete (remove from neighbor lists)
        hnsw_delete(
            node_id,
            &~self.meta,
            &self.store,
            &~self.layer_mgr,
            &~self.cow_store,
            self.pool,
            txn_id,
        )?;

        # WAL-log delete operation
        self.wal_mgr.log_delete(
            self.index_id,
            node_id,
            txn_id,
            cmd_id,
        )?;

        Ok(())
    }

    # ========================================================================
    # Search Operations
    # ========================================================================

    # MVCC-filtered k-NN search
    # Returns top-k nearest neighbors visible to the snapshot
    F search(
        self,
        query: &[f32],
        k: usize,
        ef_search: Option<u32>,
        snapshot: &Snapshot,
    ) -> Result<SearchResult, VaisError> {
        if !self.is_open {
            return Err(err_vector_engine_closed());
        }

        # Validate dimension
        if query.len() != self.config.dim as usize {
            return Err(err_vector_dim_mismatch(
                self.config.dim,
                query.len() as u32,
            ));
        }

        # Acquire read lock
        let ~read_guard = self.lock.read_lock()?;

        # Use provided ef_search or default
        let ef = M ef_search {
            Some(val) => val,
            None => self.config.ef_search,
        };

        # MVCC-filtered search
        let result = mvcc_filtered_search(
            query,
            k,
            ef,
            &self.meta,
            &self.config,
            &self.store,
            &self.layer_mgr,
            &self.cow_store,
            self.pool,
            snapshot,
        )?;

        Ok(result)
    }

    # Filtered search: combines vector search with SQL WHERE predicate
    # Uses pre/post/hybrid filter strategy
    F filtered_search(
        self,
        query: &[f32],
        k: usize,
        predicate: Option<Expr>,
        ctx: &ExecContext,
    ) -> Result<Vec<VectorSearchRow>, VaisError> {
        if !self.is_open {
            return Err(err_vector_engine_closed());
        }

        # Validate dimension
        if query.len() != self.config.dim as usize {
            return Err(err_vector_dim_mismatch(
                self.config.dim,
                query.len() as u32,
            ));
        }

        # If no predicate, use regular search
        M predicate {
            None => {
                let result = self.search(query, k, None, ctx.snapshot)?;
                # Convert SearchResult to VectorSearchRow
                return self.materialize_search_result(result, ctx);
            },
            Some(expr) => {
                # Use filtered search
                let filter_config = FilterConfig.default();
                let filtered_search = FilteredVectorSearch.new(
                    self,
                    filter_config,
                    ctx,
                )?;
                return filtered_search.execute(query, k, expr);
            },
        }
    }

    # ========================================================================
    # Bulk Loading
    # ========================================================================

    # Bulk load vectors: efficient batch insertion
    # Bypasses WAL if config.bypass_wal = true (requires checkpoint after)
    F bulk_load(
        ~self,
        vectors: &[&[f32]],
        config: BulkLoadConfig,
        txn_id: u64,
    ) -> Result<BulkLoadResult, VaisError> {
        if !self.is_open {
            return Err(err_vector_engine_closed());
        }

        # Validate all vectors have same dimension
        for vec in vectors {
            if vec.len() != self.config.dim as usize {
                return Err(err_vector_dim_mismatch(
                    self.config.dim,
                    vec.len() as u32,
                ));
            }
        }

        # Acquire write lock
        let ~write_guard = self.lock.write_lock(txn_id)?;

        # Create bulk loader
        let ~loader = BulkLoader.new(
            &~self.meta,
            &self.config,
            &~self.store,
            &~self.layer_mgr,
            &~self.cow_store,
            self.pool,
            config,
        )?;

        # Execute bulk load
        let result = loader.load(vectors, txn_id)?;

        # WAL-log bulk load (if not bypassed)
        if !config.bypass_wal {
            self.wal_mgr.log_bulk_load(
                self.index_id,
                vectors,
                txn_id,
            )?;
        }

        Ok(result)
    }

    # ========================================================================
    # Metadata Access
    # ========================================================================

    # Get current metadata (snapshot)
    F get_meta(self) -> &HnswMeta {
        &self.meta
    }

    # Get current node count
    F node_count(self) -> u64 {
        self.meta.total_nodes
    }

    # Check if engine is open
    F is_open(self) -> bool {
        self.is_open
    }

    # ========================================================================
    # Internal Helpers
    # ========================================================================

    # Convert SearchResult to materialized VectorSearchRow
    # Fetches full row data from heap pages
    F materialize_search_result(
        self,
        result: SearchResult,
        ctx: &ExecContext,
    ) -> Result<Vec<VectorSearchRow>, VaisError> {
        let ~rows = Vec.new();

        for entry in result.entries {
            # Fetch original row from heap page
            # node_id maps to TID (table row ID)
            let row = ctx.fetch_row_by_tid(entry.node_id)?;

            rows.push(VectorSearchRow {
                node_id: entry.node_id,
                distance: entry.distance,
                row,
            });
        }

        Ok(rows)
    }
}
