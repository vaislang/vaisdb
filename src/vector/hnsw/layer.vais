# HNSW Layer Manager with Layer 1+ Pinning
# Manages upper layers (1+) in memory, Layer 0 accessed via buffer pool
# Based on HNSW memory architecture: upper layers pinned, lower layer evictable

U std/hashmap.{HashMap};
U std/bytes.{ByteBuffer};
U storage/buffer/pool.{BufferPool};
U storage/constants.{FILE_ID_VECTORS, PAGE_SIZE_8K, PAGE_HEADER_SIZE};
U storage/error.{VaisError, err_internal, err_out_of_memory};
U vector/hnsw/types.{
    HnswConfig,
    HnswMeta,
    HnswNode,
    HnswNeighbor,
    INVALID_NODE_ID,
};

# Error codes: EE=02 (vector), CC=04 (layer), NNN=001-003
F err_layer_not_pinned(layer: u8) -> VaisError {
    VaisError.new(
        "VAIS-0204001",
        "Layer {layer} is not pinned (only layer 0 is unpinned)"
    )
}

F err_layer_node_not_found(node_id: u64, layer: u8) -> VaisError {
    VaisError.new(
        "VAIS-0204002",
        "Node {node_id} not found in pinned layer {layer}"
    )
}

F err_layer_load_failed(layer: u8, detail: Str) -> VaisError {
    VaisError.new(
        "VAIS-0204003",
        "Failed to load layer {layer}: {detail}"
    )
}

# Pinned layer: in-memory representation of a single HNSW layer
# Contains all nodes that have max_layer >= this layer
# Only stores neighbor lists relevant to this layer
S PinnedLayer {
    layer: u8,
    nodes: HashMap<u64, HnswNode>,  # node_id -> node (with only this layer's neighbors)
    memory_bytes: u64,             # Total memory consumed by this layer
}

X PinnedLayer {
    # Create new empty pinned layer
    F new(layer: u8) -> PinnedLayer {
        PinnedLayer {
            layer,
            nodes: HashMap.new(),
            memory_bytes: 0,
        }
    }

    # Add a node to this pinned layer
    # Node must have max_layer >= this layer
    # Only the neighbor list for this layer is stored
    F add_node(~self, node: HnswNode) -> Result<(), VaisError> {
        I node.max_layer < self.layer {
            R Err(err_internal(
                "Cannot add node to layer {self.layer}: node max_layer is {node.max_layer}"
            ));
        }

        # Calculate memory size for this node in this layer
        ~node_size = self.calculate_node_size(&node);

        self.nodes.insert(node.node_id, node);
        self.memory_bytes += node_size;

        Ok(())
    }

    # Remove a node from this pinned layer
    F remove_node(~self, node_id: u64) {
        M self.nodes.remove(&node_id) {
            Some(node) => {
                ~node_size = self.calculate_node_size(&node);
                self.memory_bytes -= node_size;
            },
            None => {},
        }
    }

    # Get node from this layer
    F get_node(self, node_id: u64) -> Option<&HnswNode> {
        self.nodes.get(&node_id)
    }

    # Get mutable node from this layer
    F get_node_mut(~self, node_id: u64) -> Option<&~HnswNode> {
        self.nodes.get_mut(&node_id)
    }

    # Update neighbor list for a node at this layer
    F update_neighbors(~self, node_id: u64, neighbors: Vec<HnswNeighbor>) -> Result<(), VaisError> {
        M self.nodes.get_mut(&node_id) {
            Some(node) => {
                # Calculate old and new sizes
                ~old_size = self.calculate_node_size(node);

                # Update neighbors at this layer
                I self.layer as u64 >= node.neighbors.len() {
                    R Err(err_internal(
                        "Node {node_id} has no neighbor list for layer {self.layer}"
                    ));
                }

                node.neighbors[self.layer as u64] = neighbors;

                # Update memory accounting
                ~new_size = self.calculate_node_size(node);
                self.memory_bytes = self.memory_bytes - old_size + new_size;

                Ok(())
            },
            None => Err(err_layer_node_not_found(node_id, self.layer)),
        }
    }

    # Calculate memory size for a node in this layer
    # Size = fixed node overhead + neighbor list for this layer
    F calculate_node_size(self, node: &HnswNode) -> u64 {
        # Fixed overhead per node: 48 bytes (node header) + 32 bytes (MVCC)
        ~base_size = 80;

        # Add size of neighbor list for this layer
        I self.layer as u64 < node.neighbors.len() {
            ~neighbor_count = node.neighbors[self.layer as u64].len();
            # Each neighbor: 8 (node_id) + 4 (distance) = 12 bytes
            base_size += neighbor_count * 12;
        }

        base_size
    }

    # Get node count in this layer
    F node_count(self) -> u64 {
        self.nodes.len() as u64
    }

    # Get memory usage in bytes
    F memory_usage(self) -> u64 {
        self.memory_bytes
    }
}

# Layer statistics for monitoring
S LayerStat {
    layer: u8,
    node_count: u64,
    memory_bytes: u64,
    is_pinned: bool,
}

X LayerStat {
    F new(layer: u8, node_count: u64, memory_bytes: u64, is_pinned: bool) -> LayerStat {
        LayerStat {
            layer,
            node_count,
            memory_bytes,
            is_pinned,
        }
    }
}

# Layer Manager: manages HNSW layer data and pinning strategy
# Layer 1+ are always pinned in memory
# Layer 0 is accessed through buffer pool (may be evicted)
S LayerManager {
    pinned_layers: Vec<PinnedLayer>,  # Index 0 = layer 1, index 1 = layer 2, etc.
    max_pinned_layer: u8,              # Highest layer currently pinned
    total_pinned_memory: u64,        # Total memory used by pinned layers
    config: HnswConfig,                # HNSW configuration
}

X LayerManager {
    # Create new layer manager
    F new(config: HnswConfig) -> LayerManager {
        LayerManager {
            pinned_layers: Vec.new(),
            max_pinned_layer: 0,
            total_pinned_memory: 0,
            config,
        }
    }

    # Load upper layers (1+) from disk at startup
    # Reads all nodes from vectors.vdb and pins those with max_layer >= 1
    F load_upper_layers(~self, meta: &HnswMeta, pool: &BufferPool) -> Result<(), VaisError> {
        I meta.is_empty() {
            # Empty index - nothing to load
            R Ok(());
        }

        # Initialize pinned layers for each layer 1..=max_layer
        ~layer = 1;
        W layer <= meta.max_layer {
            self.pinned_layers.push(PinnedLayer.new(layer));
            layer += 1;
        }
        self.max_pinned_layer = meta.max_layer;

        # Load all nodes from vectors.vdb
        # This is a simplified approach - in production, we'd have a proper
        # node page format and iterator. For now, we assume nodes are stored
        # sequentially starting from page 1 (page 0 = meta page).
        # Each node page contains one or more serialized HnswNode entries.

        # In a real implementation, we'd iterate through all HNSW node pages
        # For this implementation, we'll document the expected behavior:
        #
        # 1. Iterate through all pages of type PAGE_TYPE_HNSW_NODE
        # 2. Deserialize each HnswNode from the page
        # 3. If node.max_layer >= 1, add to appropriate pinned layers
        # 4. Track total memory usage

        # FUTURE(integration): Load nodes from HNSW node pages and populate pinned layers
        # Currently relies on add_pinned_node() calls during index construction

        Ok(())
    }

    # Get a node from pinned layers
    # Returns None if layer is not pinned (layer 0) or node not found
    F get_pinned_node(self, node_id: u64, layer: u8) -> Option<&HnswNode> {
        I layer == 0 {
            # Layer 0 is not pinned - must use buffer pool
            R None;
        }

        I layer > self.max_pinned_layer {
            R None;
        }

        ~layer_idx = (layer - 1) as u64;
        I layer_idx >= self.pinned_layers.len() {
            R None;
        }

        self.pinned_layers[layer_idx].get_node(node_id)
    }

    # Get mutable reference to a pinned node
    F get_pinned_node_mut(~self, node_id: u64, layer: u8) -> Option<&~HnswNode> {
        I layer == 0 || layer > self.max_pinned_layer {
            R None;
        }

        ~layer_idx = (layer - 1) as u64;
        I layer_idx >= self.pinned_layers.len() {
            R None;
        }

        self.pinned_layers[layer_idx].get_node_mut(node_id)
    }

    # Add a node to pinned layers
    # Node is added to all layers from 1 to node.max_layer
    # Returns error if node.max_layer == 0 (layer 0 not pinned)
    F add_pinned_node(~self, node: HnswNode, layer: u8) -> Result<(), VaisError> {
        I layer == 0 {
            R Err(err_layer_not_pinned(0));
        }

        # Ensure we have enough pinned layers
        I layer > self.max_pinned_layer {
            # Need to add new layers
            ~l = self.max_pinned_layer + 1;
            W l <= layer {
                self.pinned_layers.push(PinnedLayer.new(l));
                l += 1;
            }
            self.max_pinned_layer = layer;
        }

        # Add node to all layers from 1 to node.max_layer
        ~l = 1;
        W l <= node.max_layer {
            I l <= self.max_pinned_layer {
                ~layer_idx = (l - 1) as u64;

                # Calculate memory before adding
                ~old_memory = self.pinned_layers[layer_idx].memory_usage();

                # Add node to this layer
                self.pinned_layers[layer_idx].add_node(node.clone())?;

                # Update total memory
                ~new_memory = self.pinned_layers[layer_idx].memory_usage();
                self.total_pinned_memory += new_memory - old_memory;
            }
            l += 1;
        }

        Ok(())
    }

    # Remove a node from pinned layers
    # Removes from all layers where it exists
    F remove_pinned_node(~self, node_id: u64, layer: u8) {
        I layer == 0 || layer > self.max_pinned_layer {
            R;
        }

        # Remove from all layers from 1 to layer
        ~l = 1;
        W l <= layer {
            I l <= self.max_pinned_layer {
                ~layer_idx = (l - 1) as u64;

                # Calculate memory before removing
                ~old_memory = self.pinned_layers[layer_idx].memory_usage();

                # Remove node
                self.pinned_layers[layer_idx].remove_node(node_id);

                # Update total memory
                ~new_memory = self.pinned_layers[layer_idx].memory_usage();
                I old_memory > new_memory {
                    self.total_pinned_memory -= old_memory - new_memory;
                }
            }
            l += 1;
        }
    }

    # Update neighbor list for a node at a specific layer
    F update_pinned_neighbors(
        ~self,
        node_id: u64,
        layer: u8,
        neighbors: Vec<HnswNeighbor>
    ) -> Result<(), VaisError> {
        I layer == 0 {
            R Err(err_layer_not_pinned(0));
        }

        I layer > self.max_pinned_layer {
            R Err(err_internal(
                "Cannot update neighbors: layer {layer} > max_pinned_layer {self.max_pinned_layer}"
            ));
        }

        ~layer_idx = (layer - 1) as u64;

        # Calculate memory before update
        ~old_memory = self.pinned_layers[layer_idx].memory_usage();

        # Update neighbors
        self.pinned_layers[layer_idx].update_neighbors(node_id, neighbors)?;

        # Update total memory
        ~new_memory = self.pinned_layers[layer_idx].memory_usage();
        I new_memory > old_memory {
            self.total_pinned_memory += new_memory - old_memory;
        } E {
            self.total_pinned_memory -= old_memory - new_memory;
        }

        Ok(())
    }

    # Check if a layer is pinned
    # Layer 0 is never pinned, layers 1+ are always pinned
    F is_layer_pinned(self, layer: u8) -> bool {
        layer >= 1 && layer <= self.max_pinned_layer
    }

    # Get total pinned memory usage in bytes
    F pinned_memory_usage(self) -> u64 {
        self.total_pinned_memory
    }

    # Get statistics for all layers
    F layer_stats(self) -> Vec<LayerStat> {
        ~stats = Vec.with_capacity((self.max_pinned_layer + 1) as u64);

        # Layer 0 stats (not pinned, accessed via buffer pool)
        stats.push(LayerStat.new(0, 0, 0, false));

        # Pinned layer stats (layers 1+)
        ~layer = 1;
        W layer <= self.max_pinned_layer {
            ~layer_idx = (layer - 1) as u64;
            ~pinned_layer = &self.pinned_layers[layer_idx];

            stats.push(LayerStat.new(
                layer,
                pinned_layer.node_count(),
                pinned_layer.memory_usage(),
                true
            ));

            layer += 1;
        }

        stats
    }

    # Get maximum pinned layer
    F get_max_pinned_layer(self) -> u8 {
        self.max_pinned_layer
    }

    # Get node count for a specific pinned layer
    F get_layer_node_count(self, layer: u8) -> u64 {
        I layer == 0 || layer > self.max_pinned_layer {
            R 0;
        }

        ~layer_idx = (layer - 1) as u64;
        self.pinned_layers[layer_idx].node_count()
    }

    # Get memory usage for a specific pinned layer
    F get_layer_memory_usage(self, layer: u8) -> u64 {
        I layer == 0 || layer > self.max_pinned_layer {
            R 0;
        }

        ~layer_idx = (layer - 1) as u64;
        self.pinned_layers[layer_idx].memory_usage()
    }

    # Check if index is empty (no pinned layers)
    F is_empty(self) -> bool {
        self.max_pinned_layer == 0
    }

    # Clear all pinned layers (for shutdown or reset)
    F clear_all(~self) {
        self.pinned_layers.clear();
        self.max_pinned_layer = 0;
        self.total_pinned_memory = 0;
    }
}
