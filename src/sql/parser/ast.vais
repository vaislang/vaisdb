# SQL Abstract Syntax Tree
# All SQL statements and expressions are represented as AST nodes
# Used by the recursive descent parser and consumed by the query planner/executor

U sql/types.{SqlType, SqlValue};

# ============================================================================
# Top-level Statement
# ============================================================================

L Statement =
    Select { query: SelectQuery } |
    Insert { insert: InsertStmt } |
    Update { update: UpdateStmt } |
    Delete { delete: DeleteStmt } |
    CreateTable { create: CreateTableStmt } |
    DropTable { name: Str, if_exists: bool } |
    AlterTable { alter: AlterTableStmt } |
    CreateIndex { create: CreateIndexStmt } |
    DropIndex { name: Str, if_exists: bool } |
    Explain { stmt: Box<Statement>, analyze: bool } |
    BeginTxn { isolation: Option<Str> } |
    CommitTxn |
    RollbackTxn |
    SetExpr { target: SetTarget } |
    Prepare { name: Str, stmt: Box<Statement> } |
    Execute { name: Str, params: Vec<Expr> } |
    # Maintenance / Operations commands (Phase 9)
    Vacuum { table_name: Option<Str>, full: bool, analyze: bool, skip_locked: bool } |
    Reindex { target: Option<Str>, concurrently: bool } |
    Backup { path: Str, label: Option<Str> } |
    Restore { path: Str, pitr_timestamp: Option<Str>, pitr_lsn: Option<Str> } |
    # Security / Auth DDL commands (Phase 10)
    CreateUser { create: CreateUserStmt } |
    AlterUser { alter: AlterUserStmt } |
    DropUser { name: Str, if_exists: bool, cascade: bool } |
    CreateRole { create: CreateRoleStmt } |
    DropRole { name: Str, if_exists: bool, cascade: bool } |
    Grant { grant: GrantStmt } |
    Revoke { revoke: RevokeStmt } |
    CreatePolicy { create: CreatePolicyStmt } |
    DropPolicy { name: Str, table_name: Str, if_exists: bool };

# ============================================================================
# SELECT components
# ============================================================================

S SelectQuery {
    ctes: Vec<Cte>,
    select_list: Vec<SelectItem>,
    from: Option<Vec<TableRef>>,
    where_clause: Option<Expr>,
    group_by: Vec<Expr>,
    having: Option<Expr>,
    order_by: Vec<OrderByItem>,
    limit: Option<Expr>,
    offset: Option<Expr>,
    distinct: bool,
    set_op: Option<SetOperation>,
}

X SelectQuery {
    # Create a minimal empty SelectQuery for builder-style construction
    F empty() -> SelectQuery {
        SelectQuery {
            ctes: Vec.new(),
            select_list: Vec.new(),
            from: Option.None,
            where_clause: Option.None,
            group_by: Vec.new(),
            having: Option.None,
            order_by: Vec.new(),
            limit: Option.None,
            offset: Option.None,
            distinct: false,
            set_op: Option.None,
        }
    }
}

L SelectItem =
    AllColumns |
    AllColumnsFrom { table: Str } |
    Expr { expr: Expr, alias: Option<Str> };

S Cte {
    name: Str,
    columns: Vec<Str>,
    query: SelectQuery,
    recursive: bool,
}

S SetOperation {
    op: SetOpKind,
    all: bool,
    right: Box<SelectQuery>,
}

L SetOpKind = Union | Intersect | Except;

# ============================================================================
# Table references (FROM clause)
# ============================================================================

L TableRef =
    Table { name: Str, alias: Option<Str> } |
    Join { join: JoinClause } |
    Subquery { query: Box<SelectQuery>, alias: Str } |
    CrossJoin { left: Box<TableRef>, right: Box<TableRef> } |
    TableFunction { name: Str, args: Vec<Expr>, alias: Option<Str> };

S JoinClause {
    join_type: JoinType,
    left: Box<TableRef>,
    right: Box<TableRef>,
    condition: JoinCondition,
}

L JoinType = Inner | Left | Right | Cross;

L JoinCondition =
    On { expr: Expr } |
    Using { columns: Vec<Str> } |
    Natural;

# ============================================================================
# Expressions
# ============================================================================

L Expr =
    # Literals
    Literal { value: SqlValue } |
    # Column reference: table.column or just column
    ColumnRef { table: Option<Str>, column: Str } |
    # Parameter marker ($1, $2, ...)
    Parameter { idx: u32 } |
    # Binary operations: left op right
    BinaryOp { left: Box<Expr>, op: BinOp, right: Box<Expr> } |
    # Unary operations: op operand
    UnaryOp { op: UnaryOp, operand: Box<Expr> } |
    # IS NULL / IS NOT NULL
    IsNull { expr: Box<Expr>, negated: bool } |
    # BETWEEN low AND high / NOT BETWEEN
    Between { expr: Box<Expr>, low: Box<Expr>, high: Box<Expr>, negated: bool } |
    # IN (list) / NOT IN (list)
    InList { expr: Box<Expr>, list: Vec<Expr>, negated: bool } |
    # IN (subquery) / NOT IN (subquery)
    InSubquery { expr: Box<Expr>, query: Box<SelectQuery>, negated: bool } |
    # EXISTS (subquery) / NOT EXISTS (subquery)
    Exists { query: Box<SelectQuery>, negated: bool } |
    # LIKE / NOT LIKE
    Like { expr: Box<Expr>, pattern: Box<Expr>, negated: bool } |
    # CASE WHEN ... THEN ... ELSE ... END
    Case { operand: Option<Box<Expr>>, when_clauses: Vec<WhenClause>, else_result: Option<Box<Expr>> } |
    # CAST(expr AS type)
    Cast { expr: Box<Expr>, target_type: SqlType } |
    # Function call: name(args...) or name(DISTINCT args...)
    FunctionCall { name: Str, args: Vec<Expr>, distinct: bool } |
    # Window function: func() OVER (PARTITION BY ... ORDER BY ...)
    WindowFunc { func: Box<Expr>, partition_by: Vec<Expr>, order_by: Vec<OrderByItem> } |
    # Scalar subquery: (SELECT ...)
    Subquery { query: Box<SelectQuery> } |
    # String concatenation: left || right
    Concat { left: Box<Expr>, right: Box<Expr> } |
    # Wildcard (*) for use in COUNT(*)
    Star;

L BinOp = Add | Sub | Mul | Div | Mod |
          Eq | Neq | Lt | Gt | Le | Ge |
          And | Or;

L UnaryOp = Neg | Not;

S WhenClause { condition: Expr, result: Expr }

S OrderByItem { expr: Expr, asc: bool, nulls_first: Option<bool> }

# ============================================================================
# DDL statements
# ============================================================================

S CreateTableStmt {
    name: Str,
    columns: Vec<ColumnDef>,
    if_not_exists: bool,
}

S ColumnDef {
    name: Str,
    data_type: SqlType,
    nullable: bool,
    default_value: Option<Expr>,
    is_primary_key: bool,
    is_unique: bool,
    check_expr: Option<Expr>,
}

X ColumnDef {
    # Create a column definition with defaults (nullable, no constraints)
    F new(name: Str, data_type: SqlType) -> ColumnDef {
        ColumnDef {
            name,
            data_type,
            nullable: true,
            default_value: Option.None,
            is_primary_key: false,
            is_unique: false,
            check_expr: Option.None,
        }
    }
}

S CreateIndexStmt {
    name: Str,
    table_name: Str,
    columns: Vec<Str>,
    unique: bool,
    if_not_exists: bool,
}

S AlterTableStmt {
    table_name: Str,
    action: AlterAction,
}

L AlterAction =
    AddColumn { column: ColumnDef } |
    DropColumn { name: Str } |
    RenameColumn { old_name: Str, new_name: Str } |
    AlterColumnType { name: Str, new_type: SqlType } |
    EnableRls |
    DisableRls;

# ============================================================================
# DML statements
# ============================================================================

S InsertStmt {
    table_name: Str,
    columns: Vec<Str>,
    source: InsertSource,
}

L InsertSource =
    Values { rows: Vec<Vec<Expr>> } |
    Query { query: SelectQuery };

S UpdateStmt {
    table_name: Str,
    assignments: Vec<Assignment>,
    where_clause: Option<Expr>,
}

S Assignment { column: Str, value: Expr }

S DeleteStmt {
    table_name: Str,
    where_clause: Option<Expr>,
}

# ============================================================================
# SET statement target
# ============================================================================

L SetTarget =
    Session { key: Str, value: Expr } |
    Global { key: Str, value: Expr };

# ============================================================================
# Security DDL statements (Phase 10)
# ============================================================================

# CREATE USER username [WITH] PASSWORD 'pw' [options...]
S CreateUserStmt {
    username: Str,
    password: Str,
    is_superuser: Option<bool>,        # SUPERUSER / NOSUPERUSER
    can_login: Option<bool>,           # LOGIN / NOLOGIN
    connection_limit: Option<i64>,     # CONNECTION LIMIT n
    in_roles: Vec<Str>,               # IN ROLE role1, role2, ...
}

X CreateUserStmt {
    F new(username: Str, password: Str) -> CreateUserStmt {
        CreateUserStmt {
            username,
            password,
            is_superuser: Option.None,
            can_login: Option.None,
            connection_limit: Option.None,
            in_roles: Vec.new(),
        }
    }
}

# ALTER USER username [SET PASSWORD 'pw'] [RENAME TO name] [options...]
S AlterUserStmt {
    username: Str,
    password: Option<Str>,             # SET PASSWORD 'new_pw'
    rename_to: Option<Str>,            # RENAME TO new_name
    is_superuser: Option<bool>,        # SUPERUSER / NOSUPERUSER
    can_login: Option<bool>,           # LOGIN / NOLOGIN
    is_locked: Option<bool>,           # LOCK / UNLOCK
    connection_limit: Option<i64>,     # CONNECTION LIMIT n
}

X AlterUserStmt {
    F new(username: Str) -> AlterUserStmt {
        AlterUserStmt {
            username,
            password: Option.None,
            rename_to: Option.None,
            is_superuser: Option.None,
            can_login: Option.None,
            is_locked: Option.None,
            connection_limit: Option.None,
        }
    }
}

# CREATE ROLE role_name [IN ROLE parent1, parent2, ...]
S CreateRoleStmt {
    role_name: Str,
    in_roles: Vec<Str>,               # Inherit from these roles
}

X CreateRoleStmt {
    F new(role_name: Str) -> CreateRoleStmt {
        CreateRoleStmt {
            role_name,
            in_roles: Vec.new(),
        }
    }
}

# GRANT privileges ON object TO role/user [WITH GRANT OPTION]
# GRANT ROLE role TO user
S GrantStmt {
    grant_type: GrantType,
}

L GrantType =
    # GRANT SELECT, INSERT, ... ON table TO role [WITH GRANT OPTION]
    Privileges {
        privileges: Vec<PrivilegeKind>,
        object_type: ObjectKind,
        object_name: Str,
        grantee: Str,
        with_grant_option: bool,
    } |
    # GRANT ROLE role_name TO user_or_role
    RoleMembership {
        role_name: Str,
        grantee: Str,
    };

# REVOKE privileges ON object FROM role/user [CASCADE]
# REVOKE ROLE role FROM user
S RevokeStmt {
    revoke_type: RevokeType,
}

L RevokeType =
    # REVOKE SELECT, INSERT, ... ON table FROM role [CASCADE]
    Privileges {
        privileges: Vec<PrivilegeKind>,
        object_type: ObjectKind,
        object_name: Str,
        grantee: Str,
        cascade: bool,
    } |
    # REVOKE ROLE role_name FROM user_or_role
    RoleMembership {
        role_name: Str,
        grantee: Str,
    };

# Individual privilege types
L PrivilegeKind =
    Select |
    Insert |
    Update |
    Delete |
    Create |
    Drop |
    Alter |
    All;

# Object types for GRANT/REVOKE ON
L ObjectKind =
    Table |
    Database |
    Schema;

# CREATE POLICY name ON table [FOR cmd] [TO role] USING (expr) [WITH CHECK (expr)]
S CreatePolicyStmt {
    policy_name: Str,
    table_name: Str,
    cmd_scope: PolicyCmdScope,         # FOR ALL | SELECT | INSERT | UPDATE | DELETE
    role_name: Option<Str>,            # TO role (None = all roles)
    using_expr: Option<Str>,           # USING (expr) as raw SQL string
    check_expr: Option<Str>,           # WITH CHECK (expr) as raw SQL string
    policy_type: PolicyType,           # PERMISSIVE (default) or RESTRICTIVE
}

X CreatePolicyStmt {
    F new(policy_name: Str, table_name: Str) -> CreatePolicyStmt {
        CreatePolicyStmt {
            policy_name,
            table_name,
            cmd_scope: PolicyCmdScope.All,
            role_name: Option.None,
            using_expr: Option.None,
            check_expr: Option.None,
            policy_type: PolicyType.Permissive,
        }
    }
}

# Policy command scope
L PolicyCmdScope = All | Select | Insert | Update | Delete;

# Policy type
L PolicyType = Permissive | Restrictive;
