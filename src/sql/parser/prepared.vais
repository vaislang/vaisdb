# Prepared Statements
# Parse once, execute many with parameter binding ($1, $2, ...)
# Supports plan caching (optional, for future optimizer integration)

U storage/error.{VaisError};
U sql/types.{SqlType, SqlValue};
U sql/parser/ast.{
    Statement, SelectQuery, SelectItem, Cte, SetOperation,
    TableRef, JoinClause, JoinCondition,
    Expr, BinOp, UnaryOp, WhenClause, OrderByItem,
    CreateTableStmt, ColumnDef, CreateIndexStmt, AlterTableStmt, AlterAction,
    InsertStmt, InsertSource, UpdateStmt, Assignment, DeleteStmt,
};
U sql/parser/parser.{parse_sql};

# ============================================================================
# PreparedStatement - Cached parsed statement with parameter support
# ============================================================================

S PreparedStatement {
    name: Str,                        # Statement name
    sql: Str,                         # Original SQL text
    parsed: Statement,                # Parsed AST (parse once)
    param_count: u32,                 # Number of parameters ($1..$N)
    param_types: Vec<Option<SqlType>>, # Optional type hints per parameter
}

X PreparedStatement {
    # Parse SQL, count parameters, create prepared statement
    F prepare(name: Str, sql: Str) -> Result<PreparedStatement, VaisError> {
        # Parse the SQL
        ~stmts = parse_sql(sql.clone())?;

        # Must be exactly one statement
        I stmts.len() != 1 {
            R Err(VaisError.new(
                "VAIS-0101001",
                "Prepared statement must contain exactly one SQL statement"
            ));
        }

        ~parsed = stmts[0].clone();

        # Count parameters in the AST
        ~param_count = count_parameters(&parsed);

        # Initialize empty type hints
        ~param_types = Vec.new();
        L _: 0..param_count {
            param_types.push(Option.None);
        }

        Ok(PreparedStatement {
            name,
            sql,
            parsed,
            param_count,
            param_types,
        })
    }

    # Substitute parameters into AST, return new Statement with literals
    # Error if wrong param count
    F bind(self, params: &[SqlValue]) -> Result<Statement, VaisError> {
        # Check parameter count
        I params.len() != self.param_count as u64 {
            R Err(err_param_count_mismatch(self.param_count, params.len()));
        }

        # Substitute parameters into AST
        substitute_params(&self.parsed, params)
    }

    # Get parameter count
    F param_count(self) -> u32 {
        self.param_count
    }

    # Get statement name
    F get_name(self) -> &Str {
        &self.name
    }

    # Get original SQL text
    F get_sql(self) -> &Str {
        &self.sql
    }
}

# ============================================================================
# PreparedStatementCache - Manage prepared statements
# ============================================================================

S PreparedStatementCache {
    statements: Vec<(Str, PreparedStatement)>,  # name -> prepared stmt (Vec since no HashMap yet)
    max_size: u64,                            # Max cached statements
}

X PreparedStatementCache {
    # Create new cache with max size
    F new(max_size: u64) -> PreparedStatementCache {
        PreparedStatementCache {
            statements: Vec.new(),
            max_size,
        }
    }

    # Parse and cache a prepared statement
    F prepare(~self, name: Str, sql: Str) -> Result<(), VaisError> {
        # Check if statement with this name already exists
        L i: 0..self.statements.len() {
            I self.statements[i].0 == name {
                R Err(VaisError.new(
                    "VAIS-0101001",
                    "Prepared statement '{name}' already exists"
                ));
            }
        }

        # Create the prepared statement
        ~stmt = PreparedStatement.prepare(name.clone(), sql)?;

        # Check cache size limit
        I self.statements.len() >= self.max_size {
            # Simple eviction: remove oldest (first)
            self.statements.remove(0);
        }

        # Add to cache
        self.statements.push((name, stmt));
        Ok(())
    }

    # Lookup, bind parameters, and return ready-to-execute statement
    F execute(self, name: &Str, params: &[SqlValue]) -> Result<Statement, VaisError> {
        # Find the prepared statement
        L i: 0..self.statements.len() {
            I self.statements[i].0 == *name {
                R self.statements[i].1.bind(params);
            }
        }

        Err(err_stmt_not_found(name.clone()))
    }

    # Remove a prepared statement from cache
    F deallocate(~self, name: &Str) -> Result<(), VaisError> {
        # Find and remove
        L i: 0..self.statements.len() {
            I self.statements[i].0 == *name {
                self.statements.remove(i);
                R Ok(());
            }
        }

        Err(err_stmt_not_found(name.clone()))
    }

    # Check if statement exists
    F exists(self, name: &Str) -> bool {
        L i: 0..self.statements.len() {
            I self.statements[i].0 == *name {
                R true;
            }
        }
        false
    }

    # Get cache size
    F count(self) -> u64 {
        self.statements.len()
    }
}

# ============================================================================
# Internal helpers - parameter counting and substitution
# ============================================================================

# Walk AST to find maximum parameter index
F count_parameters(stmt: &Statement) -> u32 {
    M stmt {
        Statement.Select { query } => count_params_in_query(query),
        Statement.Insert { insert } => {
            ~max = 0u32;
            # Count in source (VALUES or SELECT)
            M &insert.source {
                InsertSource.Values { rows } => {
                    L row: rows {
                        L expr: row {
                            ~expr_max = count_params_in_expr(expr);
                            I expr_max > max {
                                max = expr_max;
                            }
                        }
                    }
                },
                InsertSource.Query { query } => {
                    max = count_params_in_query(query);
                },
            }
            max
        },
        Statement.Update { update } => {
            ~max = 0u32;
            # Count in assignments
            L assign: &update.assignments {
                ~expr_max = count_params_in_expr(&assign.value);
                I expr_max > max {
                    max = expr_max;
                }
            }
            # Count in where clause
            M &update.where_clause {
                Option.Some(expr) => {
                    ~expr_max = count_params_in_expr(expr);
                    I expr_max > max {
                        max = expr_max;
                    }
                },
                Option.None => {},
            }
            max
        },
        Statement.Delete { delete } => {
            M &delete.where_clause {
                Option.Some(expr) => count_params_in_expr(expr),
                Option.None => 0,
            }
        },
        Statement.CreateTable { create } => {
            ~max = 0u32;
            L col: &create.columns {
                M &col.default_value {
                    Option.Some(expr) => {
                        ~expr_max = count_params_in_expr(expr);
                        I expr_max > max {
                            max = expr_max;
                        }
                    },
                    Option.None => {},
                }
                M &col.check_expr {
                    Option.Some(expr) => {
                        ~expr_max = count_params_in_expr(expr);
                        I expr_max > max {
                            max = expr_max;
                        }
                    },
                    Option.None => {},
                }
            }
            max
        },
        Statement.Prepare { stmt: inner, .. } => {
            count_parameters(&**inner)
        },
        Statement.Execute { params, .. } => {
            ~max = 0u32;
            L expr: params {
                ~expr_max = count_params_in_expr(expr);
                I expr_max > max {
                    max = expr_max;
                }
            }
            max
        },
        _ => 0,
    }
}

# Count parameters in a SelectQuery
F count_params_in_query(query: &SelectQuery) -> u32 {
    ~max = 0u32;

    # CTEs
    L cte: &query.ctes {
        ~cte_max = count_params_in_query(&cte.query);
        I cte_max > max {
            max = cte_max;
        }
    }

    # Select list
    L item: &query.select_list {
        M item {
            SelectItem.Expr { expr, .. } => {
                ~expr_max = count_params_in_expr(expr);
                I expr_max > max {
                    max = expr_max;
                }
            },
            _ => {},
        }
    }

    # FROM clause
    M &query.from {
        Option.Some(refs) => {
            L table_ref: refs {
                ~ref_max = count_params_in_table_ref(table_ref);
                I ref_max > max {
                    max = ref_max;
                }
            }
        },
        Option.None => {},
    }

    # WHERE
    M &query.where_clause {
        Option.Some(expr) => {
            ~expr_max = count_params_in_expr(expr);
            I expr_max > max {
                max = expr_max;
            }
        },
        Option.None => {},
    }

    # GROUP BY
    L expr: &query.group_by {
        ~expr_max = count_params_in_expr(expr);
        I expr_max > max {
            max = expr_max;
        }
    }

    # HAVING
    M &query.having {
        Option.Some(expr) => {
            ~expr_max = count_params_in_expr(expr);
            I expr_max > max {
                max = expr_max;
            }
        },
        Option.None => {},
    }

    # ORDER BY
    L item: &query.order_by {
        ~expr_max = count_params_in_expr(&item.expr);
        I expr_max > max {
            max = expr_max;
        }
    }

    # LIMIT/OFFSET
    M &query.limit {
        Option.Some(expr) => {
            ~expr_max = count_params_in_expr(expr);
            I expr_max > max {
                max = expr_max;
            }
        },
        Option.None => {},
    }
    M &query.offset {
        Option.Some(expr) => {
            ~expr_max = count_params_in_expr(expr);
            I expr_max > max {
                max = expr_max;
            }
        },
        Option.None => {},
    }

    # Set operations
    M &query.set_op {
        Option.Some(set_op) => {
            ~set_max = count_params_in_query(&*set_op.right);
            I set_max > max {
                max = set_max;
            }
        },
        Option.None => {},
    }

    max
}

# Count parameters in a TableRef
F count_params_in_table_ref(table_ref: &TableRef) -> u32 {
    M table_ref {
        TableRef.Subquery { query, .. } => count_params_in_query(&**query),
        TableRef.Join { join } => {
            ~left_max = count_params_in_table_ref(&*join.left);
            ~right_max = count_params_in_table_ref(&*join.right);
            ~max = I left_max > right_max { left_max } E { right_max };

            # Check condition
            M &join.condition {
                JoinCondition.On { expr } => {
                    ~cond_max = count_params_in_expr(expr);
                    I cond_max > max {
                        max = cond_max;
                    }
                    max
                },
                _ => max,
            }
        },
        TableRef.CrossJoin { left, right } => {
            ~left_max = count_params_in_table_ref(&**left);
            ~right_max = count_params_in_table_ref(&**right);
            I left_max > right_max { left_max } E { right_max }
        },
        _ => 0,
    }
}

# Recursive parameter counting in expressions
F count_params_in_expr(expr: &Expr) -> u32 {
    M expr {
        Expr.Parameter { idx } => *idx,
        Expr.BinaryOp { left, right, .. } => {
            ~left_max = count_params_in_expr(&**left);
            ~right_max = count_params_in_expr(&**right);
            I left_max > right_max { left_max } E { right_max }
        },
        Expr.UnaryOp { operand, .. } => count_params_in_expr(&**operand),
        Expr.IsNull { expr: e, .. } => count_params_in_expr(&**e),
        Expr.Between { expr: e, low, high, .. } => {
            ~e_max = count_params_in_expr(&**e);
            ~low_max = count_params_in_expr(&**low);
            ~high_max = count_params_in_expr(&**high);
            ~max = I e_max > low_max { e_max } E { low_max };
            I high_max > max { high_max } E { max }
        },
        Expr.InList { expr: e, list, .. } => {
            ~max = count_params_in_expr(&**e);
            L item: list {
                ~item_max = count_params_in_expr(item);
                I item_max > max {
                    max = item_max;
                }
            }
            max
        },
        Expr.InSubquery { expr: e, query, .. } => {
            ~e_max = count_params_in_expr(&**e);
            ~q_max = count_params_in_query(&**query);
            I e_max > q_max { e_max } E { q_max }
        },
        Expr.Exists { query, .. } => count_params_in_query(&**query),
        Expr.Like { expr: e, pattern, .. } => {
            ~e_max = count_params_in_expr(&**e);
            ~p_max = count_params_in_expr(&**pattern);
            I e_max > p_max { e_max } E { p_max }
        },
        Expr.Case { operand, when_clauses, else_result } => {
            ~max = 0u32;
            M operand {
                Option.Some(op) => {
                    max = count_params_in_expr(&**op);
                },
                Option.None => {},
            }
            L when_clause: when_clauses {
                ~cond_max = count_params_in_expr(&when_clause.condition);
                ~res_max = count_params_in_expr(&when_clause.result);
                I cond_max > max {
                    max = cond_max;
                }
                I res_max > max {
                    max = res_max;
                }
            }
            M else_result {
                Option.Some(e) => {
                    ~e_max = count_params_in_expr(&**e);
                    I e_max > max {
                        max = e_max;
                    }
                },
                Option.None => {},
            }
            max
        },
        Expr.Cast { expr: e, .. } => count_params_in_expr(&**e),
        Expr.FunctionCall { args, .. } => {
            ~max = 0u32;
            L arg: args {
                ~arg_max = count_params_in_expr(arg);
                I arg_max > max {
                    max = arg_max;
                }
            }
            max
        },
        Expr.WindowFunc { func, partition_by, order_by } => {
            ~max = count_params_in_expr(&**func);
            L expr: partition_by {
                ~expr_max = count_params_in_expr(expr);
                I expr_max > max {
                    max = expr_max;
                }
            }
            L item: order_by {
                ~expr_max = count_params_in_expr(&item.expr);
                I expr_max > max {
                    max = expr_max;
                }
            }
            max
        },
        Expr.Subquery { query } => count_params_in_query(&**query),
        Expr.Concat { left, right } => {
            ~left_max = count_params_in_expr(&**left);
            ~right_max = count_params_in_expr(&**right);
            I left_max > right_max { left_max } E { right_max }
        },
        _ => 0,
    }
}

# ============================================================================
# Parameter substitution - deep clone AST replacing Parameter with Literal
# ============================================================================

# Substitute parameters in a Statement
F substitute_params(stmt: &Statement, params: &[SqlValue]) -> Result<Statement, VaisError> {
    M stmt {
        Statement.Select { query } => {
            ~new_query = substitute_query(query, params)?;
            Ok(Statement.Select { query: new_query })
        },
        Statement.Insert { insert } => {
            ~new_source = M &insert.source {
                InsertSource.Values { rows } => {
                    ~new_rows = Vec.new();
                    L row: rows {
                        ~new_row = Vec.new();
                        L expr: row {
                            new_row.push(substitute_expr(expr, params)?);
                        }
                        new_rows.push(new_row);
                    }
                    InsertSource.Values { rows: new_rows }
                },
                InsertSource.Query { query } => {
                    InsertSource.Query { query: substitute_query(query, params)? }
                },
            };
            Ok(Statement.Insert {
                insert: InsertStmt {
                    table_name: insert.table_name.clone(),
                    columns: insert.columns.clone(),
                    source: new_source,
                }
            })
        },
        Statement.Update { update } => {
            ~new_assignments = Vec.new();
            L assign: &update.assignments {
                new_assignments.push(Assignment {
                    column: assign.column.clone(),
                    value: substitute_expr(&assign.value, params)?,
                });
            }
            ~new_where = M &update.where_clause {
                Option.Some(expr) => Option.Some(substitute_expr(expr, params)?),
                Option.None => Option.None,
            };
            Ok(Statement.Update {
                update: UpdateStmt {
                    table_name: update.table_name.clone(),
                    assignments: new_assignments,
                    where_clause: new_where,
                }
            })
        },
        Statement.Delete { delete } => {
            ~new_where = M &delete.where_clause {
                Option.Some(expr) => Option.Some(substitute_expr(expr, params)?),
                Option.None => Option.None,
            };
            Ok(Statement.Delete {
                delete: DeleteStmt {
                    table_name: delete.table_name.clone(),
                    where_clause: new_where,
                }
            })
        },
        # Other statement types just clone as-is (no parameters expected)
        _ => Ok(stmt.clone()),
    }
}

# Substitute parameters in a SelectQuery
F substitute_query(query: &SelectQuery, params: &[SqlValue]) -> Result<SelectQuery, VaisError> {
    # CTEs
    ~new_ctes = Vec.new();
    L cte: &query.ctes {
        new_ctes.push(Cte {
            name: cte.name.clone(),
            columns: cte.columns.clone(),
            query: substitute_query(&cte.query, params)?,
            recursive: cte.recursive,
        });
    }

    # Select list
    ~new_select_list = Vec.new();
    L item: &query.select_list {
        ~new_item = M item {
            SelectItem.Expr { expr, alias } => {
                SelectItem.Expr {
                    expr: substitute_expr(expr, params)?,
                    alias: alias.clone(),
                }
            },
            _ => item.clone(),
        };
        new_select_list.push(new_item);
    }

    # FROM clause
    ~new_from = M &query.from {
        Option.Some(refs) => {
            ~new_refs = Vec.new();
            L table_ref: refs {
                new_refs.push(substitute_table_ref(table_ref, params)?);
            }
            Option.Some(new_refs)
        },
        Option.None => Option.None,
    };

    # WHERE
    ~new_where = M &query.where_clause {
        Option.Some(expr) => Option.Some(substitute_expr(expr, params)?),
        Option.None => Option.None,
    };

    # GROUP BY
    ~new_group_by = Vec.new();
    L expr: &query.group_by {
        new_group_by.push(substitute_expr(expr, params)?);
    }

    # HAVING
    ~new_having = M &query.having {
        Option.Some(expr) => Option.Some(substitute_expr(expr, params)?),
        Option.None => Option.None,
    };

    # ORDER BY
    ~new_order_by = Vec.new();
    L item: &query.order_by {
        new_order_by.push(OrderByItem {
            expr: substitute_expr(&item.expr, params)?,
            asc: item.asc,
            nulls_first: item.nulls_first,
        });
    }

    # LIMIT/OFFSET
    ~new_limit = M &query.limit {
        Option.Some(expr) => Option.Some(substitute_expr(expr, params)?),
        Option.None => Option.None,
    };
    ~new_offset = M &query.offset {
        Option.Some(expr) => Option.Some(substitute_expr(expr, params)?),
        Option.None => Option.None,
    };

    # Set operations
    ~new_set_op = M &query.set_op {
        Option.Some(set_op) => {
            Option.Some(SetOperation {
                op: set_op.op.clone(),
                all: set_op.all,
                right: Box.new(substitute_query(&*set_op.right, params)?),
            })
        },
        Option.None => Option.None,
    };

    Ok(SelectQuery {
        ctes: new_ctes,
        select_list: new_select_list,
        from: new_from,
        where_clause: new_where,
        group_by: new_group_by,
        having: new_having,
        order_by: new_order_by,
        limit: new_limit,
        offset: new_offset,
        distinct: query.distinct,
        set_op: new_set_op,
    })
}

# Substitute parameters in a TableRef
F substitute_table_ref(table_ref: &TableRef, params: &[SqlValue]) -> Result<TableRef, VaisError> {
    M table_ref {
        TableRef.Subquery { query, alias } => {
            Ok(TableRef.Subquery {
                query: Box.new(substitute_query(&**query, params)?),
                alias: alias.clone(),
            })
        },
        TableRef.Join { join } => {
            ~new_left = Box.new(substitute_table_ref(&*join.left, params)?);
            ~new_right = Box.new(substitute_table_ref(&*join.right, params)?);
            ~new_condition = M &join.condition {
                JoinCondition.On { expr } => {
                    JoinCondition.On { expr: substitute_expr(expr, params)? }
                },
                _ => join.condition.clone(),
            };
            Ok(TableRef.Join {
                join: JoinClause {
                    join_type: join.join_type.clone(),
                    left: new_left,
                    right: new_right,
                    condition: new_condition,
                }
            })
        },
        TableRef.CrossJoin { left, right } => {
            Ok(TableRef.CrossJoin {
                left: Box.new(substitute_table_ref(&**left, params)?),
                right: Box.new(substitute_table_ref(&**right, params)?),
            })
        },
        _ => Ok(table_ref.clone()),
    }
}

# Recursive expression substitution - replace Parameter nodes with Literal nodes
F substitute_expr(expr: &Expr, params: &[SqlValue]) -> Result<Expr, VaisError> {
    M expr {
        # Parameter marker: replace with literal
        Expr.Parameter { idx } => {
            # Parameter indices are 1-based ($1 = params[0])
            I *idx == 0 || (*idx as u64) > params.len() {
                R Err(err_param_out_of_range(*idx, params.len() as u32));
            }
            ~param_idx = (*idx - 1) as u64;
            Ok(Expr.Literal { value: params[param_idx].clone() })
        },

        # Binary operation
        Expr.BinaryOp { left, op, right } => {
            Ok(Expr.BinaryOp {
                left: Box.new(substitute_expr(&**left, params)?),
                op: *op,
                right: Box.new(substitute_expr(&**right, params)?),
            })
        },

        # Unary operation
        Expr.UnaryOp { op, operand } => {
            Ok(Expr.UnaryOp {
                op: *op,
                operand: Box.new(substitute_expr(&**operand, params)?),
            })
        },

        # IS NULL / IS NOT NULL
        Expr.IsNull { expr: e, negated } => {
            Ok(Expr.IsNull {
                expr: Box.new(substitute_expr(&**e, params)?),
                negated: *negated,
            })
        },

        # BETWEEN
        Expr.Between { expr: e, low, high, negated } => {
            Ok(Expr.Between {
                expr: Box.new(substitute_expr(&**e, params)?),
                low: Box.new(substitute_expr(&**low, params)?),
                high: Box.new(substitute_expr(&**high, params)?),
                negated: *negated,
            })
        },

        # IN (list)
        Expr.InList { expr: e, list, negated } => {
            ~new_list = Vec.new();
            L item: list {
                new_list.push(substitute_expr(item, params)?);
            }
            Ok(Expr.InList {
                expr: Box.new(substitute_expr(&**e, params)?),
                list: new_list,
                negated: *negated,
            })
        },

        # IN (subquery)
        Expr.InSubquery { expr: e, query, negated } => {
            Ok(Expr.InSubquery {
                expr: Box.new(substitute_expr(&**e, params)?),
                query: Box.new(substitute_query(&**query, params)?),
                negated: *negated,
            })
        },

        # EXISTS (subquery)
        Expr.Exists { query, negated } => {
            Ok(Expr.Exists {
                query: Box.new(substitute_query(&**query, params)?),
                negated: *negated,
            })
        },

        # LIKE
        Expr.Like { expr: e, pattern, negated } => {
            Ok(Expr.Like {
                expr: Box.new(substitute_expr(&**e, params)?),
                pattern: Box.new(substitute_expr(&**pattern, params)?),
                negated: *negated,
            })
        },

        # CASE
        Expr.Case { operand, when_clauses, else_result } => {
            ~new_operand = M operand {
                Option.Some(op) => Option.Some(Box.new(substitute_expr(&**op, params)?)),
                Option.None => Option.None,
            };
            ~new_when_clauses = Vec.new();
            L when_clause: when_clauses {
                new_when_clauses.push(WhenClause {
                    condition: substitute_expr(&when_clause.condition, params)?,
                    result: substitute_expr(&when_clause.result, params)?,
                });
            }
            ~new_else = M else_result {
                Option.Some(e) => Option.Some(Box.new(substitute_expr(&**e, params)?)),
                Option.None => Option.None,
            };
            Ok(Expr.Case {
                operand: new_operand,
                when_clauses: new_when_clauses,
                else_result: new_else,
            })
        },

        # CAST
        Expr.Cast { expr: e, target_type } => {
            Ok(Expr.Cast {
                expr: Box.new(substitute_expr(&**e, params)?),
                target_type: target_type.clone(),
            })
        },

        # Function call
        Expr.FunctionCall { name, args, distinct } => {
            ~new_args = Vec.new();
            L arg: args {
                new_args.push(substitute_expr(arg, params)?);
            }
            Ok(Expr.FunctionCall {
                name: name.clone(),
                args: new_args,
                distinct: *distinct,
            })
        },

        # Window function
        Expr.WindowFunc { func, partition_by, order_by } => {
            ~new_func = Box.new(substitute_expr(&**func, params)?);
            ~new_partition = Vec.new();
            L expr: partition_by {
                new_partition.push(substitute_expr(expr, params)?);
            }
            ~new_order = Vec.new();
            L item: order_by {
                new_order.push(OrderByItem {
                    expr: substitute_expr(&item.expr, params)?,
                    asc: item.asc,
                    nulls_first: item.nulls_first,
                });
            }
            Ok(Expr.WindowFunc {
                func: new_func,
                partition_by: new_partition,
                order_by: new_order,
            })
        },

        # Scalar subquery
        Expr.Subquery { query } => {
            Ok(Expr.Subquery {
                query: Box.new(substitute_query(&**query, params)?),
            })
        },

        # String concatenation
        Expr.Concat { left, right } => {
            Ok(Expr.Concat {
                left: Box.new(substitute_expr(&**left, params)?),
                right: Box.new(substitute_expr(&**right, params)?),
            })
        },

        # Literals, column refs, star - clone as-is
        _ => Ok(expr.clone()),
    }
}

# ============================================================================
# Error constructors
# ============================================================================

F err_stmt_not_found(name: Str) -> VaisError {
    VaisError.new(
        "VAIS-0101001",
        "Prepared statement '{name}' not found"
    )
}

F err_param_count_mismatch(expected: u32, got: u64) -> VaisError {
    VaisError.new(
        "VAIS-0101001",
        "Expected {expected} parameters, got {got}"
    )
}

F err_param_out_of_range(idx: u32, max: u32) -> VaisError {
    VaisError.new(
        "VAIS-0101001",
        "Parameter ${idx} out of range (max ${max})"
    )
}
