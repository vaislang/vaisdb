# Window Functions Executor
# Supports ROW_NUMBER, RANK, DENSE_RANK, SUM, AVG, COUNT, MIN, MAX over windows
# Materialization-based approach: collect all rows, partition, sort, compute window values
# Error codes: EE=01 (SQL), CC=06 (Window), NNN=001-005

U std/hashmap.{HashMap};
U std/result.Result;
U std/option.Option;
U std/vec.Vec;
U std/str.Str;

U crate/error.VaisError;
U crate/sql/types.{SqlValue, SqlType, agg_sum, agg_avg_accumulate, agg_avg_finalize, agg_min, agg_max, agg_count_value, group_key_hash, order_by_compare};
U crate/sql/row.Row;
U crate/sql/parser/ast.{OrderByItem, Expr};
U crate/sql/executor/mod.{ExecutorRow, ExecStats};
U crate/sql/executor/expr_eval.{eval_expr, EvalContext};

# ============================================================================
# WindowExecutor - Computes window function values over partitions
# ============================================================================

# Window function specification
S WindowSpec {
    func_expr: Expr,             # The window function (e.g., FunctionCall for SUM, ROW_NUMBER)
    partition_by: Vec<Expr>,     # PARTITION BY expressions
    order_by: Vec<OrderByItem>,  # ORDER BY within partition
    result_col_idx: usize,       # Index in output schema where this window result goes
}

X WindowSpec {
    F new(func_expr: Expr, partition_by: Vec<Expr>, order_by: Vec<OrderByItem>, result_col_idx: usize) -> WindowSpec {
        WindowSpec {
            func_expr,
            partition_by,
            order_by,
            result_col_idx,
        }
    }
}

# Single partition of rows with the same partition key
S Partition {
    key_values: Vec<SqlValue>,  # Partition key values
    rows: Vec<Row>,             # All rows in this partition (sorted by ORDER BY)
}

X Partition {
    F new(key_values: Vec<SqlValue>) -> Partition {
        Partition {
            key_values,
            rows: Vec.new(),
        }
    }
}

# Main window executor
S WindowExecutor {
    input: Box<dyn Executor>,
    window_specs: Vec<WindowSpec>,  # Multiple window functions can be computed
    eval_ctx: EvalContext,
    materialized: Option<Vec<Row>>,  # Final augmented rows with window function results
    cursor: usize,
    stats: ExecStats,
}

X WindowExecutor {
    F new(input: Box<dyn Executor>, window_specs: Vec<WindowSpec>, eval_ctx: EvalContext) -> WindowExecutor {
        WindowExecutor {
            input,
            window_specs,
            eval_ctx,
            materialized: Option.None,
            cursor: 0,
            stats: ExecStats.new(),
        }
    }

    F open(~self) -> Result<(), VaisError> {
        self.input.open()?;

        # Step 1: Materialize all input rows
        ~input_rows = Vec.new();
        L {
            M self.input.next()? {
                Option.Some(exec_row) => {
                    self.stats.add_scanned(1);
                    input_rows.push(exec_row.get_row().clone());
                },
                Option.None => { break; },
            }
        }

        # Step 2: Process each window function specification
        ~augmented_rows = input_rows.clone();

        for spec in &self.window_specs {
            # Step 2a: Partition rows by partition key
            ~partitions = self.partition_rows(&input_rows, &spec.partition_by)?;

            # Step 2b: Sort each partition by ORDER BY
            for partition in partitions.values_mut() {
                self.sort_partition(&spec.order_by, partition);
            }

            # Step 2c: Compute window function values for each partition
            ~window_values = self.compute_window_values(&partitions, spec)?;

            # Step 2d: Augment rows with computed window values
            augmented_rows = self.augment_rows_with_window_values(augmented_rows, &window_values);
        }

        # Step 3: Store augmented rows for iteration
        self.materialized = Option.Some(augmented_rows);
        self.cursor = 0;

        Result.Ok(())
    }

    F next(~self) -> Result<Option<ExecutorRow>, VaisError> {
        M &self.materialized {
            Option.None => {
                Result.Err(VaisError.new("VAIS-E0106001", "WindowExecutor not opened"))
            },
            Option.Some(rows) => {
                if self.cursor >= rows.len() {
                    Result.Ok(Option.None)
                } else {
                    ~row = &rows[self.cursor];
                    self.cursor += 1;
                    self.stats.add_produced();
                    Result.Ok(Option.Some(ExecutorRow.virtual(row.clone())))
                }
            },
        }
    }

    F close(~self) -> Result<(), VaisError> {
        self.materialized = Option.None;
        self.cursor = 0;
        self.input.close()?;
        Result.Ok(())
    }

    F stats(self) -> &ExecStats {
        &self.stats
    }

    # Partition rows into groups based on partition_by expressions
    F partition_rows(
        self,
        rows: &Vec<Row>,
        partition_exprs: &Vec<Expr>,
    ) -> Result<HashMap<u64, Partition>, VaisError> {
        ~partitions: HashMap<u64, Partition> = HashMap.new();

        for row in rows {
            # Evaluate partition key
            ~key_values = Vec.new();
            for expr in partition_exprs {
                ~val = eval_expr(expr, row, &self.eval_ctx)?;
                key_values.push(val);
            }

            # Hash partition key (if empty, all rows go to same partition)
            ~hash = if key_values.is_empty() {
                0  # No PARTITION BY: single partition
            } else {
                group_key_hash(&key_values)
            };

            # Get or create partition
            if !partitions.contains_key(&hash) {
                partitions.insert(hash, Partition.new(key_values.clone()));
            }
            ~partition = partitions.get_mut(&hash).unwrap();

            # Add row to partition
            partition.rows.push(row.clone());
        }

        Result.Ok(partitions)
    }

    # Sort rows within a partition by ORDER BY clause
    F sort_partition(self, order_items: &Vec<OrderByItem>, partition: ~Partition) {
        if order_items.is_empty() {
            return;  # No ORDER BY, keep original order
        }

        partition.rows.sort_by(|a, b| self.compare_rows(a, b, order_items));
    }

    # Compare two rows using multi-key ORDER BY
    F compare_rows(self, a: &Row, b: &Row, order_items: &Vec<OrderByItem>) -> i32 {
        for item in order_items {
            # Evaluate sort key for both rows
            ~val_a = M eval_expr(&item.expr, a, &self.eval_ctx) {
                Result.Ok(v) => v,
                Result.Err(_) => SqlValue.Null,  # Treat eval errors as NULL
            };

            ~val_b = M eval_expr(&item.expr, b, &self.eval_ctx) {
                Result.Ok(v) => v,
                Result.Err(_) => SqlValue.Null,
            };

            # Determine nulls_first (default: NULLS LAST for ASC, NULLS FIRST for DESC)
            ~nulls_first = M item.nulls_first {
                Option.Some(nf) => nf,
                Option.None => !item.asc,
            };

            ~cmp = order_by_compare(&val_a, &val_b, item.asc, Option.Some(nulls_first));
            if cmp != 0 {
                return cmp;
            }
        }

        0  # All keys equal
    }

    # Compute window function values for all partitions
    # Returns a Vec<SqlValue> with one value per original input row
    F compute_window_values(
        self,
        partitions: &HashMap<u64, Partition>,
        spec: &WindowSpec,
    ) -> Result<Vec<SqlValue>, VaisError> {
        ~all_values = Vec.new();

        for (_, partition) in partitions {
            ~partition_values = self.compute_partition_window_values(partition, spec)?;
            all_values.extend(partition_values);
        }

        Result.Ok(all_values)
    }

    # Compute window function values for a single partition
    F compute_partition_window_values(
        self,
        partition: &Partition,
        spec: &WindowSpec,
    ) -> Result<Vec<SqlValue>, VaisError> {
        ~values = Vec.with_capacity(partition.rows.len());

        # Determine window function type
        M &spec.func_expr {
            Expr.FunctionCall { name, args, .. } => {
                M name.to_uppercase().as_str() {
                    "ROW_NUMBER" => {
                        # ROW_NUMBER: sequential number within partition
                        for i in 0..partition.rows.len() {
                            values.push(SqlValue.IntVal { v: (i + 1) as i64 });
                        }
                    },
                    "RANK" => {
                        # RANK: rank with gaps (ties get same rank, next rank skips)
                        values = self.compute_rank(partition, spec, false)?;
                    },
                    "DENSE_RANK" => {
                        # DENSE_RANK: rank without gaps
                        values = self.compute_rank(partition, spec, true)?;
                    },
                    "SUM" => {
                        # SUM(expr) OVER (...): running/partition sum
                        values = self.compute_aggregate_window(partition, spec, "SUM", args)?;
                    },
                    "AVG" => {
                        # AVG(expr) OVER (...): running/partition average
                        values = self.compute_aggregate_window(partition, spec, "AVG", args)?;
                    },
                    "COUNT" => {
                        # COUNT(expr) OVER (...): running/partition count
                        values = self.compute_aggregate_window(partition, spec, "COUNT", args)?;
                    },
                    "MIN" => {
                        # MIN(expr) OVER (...): partition min
                        values = self.compute_aggregate_window(partition, spec, "MIN", args)?;
                    },
                    "MAX" => {
                        # MAX(expr) OVER (...): partition max
                        values = self.compute_aggregate_window(partition, spec, "MAX", args)?;
                    },
                    _ => {
                        return Result.Err(VaisError.new(
                            "VAIS-E0106002",
                            "Unknown window function: {name}"
                        ));
                    },
                }
            },
            _ => {
                return Result.Err(VaisError.new(
                    "VAIS-E0106003",
                    "Invalid window specification: expected FunctionCall"
                ));
            },
        }

        Result.Ok(values)
    }

    # Compute RANK or DENSE_RANK values
    F compute_rank(
        self,
        partition: &Partition,
        spec: &WindowSpec,
        dense: bool,
    ) -> Result<Vec<SqlValue>, VaisError> {
        ~values = Vec.with_capacity(partition.rows.len());
        ~current_rank = 1i64;
        ~dense_rank = 1i64;
        ~prev_sort_key: Option<Vec<SqlValue>> = Option.None;

        for i in 0..partition.rows.len() {
            ~row = &partition.rows[i];

            # Evaluate ORDER BY expressions to get sort key
            ~sort_key = Vec.new();
            for order_item in &spec.order_by {
                ~val = eval_expr(&order_item.expr, row, &self.eval_ctx)?;
                sort_key.push(val);
            }

            # Check if sort key changed (tie detection)
            ~is_tie = M &prev_sort_key {
                Option.None => false,  # First row, no tie
                Option.Some(prev_key) => {
                    # Compare all sort key values
                    ~same = true;
                    for j in 0..sort_key.len() {
                        M sort_key[j].compare(&prev_key[j]) {
                            Result.Ok(0) => {},  # Equal, continue
                            _ => {
                                same = false;
                                break;
                            },
                        }
                    }
                    same
                },
            };

            if !is_tie && i > 0 {
                # Sort key changed, update ranks
                if dense {
                    dense_rank += 1;
                } else {
                    current_rank = (i + 1) as i64;
                }
            }

            # Assign rank
            ~rank_value = if dense { dense_rank } else { current_rank };
            values.push(SqlValue.IntVal { v: rank_value });

            # Remember this sort key for next iteration
            prev_sort_key = Option.Some(sort_key);
        }

        Result.Ok(values)
    }

    # Compute aggregate window functions (SUM, AVG, COUNT, MIN, MAX)
    F compute_aggregate_window(
        self,
        partition: &Partition,
        spec: &WindowSpec,
        func_name: &str,
        args: &Vec<Expr>,
    ) -> Result<Vec<SqlValue>, VaisError> {
        ~values = Vec.with_capacity(partition.rows.len());

        # For running aggregates, we accumulate values row-by-row
        # For partition-wide aggregates (no ORDER BY), compute once and reuse
        ~has_order_by = !spec.order_by.is_empty();

        if has_order_by {
            # Running aggregate: accumulate as we go
            M func_name {
                "SUM" => {
                    ~acc: Option<SqlValue> = Option.None;
                    for row in &partition.rows {
                        ~arg_val = self.eval_agg_arg(&args, row)?;
                        acc = agg_sum(&acc, &arg_val)?;
                        ~result = M &acc {
                            Option.Some(v) => v.clone(),
                            Option.None => SqlValue.Null,
                        };
                        values.push(result);
                    }
                },
                "AVG" => {
                    ~sum: Option<SqlValue> = Option.None;
                    ~count = 0u64;
                    for row in &partition.rows {
                        ~arg_val = self.eval_agg_arg(&args, row)?;
                        ~result_tuple = agg_avg_accumulate(&sum, &count, &arg_val)?;
                        sum = result_tuple.0;
                        count = result_tuple.1;
                        ~avg = agg_avg_finalize(&sum, count)?;
                        values.push(avg);
                    }
                },
                "COUNT" => {
                    ~count = 0u64;
                    for row in &partition.rows {
                        ~arg_val = self.eval_agg_arg(&args, row)?;
                        if agg_count_value(&arg_val) {
                            count += 1;
                        }
                        values.push(SqlValue.IntVal { v: count as i64 });
                    }
                },
                "MIN" => {
                    ~acc: Option<SqlValue> = Option.None;
                    for row in &partition.rows {
                        ~arg_val = self.eval_agg_arg(&args, row)?;
                        acc = agg_min(&acc, &arg_val)?;
                        ~result = M &acc {
                            Option.Some(v) => v.clone(),
                            Option.None => SqlValue.Null,
                        };
                        values.push(result);
                    }
                },
                "MAX" => {
                    ~acc: Option<SqlValue> = Option.None;
                    for row in &partition.rows {
                        ~arg_val = self.eval_agg_arg(&args, row)?;
                        acc = agg_max(&acc, &arg_val)?;
                        ~result = M &acc {
                            Option.Some(v) => v.clone(),
                            Option.None => SqlValue.Null,
                        };
                        values.push(result);
                    }
                },
                _ => {
                    return Result.Err(VaisError.new(
                        "VAIS-E0106002",
                        "Unknown aggregate function: {func_name}"
                    ));
                },
            }
        } else {
            # Partition-wide aggregate: compute once, replicate to all rows
            ~final_value = M func_name {
                "SUM" => {
                    ~acc: Option<SqlValue> = Option.None;
                    for row in &partition.rows {
                        ~arg_val = self.eval_agg_arg(&args, row)?;
                        acc = agg_sum(&acc, &arg_val)?;
                    }
                    M acc {
                        Option.Some(v) => v,
                        Option.None => SqlValue.Null,
                    }
                },
                "AVG" => {
                    ~sum: Option<SqlValue> = Option.None;
                    ~count = 0u64;
                    for row in &partition.rows {
                        ~arg_val = self.eval_agg_arg(&args, row)?;
                        ~result_tuple = agg_avg_accumulate(&sum, &count, &arg_val)?;
                        sum = result_tuple.0;
                        count = result_tuple.1;
                    }
                    agg_avg_finalize(&sum, count)?
                },
                "COUNT" => {
                    ~count = 0u64;
                    for row in &partition.rows {
                        ~arg_val = self.eval_agg_arg(&args, row)?;
                        if agg_count_value(&arg_val) {
                            count += 1;
                        }
                    }
                    SqlValue.IntVal { v: count as i64 }
                },
                "MIN" => {
                    ~acc: Option<SqlValue> = Option.None;
                    for row in &partition.rows {
                        ~arg_val = self.eval_agg_arg(&args, row)?;
                        acc = agg_min(&acc, &arg_val)?;
                    }
                    M acc {
                        Option.Some(v) => v,
                        Option.None => SqlValue.Null,
                    }
                },
                "MAX" => {
                    ~acc: Option<SqlValue> = Option.None;
                    for row in &partition.rows {
                        ~arg_val = self.eval_agg_arg(&args, row)?;
                        acc = agg_max(&acc, &arg_val)?;
                    }
                    M acc {
                        Option.Some(v) => v,
                        Option.None => SqlValue.Null,
                    }
                },
                _ => {
                    return Result.Err(VaisError.new(
                        "VAIS-E0106002",
                        "Unknown aggregate function: {func_name}"
                    ));
                },
            };

            # Replicate final value to all rows
            for _ in 0..partition.rows.len() {
                values.push(final_value.clone());
            }
        }

        Result.Ok(values)
    }

    # Evaluate aggregate argument expression (handle COUNT(*) specially)
    F eval_agg_arg(self, args: &Vec<Expr>, row: &Row) -> Result<SqlValue, VaisError> {
        if args.is_empty() {
            # COUNT(*) case
            Result.Ok(SqlValue.IntVal { v: 1 })
        } else {
            M &args[0] {
                Expr.Star => Result.Ok(SqlValue.IntVal { v: 1 }),  # COUNT(*)
                _ => eval_expr(&args[0], row, &self.eval_ctx),
            }
        }
    }

    # Augment rows with computed window values (append as new column)
    F augment_rows_with_window_values(
        self,
        rows: Vec<Row>,
        window_values: &Vec<SqlValue>,
    ) -> Vec<Row> {
        ~augmented = Vec.with_capacity(rows.len());

        for i in 0..rows.len() {
            ~row = &rows[i];
            ~new_values = row.values.clone();
            new_values.push(window_values[i].clone());
            augmented.push(Row.new(new_values));
        }

        augmented
    }
}
