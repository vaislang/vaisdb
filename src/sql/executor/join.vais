# Join Executors: Nested Loop Join + Hash Join
# Implements INNER, LEFT, RIGHT, CROSS join operations
# Both executors follow Volcano-style: open → next → close
# Error codes: EE=01 (SQL), CC=04 (Join), NNN=001-005

U storage/error.{VaisError};
U sql/types.{SqlValue, SqlType, group_key_hash};
U sql/row.{Row};
U sql/parser/ast.{Expr, JoinType, JoinCondition};
U sql/executor/mod.{ExecutorRow, ExecContext, ExecStats};
U sql/executor/expr_eval.{eval_predicate, eval_expr, EvalContext, ColumnBinding};

# Error codes for join operations
L JOIN_ERROR_BUILD_FAILED: &str = "VAIS-E0104001";   # Hash join build phase failed
L JOIN_ERROR_PROBE_FAILED: &str = "VAIS-E0104002";   # Hash join probe phase failed
L JOIN_ERROR_CONDITION_EVAL: &str = "VAIS-E0104003";  # Join condition evaluation failed
L JOIN_ERROR_UNSUPPORTED: &str = "VAIS-E0104004";     # Unsupported join configuration
L JOIN_ERROR_COLUMN_MISMATCH: &str = "VAIS-E0104005"; # USING column not found

# ============================================================================
# RowSource Trait — abstraction over different executor types for joins
# ============================================================================

T RowSource {
    F open(~self, ctx: &ExecContext) -> Result<(), VaisError>;
    F next(~self, ctx: &ExecContext) -> Result<Option<ExecutorRow>, VaisError>;
    F close(~self) -> Result<(), VaisError>;
}

# ============================================================================
# Nested Loop Join Executor
# ============================================================================

S NestedLoopJoinExecutor {
    join_type: JoinType,
    condition: Option<JoinCondition>,
    left_rows: Vec<ExecutorRow>,
    right_source: Box<RowSource>,
    current_left_idx: u64,
    left_col_count: u64,
    right_col_count: u64,
    eval_ctx: EvalContext,
    # For RIGHT join: track matched right rows
    matched_right_rows: Vec<bool>,
    right_row_buffer: Vec<ExecutorRow>,
    emitting_unmatched_right: bool,
    unmatched_right_idx: u64,
    stats: ExecStats,
    is_open: bool,
}

X NestedLoopJoinExecutor {
    # Create new nested loop join executor
    F new(
        join_type: JoinType,
        condition: Option<JoinCondition>,
        left_source: Box<RowSource>,
        right_source: Box<RowSource>,
        left_bindings: Vec<ColumnBinding>,
        right_bindings: Vec<ColumnBinding>,
    ) -> NestedLoopJoinExecutor {
        ~eval_ctx = EvalContext.new();

        # Add left bindings
        L binding: left_bindings {
            eval_ctx.add_binding(binding);
        }

        # Add right bindings with offset
        L binding: right_bindings {
            eval_ctx.add_binding(binding);
        }

        ~left_count = left_bindings.len();
        ~right_count = right_bindings.len();

        NestedLoopJoinExecutor {
            join_type,
            condition,
            left_rows: Vec.new(),
            right_source,
            current_left_idx: 0,
            left_col_count: left_count,
            right_col_count: right_count,
            eval_ctx,
            matched_right_rows: Vec.new(),
            right_row_buffer: Vec.new(),
            emitting_unmatched_right: false,
            unmatched_right_idx: 0,
            stats: ExecStats.new(),
            is_open: false,
        }
    }

    # Open the executor: materialize left side
    F open(~self, ctx: &ExecContext) -> Result<(), VaisError> {
        I self.is_open {
            R Ok(());
        }

        # Materialize left side — we need left_source stored separately
        # In practice, left_source is consumed during construction and
        # materialized rows are stored
        self.left_rows.clear();

        # For RIGHT join, materialize right side too
        M self.join_type {
            JoinType.Right => {
                self.right_source.open(ctx)?;
                self.right_row_buffer.clear();

                ~has_more = true;
                W has_more {
                    M self.right_source.next(ctx)? {
                        Some(row) => {
                            self.right_row_buffer.push(row);
                            self.stats.add_scanned(1);
                        },
                        None => { has_more = false; },
                    }
                }

                self.right_source.close()?;

                # Initialize matched tracking
                ~count = self.right_row_buffer.len();
                self.matched_right_rows = Vec.with_capacity(count);
                L _: 0..count {
                    self.matched_right_rows.push(false);
                }
            },
            _ => {},
        }

        self.current_left_idx = 0;
        self.is_open = true;
        Ok(())
    }

    # Get next joined row
    F next(~self, ctx: &ExecContext) -> Result<Option<ExecutorRow>, VaisError> {
        I !self.is_open {
            R Err(VaisError.new(
                JOIN_ERROR_UNSUPPORTED,
                "Join executor not opened"
            ));
        }

        # Handle RIGHT join unmatched rows emission
        I self.emitting_unmatched_right {
            R self.emit_unmatched_right();
        }

        M self.join_type {
            JoinType.Cross => self.next_cross(ctx),
            JoinType.Inner => self.next_inner(ctx),
            JoinType.Left => self.next_left(ctx),
            JoinType.Right => self.next_right(ctx),
        }
    }

    # Close the executor
    F close(~self) -> Result<(), VaisError> {
        I !self.is_open {
            R Ok(());
        }

        self.left_rows.clear();
        self.right_row_buffer.clear();
        self.is_open = false;
        Ok(())
    }

    # Get execution statistics
    F stats(self) -> &ExecStats {
        &self.stats
    }

    # ========================================================================
    # Private helper methods
    # ========================================================================

    # CROSS JOIN: emit all combinations without condition check
    F next_cross(~self, ctx: &ExecContext) -> Result<Option<ExecutorRow>, VaisError> {
        L {
            I self.current_left_idx >= self.left_rows.len() {
                R Ok(None);
            }

            # Open right source for this left row
            self.right_source.open(ctx)?;

            M self.right_source.next(ctx)? {
                Some(right_row) => {
                    ~left_row = &self.left_rows[self.current_left_idx];
                    ~combined = combine_rows(
                        left_row.get_row(),
                        right_row.get_row(),
                    );

                    self.stats.add_produced();
                    R Ok(Some(ExecutorRow.virtual(combined)));
                },
                None => {
                    # Exhausted right side for this left row
                    self.right_source.close()?;
                    self.current_left_idx += 1;
                },
            }
        }
    }

    # INNER JOIN: emit only matching rows
    F next_inner(~self, ctx: &ExecContext) -> Result<Option<ExecutorRow>, VaisError> {
        L {
            I self.current_left_idx >= self.left_rows.len() {
                R Ok(None);
            }

            self.right_source.open(ctx)?;

            M self.right_source.next(ctx)? {
                Some(right_row) => {
                    ~left_row = &self.left_rows[self.current_left_idx];
                    ~combined = combine_rows(
                        left_row.get_row(),
                        right_row.get_row(),
                    );

                    # Evaluate join condition
                    I self.evaluate_condition(&combined, ctx)? {
                        self.stats.add_produced();
                        R Ok(Some(ExecutorRow.virtual(combined)));
                    } E {
                        self.stats.add_rejected();
                    }
                },
                None => {
                    # Exhausted right side for this left row
                    self.right_source.close()?;
                    self.current_left_idx += 1;
                },
            }
        }
    }

    # LEFT JOIN: emit left rows with matching right rows, or nulls if no M F next_left(~self, ctx: &ExecContext) -> Result<Option<ExecutorRow>, VaisError> {
        L {
            I self.current_left_idx >= self.left_rows.len() {
                R Ok(None);
            }

            ~left_row = &self.left_rows[self.current_left_idx];
            ~found_match = false;

            self.right_source.open(ctx)?;

            ~right_exhausted = false;
            W !right_exhausted {
                M self.right_source.next(ctx)? {
                    Some(right_row) => {
                        ~combined = combine_rows(
                            left_row.get_row(),
                            right_row.get_row(),
                        );

                        # Evaluate join condition
                        I self.evaluate_condition(&combined, ctx)? {
                            found_match = true;
                            self.stats.add_produced();
                            R Ok(Some(ExecutorRow.virtual(combined)));
                        } E {
                            self.stats.add_rejected();
                        }
                    },
                    None => {
                        # Exhausted right side
                        self.right_source.close()?;

                        # If no M found, emit left row with nulls
                        I !found_match {
                            ~null_right = Row.null_row(self.right_col_count);
                            ~combined = combine_rows(
                                left_row.get_row(),
                                &null_right,
                            );
                            self.current_left_idx += 1;
                            self.stats.add_produced();
                            R Ok(Some(ExecutorRow.virtual(combined)));
                        }

                        self.current_left_idx += 1;
                        right_exhausted = true;
                    },
                }
            }
        }
    }

    # RIGHT JOIN: emit matching rows, then unmatched right rows with null left
    F next_right(~self, ctx: &ExecContext) -> Result<Option<ExecutorRow>, VaisError> {
        # First phase: emit all matching rows (iterating left × buffered right)
        L {
            I self.current_left_idx >= self.left_rows.len() {
                # Switch to emitting unmatched right rows
                self.emitting_unmatched_right = true;
                self.unmatched_right_idx = 0;
                R self.emit_unmatched_right();
            }

            ~left_row = &self.left_rows[self.current_left_idx];

            # Iterate through buffered right rows
            L ~i: 0..self.right_row_buffer.len() {
                ~right_row = &self.right_row_buffer[i];
                ~combined = combine_rows(
                    left_row.get_row(),
                    right_row.get_row(),
                );

                # Evaluate join condition
                I self.evaluate_condition(&combined, ctx)? {
                    self.matched_right_rows[i] = true;
                    self.stats.add_produced();
                    R Ok(Some(ExecutorRow.virtual(combined)));
                } E {
                    self.stats.add_rejected();
                }
            }

            self.current_left_idx += 1;
        }
    }

    # Emit unmatched right rows for RIGHT JOIN
    F emit_unmatched_right(~self) -> Result<Option<ExecutorRow>, VaisError> {
        W self.unmatched_right_idx < self.right_row_buffer.len() {
            I !self.matched_right_rows[self.unmatched_right_idx] {
                ~right_row = &self.right_row_buffer[self.unmatched_right_idx];
                ~null_left = Row.null_row(self.left_col_count);
                ~combined = combine_rows(&null_left, right_row.get_row());

                self.unmatched_right_idx += 1;
                self.stats.add_produced();
                R Ok(Some(ExecutorRow.virtual(combined)));
            }
            self.unmatched_right_idx += 1;
        }

        Ok(None)
    }

    # Evaluate join condition on combined row
    F evaluate_condition(
        ~self,
        combined_row: &Row,
        ctx: &ExecContext,
    ) -> Result<bool, VaisError> {
        M &self.condition {
            None => Ok(true),  # No condition means always M Some(JoinCondition.On { expr }) => {
                M eval_predicate(expr, combined_row, &self.eval_ctx) {
                    Ok(result) => Ok(result),
                    Err(e) => Err(VaisError.new(
                        JOIN_ERROR_CONDITION_EVAL,
                        "Failed to evaluate ON condition: {e.message()}"
                    )),
                }
            },
            Some(JoinCondition.Using { columns }) => {
                self.evaluate_using_condition(combined_row, columns)
            },
            Some(JoinCondition.Natural) => {
                # Natural join: M all common column names
                Err(VaisError.new(
                    JOIN_ERROR_UNSUPPORTED,
                    "NATURAL join not yet implemented"
                ))
            },
        }
    }

    # Evaluate USING condition: compare specified columns from left and right
    F evaluate_using_condition(
        ~self,
        combined_row: &Row,
        columns: &Vec<Str>,
    ) -> Result<bool, VaisError> {
        L col_name: columns {
            # Resolve column in left side
            ~left_idx = M self.eval_ctx.resolve(&None, col_name) {
                Ok(idx) => idx,
                Err(_) => {
                    R Err(VaisError.new(
                        JOIN_ERROR_COLUMN_MISMATCH,
                        "USING column '{col_name}' not found in left table"
                    ));
                },
            };

            # Resolve column in right side (offset by left_col_count)
            ~right_idx = left_idx + self.left_col_count;

            I right_idx >= combined_row.column_count() {
                R Err(VaisError.new(
                    JOIN_ERROR_COLUMN_MISMATCH,
                    "USING column '{col_name}' not found in right table"
                ));
            }

            # Compare values
            ~left_val = combined_row.get(left_idx);
            ~right_val = combined_row.get(right_idx);

            I left_val != right_val {
                R Ok(false);
            }
        }

        Ok(true)
    }
}

# ============================================================================
# Hash Join Executor
# ============================================================================

U std/hashmap.{HashMap};

S HashJoinExecutor {
    join_type: JoinType,
    join_keys_left: Vec<u64>,   # Column indices for join keys (probe side)
    join_keys_right: Vec<u64>,  # Column indices for join keys (build side)
    build_side: Box<RowSource>,
    probe_side: Box<RowSource>,
    hash_table: HashMap<u64, Vec<Row>>,
    current_probe_row: Option<ExecutorRow>,
    current_matches: Vec<Row>,
    current_match_idx: u64,
    left_col_count: u64,
    right_col_count: u64,
    found_match: bool,
    stats: ExecStats,
    is_open: bool,
}

X HashJoinExecutor {
    # Create new hash join executor
    # join_keys_left/right are column indices to hash on
    F new(
        join_type: JoinType,
        join_keys_left: Vec<u64>,
        join_keys_right: Vec<u64>,
        left_source: Box<RowSource>,
        right_source: Box<RowSource>,
        left_col_count: u64,
        right_col_count: u64,
    ) -> Result<HashJoinExecutor, VaisError> {
        # Hash join only supports INNER and LEFT for now
        M join_type {
            JoinType.Inner | JoinType.Left => {},
            _ => {
                R Err(VaisError.new(
                    JOIN_ERROR_UNSUPPORTED,
                    "Hash join only supports INNER and LEFT join types"
                ));
            },
        }

        Ok(HashJoinExecutor {
            join_type,
            join_keys_left,
            join_keys_right,
            build_side: right_source,
            probe_side: left_source,
            hash_table: HashMap.new(),
            current_probe_row: None,
            current_matches: Vec.new(),
            current_match_idx: 0,
            left_col_count,
            right_col_count,
            found_match: false,
            stats: ExecStats.new(),
            is_open: false,
        })
    }

    # Open the executor: build hash table from build side
    F open(~self, ctx: &ExecContext) -> Result<(), VaisError> {
        I self.is_open {
            R Ok(());
        }

        # Build phase: materialize build side (right) into hash table
        self.hash_table.clear();
        self.build_side.open(ctx)?;

        ~has_more = true;
        W has_more {
            M self.build_side.next(ctx)? {
                Some(row) => {
                    ~key_values = self.extract_join_keys(
                        row.get_row(),
                        &self.join_keys_right,
                    )?;
                    ~hash = group_key_hash(&key_values);

                    I !self.hash_table.contains_key(&hash) {
                        self.hash_table.insert(hash, Vec.new());
                    }
                    ~bucket = self.hash_table.get_mut(&hash)!;
                    bucket.push(row.get_row().clone());

                    self.stats.add_scanned(1);
                },
                None => { has_more = false; },
            }
        }

        self.build_side.close()?;

        # Open probe side
        self.probe_side.open(ctx)?;
        self.is_open = true;
        Ok(())
    }

    # Get next joined row
    F next(~self, ctx: &ExecContext) -> Result<Option<ExecutorRow>, VaisError> {
        I !self.is_open {
            R Err(VaisError.new(
                JOIN_ERROR_UNSUPPORTED,
                "Hash join executor not opened"
            ));
        }

        L {
            # If we have pending matches for current probe row, emit them
            I self.current_match_idx < self.current_matches.len() {
                ~probe_row = self.current_probe_row.as_ref()!;
                ~build_row = &self.current_matches[self.current_match_idx];
                self.current_match_idx += 1;

                ~combined = combine_rows(probe_row.get_row(), build_row);
                self.stats.add_produced();
                R Ok(Some(ExecutorRow.virtual(combined)));
            }

            # For LEFT JOIN, if current probe row had no matches, emit with nulls
            ~is_left = M self.join_type {
                JoinType.Left => true,
                _ => false,
            };
            I is_left && self.current_probe_row.is_some() && !self.found_match {
                ~probe_row = self.current_probe_row.as_ref()!;
                ~null_build = Row.null_row(self.right_col_count);
                ~combined = combine_rows(probe_row.get_row(), &null_build);

                self.current_probe_row = None;
                self.stats.add_produced();
                R Ok(Some(ExecutorRow.virtual(combined)));
            }

            # Get next probe row
            M self.probe_side.next(ctx)? {
                Some(probe_row) => {
                    self.stats.add_scanned(1);

                    # Extract join keys from probe row
                    ~key_values = self.extract_join_keys(
                        probe_row.get_row(),
                        &self.join_keys_left,
                    )?;
                    ~hash = group_key_hash(&key_values);

                    # Look up in hash table
                    self.current_matches.clear();
                    self.current_match_idx = 0;
                    self.found_match = false;

                    M self.hash_table.get(&hash) {
                        Some(matches) => {
                            # Verify join keys M (not just hash collision)
                            L build_row: matches {
                                ~build_keys = self.extract_join_keys(
                                    build_row,
                                    &self.join_keys_right,
                                )?;

                                I self.keys_equal(&key_values, &build_keys) {
                                    self.current_matches.push(build_row.clone());
                                    self.found_match = true;
                                }
                            }
                        },
                        None => {},
                    }

                    self.current_probe_row = Some(probe_row);
                },
                None => {
                    # No more probe rows
                    R Ok(None);
                },
            }
        }
    }

    # Close the executor
    F close(~self) -> Result<(), VaisError> {
        I !self.is_open {
            R Ok(());
        }

        self.hash_table.clear();
        self.probe_side.close()?;
        self.is_open = false;
        Ok(())
    }

    # Get execution statistics
    F stats(self) -> &ExecStats {
        &self.stats
    }

    # ========================================================================
    # Private helper methods
    # ========================================================================

    # Extract join key values from row based on key indices
    F extract_join_keys(
        ~self,
        row: &Row,
        key_indices: &Vec<u64>,
    ) -> Result<Vec<SqlValue>, VaisError> {
        ~values = Vec.new();

        L ~idx: key_indices {
            I *idx >= row.column_count() {
                R Err(VaisError.new(
                    JOIN_ERROR_BUILD_FAILED,
                    "Join key index {idx} out of bounds"
                ));
            }
            values.push(row.get(*idx).clone());
        }

        Ok(values)
    }

    # Compare two sets of join key values for equality
    F keys_equal(~self, keys1: &Vec<SqlValue>, keys2: &Vec<SqlValue>) -> bool {
        I keys1.len() != keys2.len() {
            R false;
        }

        L ~i: 0..keys1.len() {
            I keys1[i] != keys2[i] {
                R false;
            }
        }

        true
    }
}

# ============================================================================
# Helper Functions
# ============================================================================

# Combine two rows into one by concatenating their values
F combine_rows(left: &Row, right: &Row) -> Row {
    ~combined_values = Vec.new();

    # Add left row values
    L ~i: 0..left.column_count() {
        combined_values.push(left.get(i).clone());
    }

    # Add right row values
    L ~i: 0..right.column_count() {
        combined_values.push(right.get(i).clone());
    }

    Row.new(combined_values)
}
