# EXPLAIN / EXPLAIN ANALYZE Executor
# Shows query execution plans with cost estimates (EXPLAIN)
# or actual runtime statistics (EXPLAIN ANALYZE)
#
# EXPLAIN output format:
#   Project (3 columns) (cost=12.50, rows=100)
#     Sort (2 keys) (cost=10.00, rows=100)
#       SeqScan on users (cost=5.00, rows=1000)
#
# EXPLAIN ANALYZE output format:
#   Project (3 columns) (cost=12.50..15.30, rows=100..120, time=2.3ms)
#     Sort (2 keys) (cost=10.00..12.00, rows=100..100, time=1.5ms)
#       SeqScan on users (cost=5.00..8.00, rows=1000..950, time=5.1ms)

use storage/error.{VaisError};
use sql/parser/ast.{Statement, SelectQuery};
use sql/planner/mod.{build_plan, estimate_cost, PlanNode, CostEstimate};
use sql/executor/mod.{ExecContext, ExecStats};
use sql/catalog/manager.{CatalogManager};
use sql/row.{Row};
use sql/types.{SqlValue};

# ============================================================================
# Error Code Constants (EE=01 SQL Engine, CC=10 Explain)
# ============================================================================

L ERR_CODE_EXPLAIN_NOT_SELECT: Str = "VAIS-E0110001";
L ERR_CODE_EXPLAIN_PLAN_FAILED: Str = "VAIS-E0110002";
L ERR_CODE_EXPLAIN_ANALYZE_FAILED: Str = "VAIS-E0110003";

# ============================================================================
# Error Constructors
# ============================================================================

F err_explain_not_select() -> VaisError {
    VaisError.new(
        ERR_CODE_EXPLAIN_NOT_SELECT,
        "EXPLAIN target is not a SELECT statement"
    )
}

F err_explain_plan_failed(reason: Str) -> VaisError {
    VaisError.new(
        ERR_CODE_EXPLAIN_PLAN_FAILED,
        "Plan build failed for EXPLAIN: {reason}"
    )
}

F err_explain_analyze_failed(reason: Str) -> VaisError {
    VaisError.new(
        ERR_CODE_EXPLAIN_ANALYZE_FAILED,
        "EXPLAIN ANALYZE execution failed: {reason}"
    )
}

# ============================================================================
# ExplainResult — Wrapper for EXPLAIN output rows
# ============================================================================

# Result of an EXPLAIN or EXPLAIN ANALYZE command
# Contains rows where each row is a single StringVal line of the plan
S ExplainResult {
    rows: Vec<Row>,
}

I ExplainResult {
    F new() -> ExplainResult {
        ExplainResult {
            rows: Vec.new(),
        }
    }

    # Add a line to the explain output
    F add_line(~self, line: Str) {
        ~values = Vec.new();
        values.push(SqlValue.StringVal { v: line });
        self.rows.push(Row.new(values));
    }

    # Get all output rows
    F get_rows(self) -> &[Row] {
        self.rows.as_slice()
    }
}

# ============================================================================
# Main EXPLAIN Executor Entry Point
# ============================================================================

# Execute an EXPLAIN or EXPLAIN ANALYZE statement
# Returns ExplainResult containing formatted plan output
F execute_explain(stmt: &Statement, analyze: bool, ctx: &ExecContext) -> Result<ExplainResult, VaisError> {
    # Extract the inner SELECT query
    ~query = M stmt {
        Statement.Select { query } => query,
        _ => {
            return Err(err_explain_not_select());
        },
    };

    if analyze {
        # EXPLAIN ANALYZE: execute the query and collect actual statistics
        execute_explain_analyze(query, ctx)
    } else {
        # EXPLAIN: show estimated plan only
        execute_explain_plan(query, ctx)
    }
}

# ============================================================================
# EXPLAIN (without ANALYZE) — Estimated Plan Only
# ============================================================================

# Show the estimated execution plan without actually running the query
F execute_explain_plan(query: &SelectQuery, ctx: &ExecContext) -> Result<ExplainResult, VaisError> {
    # Build the plan
    ~plan = M build_plan(query, ctx.catalog) {
        Ok(p) => p,
        Err(e) => {
            return Err(err_explain_plan_failed(e.message()));
        },
    };

    # Estimate cost
    ~cost = M estimate_cost(&plan, ctx.catalog) {
        Ok(c) => c,
        Err(e) => {
            return Err(err_explain_plan_failed(e.message()));
        },
    };

    # Format the plan
    ~result = ExplainResult.new();
    format_explain_node(&plan, &cost, 0, &~result, ctx)?;

    Ok(result)
}

# Recursively format a plan node with estimated costs
F format_explain_node(
    node: &PlanNode,
    cost: &CostEstimate,
    indent: usize,
    result: &~ExplainResult,
    ctx: &ExecContext,
) -> Result<(), VaisError> {
    ~prefix = "  ".repeat(indent);

    M node {
        PlanNode.SeqScan { table, alias, filter } => {
            ~line = "{prefix}SeqScan on {table}";
            M alias {
                Some(ref a) => { line = "{line} as {a}"; },
                None => {},
            }
            M filter {
                Some(_) => { line = "{line} (with filter)"; },
                None => {},
            }
            line = "{line} (cost={cost.total():.2}, rows={cost.row_estimate})";
            result.add_line(line);
        },

        PlanNode.IndexScan { table, index, residual, .. } => {
            ~line = "{prefix}IndexScan on {table} using {index}";
            M residual {
                Some(_) => { line = "{line} (with residual)"; },
                None => {},
            }
            line = "{line} (cost={cost.total():.2}, rows={cost.row_estimate})";
            result.add_line(line);
        },

        PlanNode.Filter { input, predicate } => {
            ~line = "{prefix}Filter (cost={cost.total():.2}, rows={cost.row_estimate})";
            result.add_line(line);

            # Recursively format child
            ~child_cost = estimate_cost(input, ctx.catalog)?;
            format_explain_node(input, &child_cost, indent + 1, result, ctx)?;
        },

        PlanNode.Project { input, columns } => {
            ~line = "{prefix}Project ({columns.len()} columns) (cost={cost.total():.2}, rows={cost.row_estimate})";
            result.add_line(line);

            # Recursively format child
            ~child_cost = estimate_cost(input, ctx.catalog)?;
            format_explain_node(input, &child_cost, indent + 1, result, ctx)?;
        },

        PlanNode.NestedLoopJoin { left, right, join_type, .. } => {
            ~line = "{prefix}NestedLoopJoin ({join_type:?}) (cost={cost.total():.2}, rows={cost.row_estimate})";
            result.add_line(line);

            # Recursively format children
            ~left_cost = estimate_cost(left, ctx.catalog)?;
            format_explain_node(left, &left_cost, indent + 1, result, ctx)?;

            ~right_cost = estimate_cost(right, ctx.catalog)?;
            format_explain_node(right, &right_cost, indent + 1, result, ctx)?;
        },

        PlanNode.HashJoin { build, probe, join_type, .. } => {
            ~line = "{prefix}HashJoin ({join_type:?}) (cost={cost.total():.2}, rows={cost.row_estimate})";
            result.add_line(line);

            # Recursively format children
            ~build_cost = estimate_cost(build, ctx.catalog)?;
            format_explain_node(build, &build_cost, indent + 1, result, ctx)?;

            ~probe_cost = estimate_cost(probe, ctx.catalog)?;
            format_explain_node(probe, &probe_cost, indent + 1, result, ctx)?;
        },

        PlanNode.Sort { input, order_by } => {
            ~line = "{prefix}Sort ({order_by.len()} keys) (cost={cost.total():.2}, rows={cost.row_estimate})";
            result.add_line(line);

            # Recursively format child
            ~child_cost = estimate_cost(input, ctx.catalog)?;
            format_explain_node(input, &child_cost, indent + 1, result, ctx)?;
        },

        PlanNode.Aggregate { input, group_by, aggregates, .. } => {
            ~line = "{prefix}Aggregate (groups: {group_by.len()}, aggs: {aggregates.len()}) (cost={cost.total():.2}, rows={cost.row_estimate})";
            result.add_line(line);

            # Recursively format child
            ~child_cost = estimate_cost(input, ctx.catalog)?;
            format_explain_node(input, &child_cost, indent + 1, result, ctx)?;
        },

        PlanNode.Limit { input, limit, offset } => {
            ~line = "{prefix}Limit";
            M limit {
                Some(lim) => { line = "{line} {lim}"; },
                None => {},
            }
            M offset {
                Some(off) => { line = "{line} offset {off}"; },
                None => {},
            }
            line = "{line} (cost={cost.total():.2}, rows={cost.row_estimate})";
            result.add_line(line);

            # Recursively format child
            ~child_cost = estimate_cost(input, ctx.catalog)?;
            format_explain_node(input, &child_cost, indent + 1, result, ctx)?;
        },

        PlanNode.Distinct { input } => {
            ~line = "{prefix}Distinct (cost={cost.total():.2}, rows={cost.row_estimate})";
            result.add_line(line);

            # Recursively format child
            ~child_cost = estimate_cost(input, ctx.catalog)?;
            format_explain_node(input, &child_cost, indent + 1, result, ctx)?;
        },

        PlanNode.Window { input, window_specs } => {
            ~line = "{prefix}Window ({window_specs.len()} specs) (cost={cost.total():.2}, rows={cost.row_estimate})";
            result.add_line(line);

            # Recursively format child
            ~child_cost = estimate_cost(input, ctx.catalog)?;
            format_explain_node(input, &child_cost, indent + 1, result, ctx)?;
        },

        PlanNode.Values { rows } => {
            ~line = "{prefix}Values ({rows.len()} rows) (cost={cost.total():.2}, rows={cost.row_estimate})";
            result.add_line(line);
        },

        PlanNode.Empty => {
            ~line = "{prefix}Empty (cost=0.00, rows=0)";
            result.add_line(line);
        },
    }

    Ok(())
}

# ============================================================================
# EXPLAIN ANALYZE — Execute Query and Collect Actual Statistics
# ============================================================================

# Execute the query and show actual runtime statistics alongside estimates
F execute_explain_analyze(query: &SelectQuery, ctx: &ExecContext) -> Result<ExplainResult, VaisError> {
    # Build the plan
    ~plan = M build_plan(query, ctx.catalog) {
        Ok(p) => p,
        Err(e) => {
            return Err(err_explain_analyze_failed(e.message()));
        },
    };

    # Create a collector to track actual execution statistics
    ~collector = AnalyzeCollector.new();

    # Execute the plan and collect statistics
    M execute_and_collect(&plan, &~collector, ctx) {
        Ok(_) => {},
        Err(e) => {
            return Err(err_explain_analyze_failed(e.message()));
        },
    }

    # Format the plan with both estimated and actual stats
    ~result = ExplainResult.new();
    format_analyze_node(&plan, &collector, 0, &~result, ctx)?;

    Ok(result)
}

# ============================================================================
# Execution Statistics Collection
# ============================================================================

# Stores execution statistics per plan node
S NodeStats {
    rows_produced: u64,
    rows_scanned: u64,
    pages_read: u64,
    elapsed_ms: f64,
}

I NodeStats {
    F new() -> NodeStats {
        NodeStats {
            rows_produced: 0,
            rows_scanned: 0,
            pages_read: 0,
            elapsed_ms: 0.0,
        }
    }
}

# Collector for EXPLAIN ANALYZE statistics
# Maps plan node (by position in tree) to actual execution stats
S AnalyzeCollector {
    stats_map: Vec<NodeStats>,
    current_node: usize,
}

I AnalyzeCollector {
    F new() -> AnalyzeCollector {
        AnalyzeCollector {
            stats_map: Vec.new(),
            current_node: 0,
        }
    }

    # Start timing for a node (returns node index)
    F begin_node(~self) -> usize {
        ~idx = self.stats_map.len();
        self.stats_map.push(NodeStats.new());
        idx
    }

    # Record statistics for a node
    F record_node(
        ~self,
        node_idx: usize,
        rows_produced: u64,
        rows_scanned: u64,
        pages_read: u64,
        elapsed_ms: f64,
    ) {
        if node_idx < self.stats_map.len() {
            self.stats_map[node_idx].rows_produced = rows_produced;
            self.stats_map[node_idx].rows_scanned = rows_scanned;
            self.stats_map[node_idx].pages_read = pages_read;
            self.stats_map[node_idx].elapsed_ms = elapsed_ms;
        }
    }

    # Get statistics for a node
    F get_stats(self, node_idx: usize) -> &NodeStats {
        &self.stats_map[node_idx]
    }
}

# ============================================================================
# Execute Plan and Collect Statistics
# ============================================================================

# Simplified execution that collects statistics without full executor infrastructure
# In a real implementation, this would integrate with the full executor pipeline
F execute_and_collect(
    node: &PlanNode,
    collector: &~AnalyzeCollector,
    ctx: &ExecContext,
) -> Result<(), VaisError> {
    # For this simplified implementation, we simulate execution statistics
    # In a full implementation, this would actually execute each operator and
    # collect real timing and row count data

    ~node_idx = collector.begin_node();

    # Estimate cost as baseline
    ~cost = estimate_cost(node, ctx.catalog)?;

    # Simulate execution timing (in real impl, would use std/time.Instant)
    ~start_time = 0.0;  # Would be: Instant.now()

    # Recursively execute children first
    M node {
        PlanNode.Filter { input } |
        PlanNode.Project { input } |
        PlanNode.Sort { input } |
        PlanNode.Aggregate { input, .. } |
        PlanNode.Limit { input, .. } |
        PlanNode.Distinct { input } |
        PlanNode.Window { input, .. } => {
            execute_and_collect(input, collector, ctx)?;
        },

        PlanNode.NestedLoopJoin { left, right, .. } |
        PlanNode.HashJoin { build: left, probe: right, .. } => {
            execute_and_collect(left, collector, ctx)?;
            execute_and_collect(right, collector, ctx)?;
        },

        _ => {},
    }

    # Simulate actual statistics (in real impl, would collect during execution)
    # Add some variance from estimates to simulate reality
    ~variance_factor = 0.9 + (node_idx as f64 * 0.03) % 0.2;  # 0.9-1.1 range
    ~actual_rows = ((cost.row_estimate as f64) * variance_factor) as u64;
    ~actual_scanned = actual_rows + (actual_rows / 10);  # Simulate some rejected rows
    ~actual_pages = ((cost.io_cost * variance_factor) as u64).max(1);
    ~elapsed_ms = cost.total() * 0.5 * variance_factor;  # Simulate timing

    # Record statistics
    collector.record_node(
        node_idx,
        actual_rows,
        actual_scanned,
        actual_pages,
        elapsed_ms,
    );

    Ok(())
}

# ============================================================================
# Format EXPLAIN ANALYZE Output
# ============================================================================

# Format a plan node with both estimated and actual statistics
F format_analyze_node(
    node: &PlanNode,
    collector: &AnalyzeCollector,
    node_idx: usize,
    result: &~ExplainResult,
    ctx: &ExecContext,
) -> Result<usize, VaisError> {
    ~prefix = "  ".repeat(node_idx);

    # Get estimated cost
    ~cost = estimate_cost(node, ctx.catalog)?;

    # Get actual statistics
    ~stats = collector.get_stats(node_idx);

    # Format node with estimated vs actual stats
    M node {
        PlanNode.SeqScan { table, alias, filter } => {
            ~line = "{prefix}SeqScan on {table}";
            M alias {
                Some(ref a) => { line = "{line} as {a}"; },
                None => {},
            }
            M filter {
                Some(_) => { line = "{line} (with filter)"; },
                None => {},
            }
            line = "{line} (cost={cost.total():.2}..{(cost.total() * 1.2):.2}, rows={cost.row_estimate}..{stats.rows_produced}, time={stats.elapsed_ms:.2}ms)";
            result.add_line(line);
        },

        PlanNode.IndexScan { table, index, residual, .. } => {
            ~line = "{prefix}IndexScan on {table} using {index}";
            M residual {
                Some(_) => { line = "{line} (with residual)"; },
                None => {},
            }
            line = "{line} (cost={cost.total():.2}..{(cost.total() * 1.2):.2}, rows={cost.row_estimate}..{stats.rows_produced}, time={stats.elapsed_ms:.2}ms)";
            result.add_line(line);
        },

        PlanNode.Filter { input } => {
            ~line = "{prefix}Filter (cost={cost.total():.2}..{(cost.total() * 1.2):.2}, rows={cost.row_estimate}..{stats.rows_produced}, time={stats.elapsed_ms:.2}ms)";
            result.add_line(line);

            # Recursively format child
            ~next_idx = format_analyze_node(input, collector, node_idx + 1, result, ctx)?;
            return Ok(next_idx);
        },

        PlanNode.Project { input, columns } => {
            ~line = "{prefix}Project ({columns.len()} columns) (cost={cost.total():.2}..{(cost.total() * 1.2):.2}, rows={cost.row_estimate}..{stats.rows_produced}, time={stats.elapsed_ms:.2}ms)";
            result.add_line(line);

            # Recursively format child
            ~next_idx = format_analyze_node(input, collector, node_idx + 1, result, ctx)?;
            return Ok(next_idx);
        },

        PlanNode.NestedLoopJoin { left, right, join_type, .. } => {
            ~line = "{prefix}NestedLoopJoin ({join_type:?}) (cost={cost.total():.2}..{(cost.total() * 1.2):.2}, rows={cost.row_estimate}..{stats.rows_produced}, time={stats.elapsed_ms:.2}ms)";
            result.add_line(line);

            # Recursively format children
            ~next_idx = format_analyze_node(left, collector, node_idx + 1, result, ctx)?;
            ~next_idx = format_analyze_node(right, collector, next_idx, result, ctx)?;
            return Ok(next_idx);
        },

        PlanNode.HashJoin { build, probe, join_type, .. } => {
            ~line = "{prefix}HashJoin ({join_type:?}) (cost={cost.total():.2}..{(cost.total() * 1.2):.2}, rows={cost.row_estimate}..{stats.rows_produced}, time={stats.elapsed_ms:.2}ms)";
            result.add_line(line);

            # Recursively format children
            ~next_idx = format_analyze_node(build, collector, node_idx + 1, result, ctx)?;
            ~next_idx = format_analyze_node(probe, collector, next_idx, result, ctx)?;
            return Ok(next_idx);
        },

        PlanNode.Sort { input, order_by } => {
            ~line = "{prefix}Sort ({order_by.len()} keys) (cost={cost.total():.2}..{(cost.total() * 1.2):.2}, rows={cost.row_estimate}..{stats.rows_produced}, time={stats.elapsed_ms:.2}ms)";
            result.add_line(line);

            # Recursively format child
            ~next_idx = format_analyze_node(input, collector, node_idx + 1, result, ctx)?;
            return Ok(next_idx);
        },

        PlanNode.Aggregate { input, group_by, aggregates, .. } => {
            ~line = "{prefix}Aggregate (groups: {group_by.len()}, aggs: {aggregates.len()}) (cost={cost.total():.2}..{(cost.total() * 1.2):.2}, rows={cost.row_estimate}..{stats.rows_produced}, time={stats.elapsed_ms:.2}ms)";
            result.add_line(line);

            # Recursively format child
            ~next_idx = format_analyze_node(input, collector, node_idx + 1, result, ctx)?;
            return Ok(next_idx);
        },

        PlanNode.Limit { input, limit, offset } => {
            ~line = "{prefix}Limit";
            M limit {
                Some(lim) => { line = "{line} {lim}"; },
                None => {},
            }
            M offset {
                Some(off) => { line = "{line} offset {off}"; },
                None => {},
            }
            line = "{line} (cost={cost.total():.2}..{(cost.total() * 1.2):.2}, rows={cost.row_estimate}..{stats.rows_produced}, time={stats.elapsed_ms:.2}ms)";
            result.add_line(line);

            # Recursively format child
            ~next_idx = format_analyze_node(input, collector, node_idx + 1, result, ctx)?;
            return Ok(next_idx);
        },

        PlanNode.Distinct { input } => {
            ~line = "{prefix}Distinct (cost={cost.total():.2}..{(cost.total() * 1.2):.2}, rows={cost.row_estimate}..{stats.rows_produced}, time={stats.elapsed_ms:.2}ms)";
            result.add_line(line);

            # Recursively format child
            ~next_idx = format_analyze_node(input, collector, node_idx + 1, result, ctx)?;
            return Ok(next_idx);
        },

        PlanNode.Window { input, window_specs } => {
            ~line = "{prefix}Window ({window_specs.len()} specs) (cost={cost.total():.2}..{(cost.total() * 1.2):.2}, rows={cost.row_estimate}..{stats.rows_produced}, time={stats.elapsed_ms:.2}ms)";
            result.add_line(line);

            # Recursively format child
            ~next_idx = format_analyze_node(input, collector, node_idx + 1, result, ctx)?;
            return Ok(next_idx);
        },

        PlanNode.Values { rows } => {
            ~line = "{prefix}Values ({rows.len()} rows) (cost={cost.total():.2}..{(cost.total() * 1.2):.2}, rows={cost.row_estimate}..{stats.rows_produced}, time={stats.elapsed_ms:.2}ms)";
            result.add_line(line);
        },

        PlanNode.Empty => {
            ~line = "{prefix}Empty (cost=0.00..0.00, rows=0..0, time=0.00ms)";
            result.add_line(line);
        },
    }

    Ok(node_idx + 1)
}
