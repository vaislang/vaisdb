# Subquery, CTE, and Set Operations Executors
# SubqueryExecutor: materialize scalar subquery (1 row, 1 column)
# InSubqueryExecutor: IN (SELECT ...) evaluation
# ExistsExecutor: EXISTS (SELECT ...) evaluation
# CteExecutor: WITH clause CTE materialization and reference
# SetOperationExecutor: UNION, INTERSECT, EXCEPT
# Error codes: EE=01 (SQL), CC=07 (Subquery), NNN=001-005

use std/hashmap.{HashMap, HashSet};
use std/result.Result;
use std/option.Option;
use std/vec.Vec;
use std/str.Str;
use std/box.Box;

use crate/error.VaisError;
use crate/sql/types.{SqlValue, group_key_hash};
use crate/sql/row.Row;
use crate/sql/parser/ast.{SelectQuery, Expr, SetOpKind};
use crate/sql/executor/mod.{ExecutorRow, ExecStats, ExecContext};
use crate/sql/executor/expr_eval.{eval_expr, EvalContext};

# ============================================================================
# CTE Context - Shared storage for materialized CTEs
# ============================================================================

S CteContext {
    materialized: HashMap<Str, Vec<Row>>,
}

I CteContext {
    F new() -> CteContext {
        CteContext {
            materialized: HashMap.new(),
        }
    }

    F insert(~self, name: Str, rows: Vec<Row>) {
        self.materialized.insert(name, rows);
    }

    F get(self, name: &Str) -> Option<&Vec<Row>> {
        self.materialized.get(name)
    }

    F clear(~self) {
        self.materialized.clear();
    }
}

# ============================================================================
# SubqueryExecutor - Materialize scalar subquery (must return 1 row, 1 col)
# ============================================================================

# Forward declaration: we need a way to build an executor from SelectQuery
# In practice, this would be provided by the planner/builder module
# For now, we define the signature as a placeholder
T ExecutorBuilder {
    F build_select(query: &SelectQuery, ctx: &ExecContext, eval_ctx: &EvalContext, cte_ctx: &CteContext) -> Result<Box<dyn Executor>, VaisError>;
}

S SubqueryExecutor {
    child: Box<dyn Executor>,
    stats: ExecStats,
}

I SubqueryExecutor {
    F new(child: Box<dyn Executor>) -> SubqueryExecutor {
        SubqueryExecutor {
            child,
            stats: ExecStats.new(),
        }
    }

    # Evaluate the subquery and return a single scalar value
    # Errors if subquery returns more than one row
    F eval(~self) -> Result<SqlValue, VaisError> {
        self.child.open()?;

        ~result_val = SqlValue.Null;
        ~row_count = 0u64;

        L {
            M self.child.next()? {
                Option.None => { break; },
                Option.Some(exec_row) => {
                    row_count += 1;
                    self.stats.add_scanned(1);

                    if row_count > 1 {
                        self.child.close()?;
                        return Result.Err(VaisError.new(
                            "VAIS-E0107002",
                            "Scalar subquery returned more than one row"
                        ));
                    }

                    # Get first column value
                    ~row = exec_row.get_row();
                    if row.column_count() > 0 {
                        result_val = row.get(0).clone();
                    }
                },
            }
        }

        self.child.close()?;
        Result.Ok(result_val)
    }

    F stats(self) -> &ExecStats {
        &self.stats
    }
}

# ============================================================================
# Helper: Evaluate IN (SELECT ...) subquery
# ============================================================================

# Execute IN subquery and check if expr value is in the result set
F eval_in_subquery(
    expr_val: &SqlValue,
    child: &~Box<dyn Executor>,
    negated: bool,
    stats: &~ExecStats,
) -> Result<SqlValue, VaisError> {
    child.open()?;

    ~found = false;
    ~found_null = false;

    L {
        M child.next()? {
            Option.None => { break; },
            Option.Some(exec_row) => {
                stats.add_scanned(1);
                ~row = exec_row.get_row();

                if row.column_count() > 0 {
                    ~val = row.get(0);

                    # Compare using SQL equals (NULL propagation)
                    M expr_val.equals(val) {
                        SqlValue.BoolVal { v: true } => {
                            found = true;
                            break;
                        },
                        SqlValue.Null => {
                            found_null = true;
                        },
                        _ => {},
                    }
                }
            },
        }
    }

    child.close()?;

    # Result logic:
    # IN: found -> TRUE, not found but NULL seen -> NULL, not found -> FALSE
    # NOT IN: found -> FALSE, not found but NULL seen -> NULL, not found -> TRUE
    ~result = if found {
        SqlValue.BoolVal { v: !negated }
    } else if found_null {
        SqlValue.Null
    } else {
        SqlValue.BoolVal { v: negated }
    };

    Result.Ok(result)
}

# ============================================================================
# Helper: Evaluate EXISTS (SELECT ...) subquery
# ============================================================================

# Execute EXISTS subquery and check if at least one row is returned
F eval_exists(
    child: &~Box<dyn Executor>,
    negated: bool,
    stats: &~ExecStats,
) -> Result<SqlValue, VaisError> {
    child.open()?;

    ~exists = false;

    M child.next()? {
        Option.Some(_) => {
            exists = true;
            stats.add_scanned(1);
        },
        Option.None => {},
    }

    child.close()?;

    ~result = if negated {
        SqlValue.BoolVal { v: !exists }
    } else {
        SqlValue.BoolVal { v: exists }
    };

    Result.Ok(result)
}

# ============================================================================
# CteRefExecutor - Reads from materialized CTE
# ============================================================================

S CteRefExecutor {
    cte_name: Str,
    cte_ctx: &CteContext,
    materialized: Option<Vec<Row>>,
    cursor: usize,
    stats: ExecStats,
}

I CteRefExecutor {
    F new(cte_name: Str, cte_ctx: &CteContext) -> CteRefExecutor {
        CteRefExecutor {
            cte_name,
            cte_ctx,
            materialized: Option.None,
            cursor: 0,
            stats: ExecStats.new(),
        }
    }

    F open(~self) -> Result<(), VaisError> {
        # Lookup CTE by name
        M self.cte_ctx.get(&self.cte_name) {
            Option.Some(rows) => {
                self.materialized = Option.Some(rows.clone());
                self.cursor = 0;
                Result.Ok(())
            },
            Option.None => {
                Result.Err(VaisError.new(
                    "VAIS-E0107003",
                    "CTE not found: {self.cte_name}"
                ))
            },
        }
    }

    F next(~self) -> Result<Option<ExecutorRow>, VaisError> {
        M &self.materialized {
            Option.None => {
                Result.Err(VaisError.new("VAIS-E0107001", "CteRefExecutor not opened"))
            },
            Option.Some(rows) => {
                if self.cursor >= rows.len() {
                    Result.Ok(Option.None)
                } else {
                    ~row = &rows[self.cursor];
                    self.cursor += 1;
                    self.stats.add_produced();
                    self.stats.add_scanned(1);
                    Result.Ok(Option.Some(ExecutorRow.virtual(row.clone())))
                }
            },
        }
    }

    F close(~self) -> Result<(), VaisError> {
        self.materialized = Option.None;
        self.cursor = 0;
        Result.Ok(())
    }

    F stats(self) -> &ExecStats {
        &self.stats
    }
}

# ============================================================================
# SetOperationExecutor - UNION, INTERSECT, EXCEPT
# ============================================================================

S SetOperationExecutor {
    left: Box<dyn Executor>,
    right: Box<dyn Executor>,
    op_kind: SetOpKind,
    all: bool,
    materialized: Option<Vec<Row>>,
    cursor: usize,
    stats: ExecStats,
}

I SetOperationExecutor {
    F new(
        left: Box<dyn Executor>,
        right: Box<dyn Executor>,
        op_kind: SetOpKind,
        all: bool,
    ) -> SetOperationExecutor {
        SetOperationExecutor {
            left,
            right,
            op_kind,
            all,
            materialized: Option.None,
            cursor: 0,
            stats: ExecStats.new(),
        }
    }

    F open(~self) -> Result<(), VaisError> {
        M self.op_kind {
            SetOpKind.Union => {
                if self.all {
                    self.open_union_all()?;
                } else {
                    self.open_union()?;
                }
            },
            SetOpKind.Intersect => {
                self.open_intersect()?;
            },
            SetOpKind.Except => {
                self.open_except()?;
            },
        }

        Result.Ok(())
    }

    F next(~self) -> Result<Option<ExecutorRow>, VaisError> {
        M &self.materialized {
            Option.None => {
                Result.Err(VaisError.new("VAIS-E0107001", "SetOperationExecutor not opened"))
            },
            Option.Some(rows) => {
                if self.cursor >= rows.len() {
                    Result.Ok(Option.None)
                } else {
                    ~row = &rows[self.cursor];
                    self.cursor += 1;
                    self.stats.add_produced();
                    Result.Ok(Option.Some(ExecutorRow.virtual(row.clone())))
                }
            },
        }
    }

    F close(~self) -> Result<(), VaisError> {
        self.materialized = Option.None;
        self.cursor = 0;
        self.left.close()?;
        self.right.close()?;
        Result.Ok(())
    }

    F stats(self) -> &ExecStats {
        &self.stats
    }

    # UNION ALL: concatenate left and right
    F open_union_all(~self) -> Result<(), VaisError> {
        self.left.open()?;
        self.right.open()?;

        ~result = Vec.new();

        # Materialize left side
        L {
            M self.left.next()? {
                Option.None => { break; },
                Option.Some(exec_row) => {
                    self.stats.add_scanned(1);
                    result.push(exec_row.get_row().clone());
                },
            }
        }

        # Materialize right side
        L {
            M self.right.next()? {
                Option.None => { break; },
                Option.Some(exec_row) => {
                    self.stats.add_scanned(1);
                    result.push(exec_row.get_row().clone());
                },
            }
        }

        self.materialized = Option.Some(result);
        self.cursor = 0;

        Result.Ok(())
    }

    # UNION: concatenate left and right, then deduplicate
    F open_union(~self) -> Result<(), VaisError> {
        self.left.open()?;
        self.right.open()?;

        ~seen = HashSet.new();
        ~result = Vec.new();

        # Materialize left side with dedup
        L {
            M self.left.next()? {
                Option.None => { break; },
                Option.Some(exec_row) => {
                    self.stats.add_scanned(1);
                    ~row = exec_row.get_row();

                    # Hash all row values
                    ~values: Vec<SqlValue> = Vec.new();
                    for i in 0..row.column_count() {
                        values.push(row.get(i).clone());
                    }
                    ~hash = group_key_hash(&values);

                    if !seen.contains(&hash) {
                        seen.insert(hash);
                        result.push(row.clone());
                    }
                },
            }
        }

        # Materialize right side with dedup
        L {
            M self.right.next()? {
                Option.None => { break; },
                Option.Some(exec_row) => {
                    self.stats.add_scanned(1);
                    ~row = exec_row.get_row();

                    # Hash all row values
                    ~values: Vec<SqlValue> = Vec.new();
                    for i in 0..row.column_count() {
                        values.push(row.get(i).clone());
                    }
                    ~hash = group_key_hash(&values);

                    if !seen.contains(&hash) {
                        seen.insert(hash);
                        result.push(row.clone());
                    }
                },
            }
        }

        self.materialized = Option.Some(result);
        self.cursor = 0;

        Result.Ok(())
    }

    # INTERSECT: materialize right into HashSet, probe from left
    F open_intersect(~self) -> Result<(), VaisError> {
        self.left.open()?;
        self.right.open()?;

        # Materialize right side into hash set
        ~right_hashes = HashSet.new();

        L {
            M self.right.next()? {
                Option.None => { break; },
                Option.Some(exec_row) => {
                    self.stats.add_scanned(1);
                    ~row = exec_row.get_row();

                    ~values: Vec<SqlValue> = Vec.new();
                    for i in 0..row.column_count() {
                        values.push(row.get(i).clone());
                    }
                    ~hash = group_key_hash(&values);
                    right_hashes.insert(hash);
                },
            }
        }

        # Probe from left side, emit rows in both
        ~seen = HashSet.new();
        ~result = Vec.new();

        L {
            M self.left.next()? {
                Option.None => { break; },
                Option.Some(exec_row) => {
                    self.stats.add_scanned(1);
                    ~row = exec_row.get_row();

                    ~values: Vec<SqlValue> = Vec.new();
                    for i in 0..row.column_count() {
                        values.push(row.get(i).clone());
                    }
                    ~hash = group_key_hash(&values);

                    # Only emit if in right side and not already seen (dedup)
                    if right_hashes.contains(&hash) && !seen.contains(&hash) {
                        seen.insert(hash);
                        result.push(row.clone());
                    }
                },
            }
        }

        self.materialized = Option.Some(result);
        self.cursor = 0;

        Result.Ok(())
    }

    # EXCEPT: materialize right into HashSet, emit left rows NOT in right
    F open_except(~self) -> Result<(), VaisError> {
        self.left.open()?;
        self.right.open()?;

        # Materialize right side into hash set
        ~right_hashes = HashSet.new();

        L {
            M self.right.next()? {
                Option.None => { break; },
                Option.Some(exec_row) => {
                    self.stats.add_scanned(1);
                    ~row = exec_row.get_row();

                    ~values: Vec<SqlValue> = Vec.new();
                    for i in 0..row.column_count() {
                        values.push(row.get(i).clone());
                    }
                    ~hash = group_key_hash(&values);
                    right_hashes.insert(hash);
                },
            }
        }

        # Probe from left side, emit rows NOT in right
        ~seen = HashSet.new();
        ~result = Vec.new();

        L {
            M self.left.next()? {
                Option.None => { break; },
                Option.Some(exec_row) => {
                    self.stats.add_scanned(1);
                    ~row = exec_row.get_row();

                    ~values: Vec<SqlValue> = Vec.new();
                    for i in 0..row.column_count() {
                        values.push(row.get(i).clone());
                    }
                    ~hash = group_key_hash(&values);

                    # Only emit if NOT in right side and not already seen (dedup)
                    if !right_hashes.contains(&hash) && !seen.contains(&hash) {
                        seen.insert(hash);
                        result.push(row.clone());
                    }
                },
            }
        }

        self.materialized = Option.Some(result);
        self.cursor = 0;

        Result.Ok(())
    }
}
