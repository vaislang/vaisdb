# RAG Source Attribution
# Tracks provenance of retrieved chunks: which document, section, position,
# embedding model, and search engines contributed to each result.
# Enables "Show Sources" in RAG applications and citation generation.

U std/vec.Vec;
U std/string.Str;
U std/option.{Option, Some, None};
U std/hashmap.HashMap;
U storage/error.{VaisError};
U rag/types.{
    RagSearchResult, ChunkInfo, DocumentInfo, ScoredChunk,
    ENGINE_TAG_RAG
};

# ============================================================================
# Attribution — Source provenance for a single search result
# ============================================================================

S Attribution {
    chunk_id: u64,
    doc_id: u64,
    doc_title: Str,
    doc_source_uri: Str,
    section_index: u32,             # Which section of the document
    position_in_doc: u32,           # Chunk position within document
    byte_start: u32,                # Start byte offset in original document
    byte_end: u32,                  # End byte offset in original document
    embedding_model_id: u32,        # Model used for embedding
    contributing_engines: Vec<Str>, # Engines that found this chunk
    score_breakdown: ScoreBreakdown,
}

X Attribution {
    F new(chunk_id: u64, doc_id: u64) -> Attribution {
        Attribution {
            chunk_id,
            doc_id,
            doc_title: Str.new(),
            doc_source_uri: Str.new(),
            section_index: 0,
            position_in_doc: 0,
            byte_start: 0,
            byte_end: 0,
            embedding_model_id: 0,
            contributing_engines: Vec.new(),
            score_breakdown: ScoreBreakdown.empty(),
        }
    }

    F with_document(~self, title: Str, source_uri: Str) -> Attribution {
        self.doc_title = title;
        self.doc_source_uri = source_uri;
        self
    }

    F with_position(~self, section: u32, position: u32,
                    byte_start: u32, byte_end: u32) -> Attribution {
        self.section_index = section;
        self.position_in_doc = position;
        self.byte_start = byte_start;
        self.byte_end = byte_end;
        self
    }

    F with_model(~self, model_id: u32) -> Attribution {
        self.embedding_model_id = model_id;
        self
    }

    F add_engine(~self, engine_name: Str) {
        self.contributing_engines.push(engine_name);
    }

    ## Format as citation string
    ## Example: "[Doc: 'ML Guide', Section 3, Position 12]"
    F format_citation(self) -> Str {
        I self.doc_title.is_empty() {
            R "[Chunk {self.chunk_id}, Doc {self.doc_id}]";
        }
        "[Doc: '{self.doc_title}', Section {self.section_index}, Position {self.position_in_doc}]"
    }

    ## Format as URI-like reference
    ## Example: "vaisdb://doc/42/chunk/17"
    F format_ref(self) -> Str {
        "vaisdb://doc/{self.doc_id}/chunk/{self.chunk_id}"
    }
}

# ============================================================================
# ScoreBreakdown — Per-engine score breakdown for transparency
# ============================================================================

S ScoreBreakdown {
    vector_score: f64,              # Raw vector similarity score
    fulltext_score: f64,            # Raw BM25 score
    graph_boost: f64,               # Graph proximity boost
    memory_boost: f64,              # Memory importance boost
    fused_score: f64,               # Final fused score
    vector_rank: u32,               # Rank in vector results (0 if absent)
    fulltext_rank: u32,             # Rank in fulltext results (0 if absent)
}

X ScoreBreakdown {
    F empty() -> ScoreBreakdown {
        ScoreBreakdown {
            vector_score: 0.0,
            fulltext_score: 0.0,
            graph_boost: 0.0,
            memory_boost: 0.0,
            fused_score: 0.0,
            vector_rank: 0,
            fulltext_rank: 0,
        }
    }

    ## Format as human-readable breakdown
    F format(self) -> Str {
        ~parts = Vec.new();
        I self.vector_score > 0.0 {
            parts.push("vector={self.vector_score:.3}(rank:{self.vector_rank})");
        }
        I self.fulltext_score > 0.0 {
            parts.push("fulltext={self.fulltext_score:.3}(rank:{self.fulltext_rank})");
        }
        I self.graph_boost > 0.0 {
            parts.push("graph_boost={self.graph_boost:.3}");
        }
        I self.memory_boost > 0.0 {
            parts.push("memory={self.memory_boost:.3}");
        }

        ~result = "fused={self.fused_score:.3}";
        I parts.len() > 0 {
            result = "{result} [";
            ~i: u32 = 0;
            W i < parts.len() as u32 {
                I i > 0 {
                    result = "{result}, ";
                }
                result = "{result}{*parts.get(i as u64)}";
                i = i + 1;
            }
            result = "{result}]";
        }
        result
    }
}

# ============================================================================
# AttributionBuilder — Builds attributions from search results
# ============================================================================

S AttributionBuilder {
    attributions: Vec<Attribution>,
}

X AttributionBuilder {
    F new() -> AttributionBuilder {
        AttributionBuilder {
            attributions: Vec.new(),
        }
    }

    ## Build attributions for a set of search results
    ## Looks up chunk and document metadata to fill in provenance details
    F build(
        ~self,
        results: &Vec<RagSearchResult>,
        chunks: &Vec<ChunkInfo>,
        docs: &Vec<DocumentInfo>,
        vector_results: &Vec<ScoredChunk>,
        fulltext_results: &Vec<ScoredChunk>,
        graph_boost_results: &Vec<ScoredChunk>,
    ) -> Vec<Attribution> {
        self.attributions = Vec.new();

        ~ri: u32 = 0;
        W ri < results.len() as u32 {
            ~r = results.get(ri as u64);
            ~attr = Attribution.new(r.chunk_id, r.parent_doc_id);

            # Look up document info
            ~di: u32 = 0;
            W di < docs.len() as u32 {
                ~d = docs.get(di as u64);
                I d.doc_id == r.parent_doc_id {
                    attr = attr.with_document(d.title.clone(), d.source_uri.clone());
                    attr = attr.with_model(d.embedding_model_id);
                    di = docs.len() as u32;  # Break
                }
                di = di + 1;
            }

            # Look up chunk position
            ~ci: u32 = 0;
            W ci < chunks.len() as u32 {
                ~c = chunks.get(ci as u64);
                I c.chunk_id == r.chunk_id {
                    attr = attr.with_position(
                        0,  # Section index not stored in ChunkInfo directly
                        c.position_in_doc,
                        c.overlap_start,
                        c.overlap_end,
                    );
                    ci = chunks.len() as u32;  # Break
                }
                ci = ci + 1;
            }

            # Build score breakdown
            ~breakdown = ScoreBreakdown.empty();
            breakdown.fused_score = r.score;

            # Check vector results
            ~v_score = find_score_for_chunk(r.chunk_id, vector_results);
            I v_score.0 {
                breakdown.vector_score = v_score.1;
                breakdown.vector_rank = v_score.2;
                attr.add_engine("vector");
            }

            # Check fulltext results
            ~f_score = find_score_for_chunk(r.chunk_id, fulltext_results);
            I f_score.0 {
                breakdown.fulltext_score = f_score.1;
                breakdown.fulltext_rank = f_score.2;
                attr.add_engine("fulltext");
            }

            # Check graph boost
            ~g_score = find_score_for_chunk(r.chunk_id, graph_boost_results);
            I g_score.0 {
                breakdown.graph_boost = g_score.1;
                attr.add_engine("graph");
            }

            attr.score_breakdown = breakdown;
            self.attributions.push(attr);
            ri = ri + 1;
        }

        self.attributions.clone()
    }

    ## Get the built attributions
    F get_attributions(self) -> &Vec<Attribution> {
        &self.attributions
    }

    ## Format all attributions as a report
    F format_report(self) -> Str {
        ~report = "=== RAG Search Attribution Report ===\n";
        ~i: u32 = 0;
        W i < self.attributions.len() as u32 {
            ~a = self.attributions.get(i as u64);
            report = "{report}\nResult {i + 1}:\n";
            report = "{report}  Citation: {a.format_citation()}\n";
            report = "{report}  Reference: {a.format_ref()}\n";
            report = "{report}  Scores: {a.score_breakdown.format()}\n";

            I a.contributing_engines.len() > 0 {
                report = "{report}  Engines: ";
                ~j: u32 = 0;
                W j < a.contributing_engines.len() as u32 {
                    I j > 0 {
                        report = "{report}, ";
                    }
                    report = "{report}{*a.contributing_engines.get(j as u64)}";
                    j = j + 1;
                }
                report = "{report}\n";
            }
            i = i + 1;
        }
        report
    }
}

# ============================================================================
# Helper Functions
# ============================================================================

## Find a chunk's score and rank in a scored result set
## Returns (found: bool, score: f64, rank: u32)
F find_score_for_chunk(
    chunk_id: u64,
    results: &Vec<ScoredChunk>,
) -> (bool, f64, u32) {
    ~i: u32 = 0;
    W i < results.len() as u32 {
        ~c = results.get(i as u64);
        I c.chunk_id == chunk_id {
            R (true, c.score, i + 1);  # 1-based rank
        }
        i = i + 1;
    }
    (false, 0.0, 0)
}

## Inject attribution metadata into a RagSearchResult
## Adds keys: "citation", "reference", "score_breakdown", "engines"
F inject_attribution_metadata(
    ~result: RagSearchResult,
    attribution: &Attribution,
) -> RagSearchResult {
    result.metadata.insert("citation".clone(), attribution.format_citation());
    result.metadata.insert("reference".clone(), attribution.format_ref());
    result.metadata.insert("score_breakdown".clone(),
        attribution.score_breakdown.format());

    # Engines list
    ~engines = Str.new();
    ~i: u32 = 0;
    W i < attribution.contributing_engines.len() as u32 {
        I i > 0 {
            engines = "{engines},";
        }
        engines = "{engines}{*attribution.contributing_engines.get(i as u64)}";
        i = i + 1;
    }
    result.metadata.insert("engines".clone(), engines);

    result
}

## Build attributions and inject them into search results (convenience)
F attribute_results(
    results: &~Vec<RagSearchResult>,
    chunks: &Vec<ChunkInfo>,
    docs: &Vec<DocumentInfo>,
    vector_results: &Vec<ScoredChunk>,
    fulltext_results: &Vec<ScoredChunk>,
    graph_boost: &Vec<ScoredChunk>,
) {
    ~builder = AttributionBuilder.new();
    ~attrs = builder.build(
        results, chunks, docs,
        vector_results, fulltext_results, graph_boost,
    );

    # Inject metadata into each result
    ~i: u32 = 0;
    W i < results.len() as u32 && i < attrs.len() as u32 {
        ~result = results.get_mut(i as u64);
        ~attr = attrs.get(i as u64);

        result.metadata.insert("citation".clone(), attr.format_citation());
        result.metadata.insert("reference".clone(), attr.format_ref());
        result.metadata.insert("score_breakdown".clone(),
            attr.score_breakdown.format());

        i = i + 1;
    }
}
