# RAG Concurrency Control
# RwLock-based RAII guards for document/chunk/memory operations
# Provides read/write locking with statistics tracking

U std/sync.{RwLock, RwLockReadGuard, RwLockWriteGuard};
U std/atomic.{AtomicU64};

## RAG Concurrency Statistics
## Tracks lock acquisition patterns for performance monitoring
S RagConcurrencyStats {
    read_count: AtomicU64,
    write_count: AtomicU64,
    contention_count: AtomicU64,
}

X RagConcurrencyStats {
    ## Create new statistics tracker
    F new() -> RagConcurrencyStats {
        RagConcurrencyStats {
            read_count: AtomicU64.new(0),
            write_count: AtomicU64.new(0),
            contention_count: AtomicU64.new(0),
        }
    }

    ## Increment read lock counter
    F inc_read(&self) {
        self.read_count.fetch_add(1);
    }

    ## Increment write lock counter
    F inc_write(&self) {
        self.write_count.fetch_add(1);
    }

    ## Increment contention counter
    F inc_contention(&self) {
        self.contention_count.fetch_add(1);
    }

    ## Get total read locks acquired
    F get_read_count(&self) -> u64 {
        self.read_count.load()
    }

    ## Get total write locks acquired
    F get_write_count(&self) -> u64 {
        self.write_count.load()
    }

    ## Get total contentions detected
    F get_contention_count(&self) -> u64 {
        self.contention_count.load()
    }

    ## Reset all counters to zero
    F reset(&self) {
        self.read_count.store(0);
        self.write_count.store(0);
        self.contention_count.store(0);
    }
}

## RAG Lock
## Primary concurrency primitive for RAG engine operations
## Uses RwLock to allow multiple readers or single writer
S RagLock {
    lock: RwLock,
    stats: RagConcurrencyStats,
}

X RagLock {
    ## Create new RAG lock
    F new() -> RagLock {
        RagLock {
            lock: RwLock.new(),
            stats: RagConcurrencyStats.new(),
        }
    }

    ## Acquire read lock (shared access)
    ## Multiple readers can hold lock simultaneously
    F read_lock(&self) -> RwLockReadGuard {
        self.stats.inc_read();
        self.lock.read()
    }

    ## Acquire write lock (exclusive access)
    ## Only one writer can hold lock at a time
    F write_lock(&self) -> RwLockWriteGuard {
        self.stats.inc_write();
        self.lock.write()
    }

    ## Try to acquire read lock without blocking
    ## Returns None if lock is held by writer
    F try_read_lock(&self) -> Option<RwLockReadGuard> {
        L result = self.lock.try_read();
        M result {
            Some(guard) => {
                self.stats.inc_read();
                Some(guard)
            }
            None => {
                self.stats.inc_contention();
                None
            }
        }
    }

    ## Try to acquire write lock without blocking
    ## Returns None if lock is held by any reader or writer
    F try_write_lock(&self) -> Option<RwLockWriteGuard> {
        L result = self.lock.try_write();
        M result {
            Some(guard) => {
                self.stats.inc_write();
                Some(guard)
            }
            None => {
                self.stats.inc_contention();
                None
            }
        }
    }

    ## Get lock statistics
    F get_stats(&self) -> &RagConcurrencyStats {
        &self.stats
    }

    ## Reset lock statistics
    F reset_stats(&self) {
        self.stats.reset();
    }
}

## Document Lock Manager
## Provides fine-grained locking per document
## Uses hash-based striping to reduce contention
S DocumentLockManager {
    locks: Vec<RagLock>,
    stripe_count: usize,
}

X DocumentLockManager {
    ## Create new document lock manager
    ## stripe_count should be power of 2 for efficient modulo
    F new(stripe_count: usize) -> DocumentLockManager {
        ~locks = Vec.new();
        L i = 0;
        W i < stripe_count {
            locks.push(RagLock.new());
            i = i + 1;
        }
        DocumentLockManager { locks, stripe_count }
    }

    ## Get lock for document ID
    F get_lock(&self, doc_id: u64) -> &RagLock {
        L stripe = (doc_id % self.stripe_count as u64) as usize;
        &self.locks[stripe]
    }

    ## Acquire read lock for document
    F read_lock_document(&self, doc_id: u64) -> RwLockReadGuard {
        self.get_lock(doc_id).read_lock()
    }

    ## Acquire write lock for document
    F write_lock_document(&self, doc_id: u64) -> RwLockWriteGuard {
        self.get_lock(doc_id).write_lock()
    }

    ## Try to acquire read lock for document
    F try_read_lock_document(&self, doc_id: u64) -> Option<RwLockReadGuard> {
        self.get_lock(doc_id).try_read_lock()
    }

    ## Try to acquire write lock for document
    F try_write_lock_document(&self, doc_id: u64) -> Option<RwLockWriteGuard> {
        self.get_lock(doc_id).try_write_lock()
    }

    ## Get aggregate statistics across all stripes
    F get_aggregate_stats(&self) -> RagConcurrencyStats {
        ~total = RagConcurrencyStats.new();
        E lock in &self.locks {
            L stats = lock.get_stats();
            total.read_count.fetch_add(stats.get_read_count());
            total.write_count.fetch_add(stats.get_write_count());
            total.contention_count.fetch_add(stats.get_contention_count());
        }
        total
    }

    ## Reset statistics for all stripes
    F reset_all_stats(&self) {
        E lock in &self.locks {
            lock.reset_stats();
        }
    }
}

## Chunk Lock Manager
## Provides fine-grained locking per chunk
## Uses hash-based striping to reduce contention
S ChunkLockManager {
    locks: Vec<RagLock>,
    stripe_count: usize,
}

X ChunkLockManager {
    ## Create new chunk lock manager
    F new(stripe_count: usize) -> ChunkLockManager {
        ~locks = Vec.new();
        L i = 0;
        W i < stripe_count {
            locks.push(RagLock.new());
            i = i + 1;
        }
        ChunkLockManager { locks, stripe_count }
    }

    ## Get lock for chunk ID
    F get_lock(&self, chunk_id: u64) -> &RagLock {
        L stripe = (chunk_id % self.stripe_count as u64) as usize;
        &self.locks[stripe]
    }

    ## Acquire read lock for chunk
    F read_lock_chunk(&self, chunk_id: u64) -> RwLockReadGuard {
        self.get_lock(chunk_id).read_lock()
    }

    ## Acquire write lock for chunk
    F write_lock_chunk(&self, chunk_id: u64) -> RwLockWriteGuard {
        self.get_lock(chunk_id).write_lock()
    }

    ## Try to acquire read lock for chunk
    F try_read_lock_chunk(&self, chunk_id: u64) -> Option<RwLockReadGuard> {
        self.get_lock(chunk_id).try_read_lock()
    }

    ## Try to acquire write lock for chunk
    F try_write_lock_chunk(&self, chunk_id: u64) -> Option<RwLockWriteGuard> {
        self.get_lock(chunk_id).try_write_lock()
    }

    ## Get aggregate statistics across all stripes
    F get_aggregate_stats(&self) -> RagConcurrencyStats {
        ~total = RagConcurrencyStats.new();
        E lock in &self.locks {
            L stats = lock.get_stats();
            total.read_count.fetch_add(stats.get_read_count());
            total.write_count.fetch_add(stats.get_write_count());
            total.contention_count.fetch_add(stats.get_contention_count());
        }
        total
    }

    ## Reset statistics for all stripes
    F reset_all_stats(&self) {
        E lock in &self.locks {
            lock.reset_stats();
        }
    }
}

## Memory Lock Manager
## Provides fine-grained locking per memory entry
## Uses hash-based striping to reduce contention
S MemoryLockManager {
    locks: Vec<RagLock>,
    stripe_count: usize,
}

X MemoryLockManager {
    ## Create new memory lock manager
    F new(stripe_count: usize) -> MemoryLockManager {
        ~locks = Vec.new();
        L i = 0;
        W i < stripe_count {
            locks.push(RagLock.new());
            i = i + 1;
        }
        MemoryLockManager { locks, stripe_count }
    }

    ## Get lock for memory ID
    F get_lock(&self, memory_id: u64) -> &RagLock {
        L stripe = (memory_id % self.stripe_count as u64) as usize;
        &self.locks[stripe]
    }

    ## Acquire read lock for memory entry
    F read_lock_memory(&self, memory_id: u64) -> RwLockReadGuard {
        self.get_lock(memory_id).read_lock()
    }

    ## Acquire write lock for memory entry
    F write_lock_memory(&self, memory_id: u64) -> RwLockWriteGuard {
        self.get_lock(memory_id).write_lock()
    }

    ## Try to acquire read lock for memory entry
    F try_read_lock_memory(&self, memory_id: u64) -> Option<RwLockReadGuard> {
        self.get_lock(memory_id).try_read_lock()
    }

    ## Try to acquire write lock for memory entry
    F try_write_lock_memory(&self, memory_id: u64) -> Option<RwLockWriteGuard> {
        self.get_lock(memory_id).try_write_lock()
    }

    ## Get aggregate statistics across all stripes
    F get_aggregate_stats(&self) -> RagConcurrencyStats {
        ~total = RagConcurrencyStats.new();
        E lock in &self.locks {
            L stats = lock.get_stats();
            total.read_count.fetch_add(stats.get_read_count());
            total.write_count.fetch_add(stats.get_write_count());
            total.contention_count.fetch_add(stats.get_contention_count());
        }
        total
    }

    ## Reset statistics for all stripes
    F reset_all_stats(&self) {
        E lock in &self.locks {
            lock.reset_stats();
        }
    }
}

## Default stripe count for lock managers
## Power of 2 for efficient modulo operations
L DEFAULT_STRIPE_COUNT: usize = 256;
