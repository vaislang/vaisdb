# Memory Lifecycle Manager
# Handles TTL expiration, working memory eviction,
# importance-based consolidation, and garbage collection
# Runs periodically as background maintenance

U std/vec.Vec;
U std/string.Str;
U std/option.{Option, Some, None};
U storage/error.{VaisError};
U rag/types.{
    MEMORY_TYPE_EPISODIC, MEMORY_TYPE_SEMANTIC,
    MEMORY_TYPE_PROCEDURAL, MEMORY_TYPE_WORKING,
    DEFAULT_TTL_WORKING,
    err_rag_engine_closed
};
U rag/memory/types.{MemoryEntry, MemoryConfig};

# ============================================================================
# LifecycleAction — Actions to be taken by the lifecycle manager
# ============================================================================

L ACTION_EXPIRE: u8 = 0;           # TTL expired, mark for deletion
L ACTION_EVICT: u8 = 1;            # Working memory eviction
L ACTION_CONSOLIDATE: u8 = 2;      # Promote working → semantic
L ACTION_DECAY: u8 = 3;            # Apply importance decay

S LifecycleAction {
    action_type: u8,
    memory_id: u64,
    reason: Str,
}

X LifecycleAction {
    ## Create a new lifecycle action
    F new(action_type: u8, memory_id: u64, reason: Str) -> LifecycleAction {
        LifecycleAction {
            action_type: action_type,
            memory_id: memory_id,
            reason: reason,
        }
    }

    ## Get action type as string
    F action_name(&self) -> Str {
        M self.action_type {
            0 => "EXPIRE",
            1 => "EVICT",
            2 => "CONSOLIDATE",
            3 => "DECAY",
            _ => "UNKNOWN",
        }
    }
}

# ============================================================================
# LifecycleStats — Statistics from a lifecycle run
# ============================================================================

S LifecycleStats {
    expired_count: u32,
    evicted_count: u32,
    consolidated_count: u32,
    decayed_count: u32,
    total_scanned: u32,
    run_time_us: u64,
}

X LifecycleStats {
    ## Create empty lifecycle stats
    F new() -> LifecycleStats {
        LifecycleStats {
            expired_count: 0,
            evicted_count: 0,
            consolidated_count: 0,
            decayed_count: 0,
            total_scanned: 0,
            run_time_us: 0,
        }
    }

    ## Get total actions taken
    F total_actions(&self) -> u32 {
        self.expired_count + self.evicted_count +
        self.consolidated_count + self.decayed_count
    }

    ## Format stats as human-readable string
    F format(&self) -> Str {
        "LifecycleStats {{ scanned: {self.total_scanned}, expired: {self.expired_count}, evicted: {self.evicted_count}, consolidated: {self.consolidated_count}, decayed: {self.decayed_count}, time_us: {self.run_time_us} }}"
    }
}

# ============================================================================
# MemoryLifecycleManager — Runs lifecycle maintenance
# ============================================================================

S MemoryLifecycleManager {
    config: MemoryConfig,
    last_run_at: i64,
    run_interval_seconds: u64,      # How often to run (default 300 = 5 min)
}

X MemoryLifecycleManager {
    ## Create a new lifecycle manager
    F new(config: MemoryConfig) -> MemoryLifecycleManager {
        MemoryLifecycleManager {
            config: config,
            last_run_at: 0,
            run_interval_seconds: 300,  # 5 minutes default
        }
    }

    ## Check if lifecycle maintenance should run
    F should_run(&self, current_time: i64) -> bool {
        (current_time - self.last_run_at) as u64 >= self.run_interval_seconds
    }

    ## Set run interval
    F set_run_interval(~self, interval_seconds: u64) {
        self.run_interval_seconds = interval_seconds;
    }

    ## Run full lifecycle pass on memories
    ## Returns actions to be executed by the caller
    F run(~self, memories: &Vec<MemoryEntry>,
          current_time: i64) -> (Vec<LifecycleAction>, LifecycleStats) {
        ~stats = LifecycleStats.new();
        stats.total_scanned = memories.len() as u32;

        ~actions = Vec.new();

        # 1. Check TTL expiration for each memory
        ~expired = self.find_expired(memories, current_time);
        stats.expired_count = expired.len() as u32;
        ~ei: u32 = 0;
        W ei < expired.len() as u32 {
            ~a = expired.get(ei as u64);
            actions.push(LifecycleAction.new(a.action_type, a.memory_id, a.reason.clone()));
            ei = ei + 1;
        }

        # 2. Evict excess working memory entries
        ~evicted = self.find_eviction_candidates(memories, current_time);
        stats.evicted_count = evicted.len() as u32;
        ~vi: u32 = 0;
        W vi < evicted.len() as u32 {
            ~a = evicted.get(vi as u64);
            actions.push(LifecycleAction.new(a.action_type, a.memory_id, a.reason.clone()));
            vi = vi + 1;
        }

        # 3. Identify consolidation candidates (high-importance working → semantic)
        ~consolidated = self.find_consolidation_candidates(memories, current_time);
        stats.consolidated_count = consolidated.len() as u32;
        ~ci: u32 = 0;
        W ci < consolidated.len() as u32 {
            ~a = consolidated.get(ci as u64);
            actions.push(LifecycleAction.new(a.action_type, a.memory_id, a.reason.clone()));
            ci = ci + 1;
        }

        # 4. Apply importance decay to all entries
        ~decayed = self.compute_decay(memories, current_time);
        stats.decayed_count = decayed.len() as u32;
        ~di: u32 = 0;
        W di < decayed.len() as u32 {
            ~a = decayed.get(di as u64);
            actions.push(LifecycleAction.new(a.action_type, a.memory_id, a.reason.clone()));
            di = di + 1;
        }

        self.last_run_at = current_time;

        (actions, stats)
    }

    ## Find TTL-expired memories
    F find_expired(&self, memories: &Vec<MemoryEntry>,
                   current_time: i64) -> Vec<LifecycleAction> {
        ~actions = Vec.new();

        ~i: u32 = 0;
        W i < memories.len() as u32 {
            ~entry = memories.get(i as u64);

            # Check if memory has expired based on TTL
            I entry.ttl_seconds > 0 {
                ~age_diff = current_time - entry.created_at;
                ~age: u64 = I age_diff > 0 { age_diff as u64 } E { 0 };
                I age > entry.ttl_seconds {
                    ~action = LifecycleAction.new(
                        ACTION_EXPIRE,
                        entry.memory_id,
                        "TTL expired (age: {age}s, ttl: {entry.ttl_seconds}s)"
                    );
                    actions.push(action);
                }
            }

            i = i + 1;
        }

        actions
    }

    ## Find working memories to evict (oldest/lowest importance beyond limit)
    F find_eviction_candidates(&self, memories: &Vec<MemoryEntry>,
                               current_time: i64) -> Vec<LifecycleAction> {
        ~actions = Vec.new();

        # Count working memories
        ~working_count: u32 = 0;
        ~i: u32 = 0;
        W i < memories.len() as u32 {
            ~entry = memories.get(i as u64);
            I entry.memory_type == MEMORY_TYPE_WORKING {
                working_count = working_count + 1;
            }
            i = i + 1;
        }

        # If below limit, no eviction needed
        I working_count <= self.config.max_working_memory_entries {
            R actions;
        }

        # Need to evict (working_count - limit) entries
        ~evict_count = working_count - self.config.max_working_memory_entries;

        # Collect working memories with (importance, age) for sorting
        ~candidates = Vec.new();
        ~i: u32 = 0;
        W i < memories.len() as u32 {
            ~entry = memories.get(i as u64);
            I entry.memory_type == MEMORY_TYPE_WORKING {
                ~age_diff = current_time - entry.created_at;
                ~age: u64 = I age_diff > 0 { age_diff as u64 } E { 0 };
                candidates.push((entry.memory_id, entry.importance, age));
            }
            i = i + 1;
        }

        # O(N log N) merge sort by importance ascending, then age descending
        sort_eviction_candidates(&~candidates);

        # Take first evict_count candidates
        ~i: u32 = 0;
        W i < evict_count {
            ~candidate = candidates.get(i as u64);
            ~action = LifecycleAction.new(
                ACTION_EVICT,
                candidate.0,
                "Working memory limit exceeded (importance: {candidate.1}, age: {candidate.2}s)"
            );
            actions.push(action);
            i = i + 1;
        }

        actions
    }

    ## Find working memories suitable for consolidation to semantic
    F find_consolidation_candidates(&self, memories: &Vec<MemoryEntry>,
                                     current_time: i64) -> Vec<LifecycleAction> {
        ~actions = Vec.new();

        ~i: u32 = 0;
        W i < memories.len() as u32 {
            ~entry = memories.get(i as u64);

            # Only consolidate working memories
            I entry.memory_type == MEMORY_TYPE_WORKING {
                # Consolidate if:
                # 1. High importance (> 0.8)
                # 2. Accessed multiple times (> 3)
                # 3. Not too old (< 1 hour)
                ~age_diff = current_time - entry.created_at;
                ~age: u64 = I age_diff > 0 { age_diff as u64 } E { 0 };

                I entry.importance > 0.8 &&
                   entry.access_count > 3 &&
                   age < 3600 {
                    ~action = LifecycleAction.new(
                        ACTION_CONSOLIDATE,
                        entry.memory_id,
                        "High importance working memory (score: {entry.importance}, accesses: {entry.access_count})"
                    );
                    actions.push(action);
                }
            }

            i = i + 1;
        }

        actions
    }

    ## Compute decay actions for all memories
    F compute_decay(&self, memories: &Vec<MemoryEntry>,
                    current_time: i64) -> Vec<LifecycleAction> {
        ~actions = Vec.new();

        # Decay half-life from config
        ~decay_half_life = self.config.decay_half_life;

        ~i: u32 = 0;
        W i < memories.len() as u32 {
            ~entry = memories.get(i as u64);

            # Apply decay based on time since last access
            ~tsa_diff = current_time - entry.last_accessed;
            ~time_since_access: u64 = I tsa_diff > 0 { tsa_diff as u64 } E { 0 };

            # Decay if not accessed for more than 1 hour and importance > 0.1
            I time_since_access > 3600 && entry.importance > 0.1 {
                ~action = LifecycleAction.new(
                    ACTION_DECAY,
                    entry.memory_id,
                    "Apply decay (half_life: {decay_half_life}, inactive: {time_since_access}s)"
                );
                actions.push(action);
            }

            i = i + 1;
        }

        actions
    }

    ## Get config reference
    F config(&self) -> &MemoryConfig {
        &self.config
    }

    ## Get last run time
    F last_run(&self) -> i64 {
        self.last_run_at
    }

    ## Reset last run time (for testing)
    F reset_last_run(~self) {
        self.last_run_at = 0;
    }
}

# ============================================================================
# Helper: O(N log N) merge sort for eviction candidates
# Sorts by importance ascending, then by age descending (oldest first)
# Candidate tuple: (memory_id: u64, importance: f64, age: u64)
# ============================================================================

## Compare two candidates: returns true if a should come before b
## (lower importance first; same importance → higher age first)
F evict_compare_before(
    candidates: &Vec<(u64, f64, u64)>, idx_a: u32, idx_b: u32
) -> bool {
    ~a = candidates.get(idx_a as u64);
    ~b = candidates.get(idx_b as u64);
    I a.1 < b.1 {
        R true;
    }
    I a.1 > b.1 {
        R false;
    }
    # Same importance — older (higher age) comes first
    a.2 >= b.2
}

## Bottom-up merge sort on eviction candidates via index permutation
F sort_eviction_candidates(candidates: &~Vec<(u64, f64, u64)>) {
    ~n = candidates.len() as u32;
    I n <= 1 {
        R;
    }

    # Build index + aux arrays
    ~indices = Vec.new();
    ~aux = Vec.new();
    ~i: u32 = 0;
    W i < n {
        indices.push(i);
        aux.push(i);
        i = i + 1;
    }

    # Bottom-up merge sort on indices
    ~width: u32 = 1;
    W width < n {
        ~left: u32 = 0;
        W left < n {
            ~mid = left + width;
            I mid > n { mid = n; }
            ~right = left + width * 2;
            I right > n { right = n; }

            ~li = left;
            ~ri = mid;
            ~k = left;
            W k < right {
                I li < mid && (ri >= right ||
                    evict_compare_before(candidates,
                        *indices.get(li as u64),
                        *indices.get(ri as u64))) {
                    aux.set(k as u64, *indices.get(li as u64));
                    li = li + 1;
                } E {
                    aux.set(k as u64, *indices.get(ri as u64));
                    ri = ri + 1;
                }
                k = k + 1;
            }
            left = left + width * 2;
        }
        # Copy aux → indices
        ~c: u32 = 0;
        W c < n {
            indices.set(c as u64, *aux.get(c as u64));
            c = c + 1;
        }
        width = width * 2;
    }

    # Apply permutation via swap cycles
    ~visited = Vec.new();
    ~vi: u32 = 0;
    W vi < n {
        visited.push(false);
        vi = vi + 1;
    }
    ~ci: u32 = 0;
    W ci < n {
        I !*visited.get(ci as u64) && *indices.get(ci as u64) != ci {
            ~j = ci;
            ~done = false;
            W !done {
                ~next = *indices.get(j as u64);
                I next == ci {
                    visited.set(j as u64, true);
                    done = true;
                } E {
                    candidates.swap(j as u64, next as u64);
                    visited.set(j as u64, true);
                    j = next;
                }
            }
        }
        ci = ci + 1;
    }
}
