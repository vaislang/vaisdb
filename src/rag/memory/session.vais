# Agent Session Manager
# Manages AI agent sessions with per-session working memory
# Sessions group related interactions (conversation turns, tool calls)
# Each session has a lifecycle: Active → Paused → Closed
# Uses SESSION_CONTEXT edges in graph to connect session → memory entries

U std/vec.Vec;
U std/string.Str;
U std/option.{Option, Some, None};
U std/hashmap.HashMap;
U std/result.{Result, Ok, Err};
U storage/error.{VaisError};
U rag/types.{
    LABEL_SESSION, EDGE_TYPE_SESSION_CONTEXT, EDGE_TYPE_TEMPORAL_NEXT,
    MEMORY_TYPE_WORKING,
    err_rag_session_not_found, err_rag_engine_closed
};

# ============================================================================
# Session Status Constants
# ============================================================================

L SESSION_STATUS_ACTIVE: u8 = 0;
L SESSION_STATUS_PAUSED: u8 = 1;
L SESSION_STATUS_CLOSED: u8 = 2;

# Maximum concurrent sessions per agent
L MAX_CONCURRENT_SESSIONS: u32 = 16;

# ============================================================================
# AgentSession — Single agent session with lifecycle tracking
# ============================================================================

S AgentSession {
    session_id: u64,
    agent_id: Str,                  # Agent identifier
    status: u8,                     # SESSION_STATUS_*
    memory_ids: Vec<u64>,           # Memory entries in this session
    graph_node_id: u64,             # Graph node for this session (0 if not yet created)
    turn_count: u32,                # Number of interaction turns
    token_budget: u32,              # Max tokens for session context
    tokens_used: u32,               # Current tokens used
    created_at: i64,
    last_active_at: i64,
    closed_at: i64,                 # 0 if not closed
    metadata: HashMap<Str, Str>,
}

X AgentSession {
    ## Create a new agent session
    F new(session_id: u64, agent_id: Str, current_time: i64) -> AgentSession {
        AgentSession {
            session_id: session_id,
            agent_id: agent_id,
            status: SESSION_STATUS_ACTIVE,
            memory_ids: Vec.new(),
            graph_node_id: 0,
            turn_count: 0,
            token_budget: 4096,     # Default token budget
            tokens_used: 0,
            created_at: current_time,
            last_active_at: current_time,
            closed_at: 0,
            metadata: HashMap.new(),
        }
    }

    ## Check if session is active
    F is_active(&self) -> bool {
        self.status == SESSION_STATUS_ACTIVE
    }

    ## Check if session is closed
    F is_closed(&self) -> bool {
        self.status == SESSION_STATUS_CLOSED
    }

    ## Record an interaction turn
    F record_turn(~self, current_time: i64) {
        self.turn_count = self.turn_count + 1;
        self.last_active_at = current_time;
    }

    ## Add a memory to this session
    F add_memory(~self, memory_id: u64) {
        self.memory_ids.push(memory_id);
    }

    ## Add tokens to usage count
    F add_tokens(~self, token_count: u32) {
        self.tokens_used = self.tokens_used + token_count;
    }

    ## Check if token budget is exceeded
    F is_budget_exceeded(&self) -> bool {
        self.tokens_used > self.token_budget
    }

    ## Pause the session
    F pause(~self) {
        self.status = SESSION_STATUS_PAUSED;
    }

    ## Resume the session
    F resume(~self, current_time: i64) {
        self.status = SESSION_STATUS_ACTIVE;
        self.last_active_at = current_time;
    }

    ## Close the session
    F close(~self, current_time: i64) {
        self.status = SESSION_STATUS_CLOSED;
        self.closed_at = current_time;
    }

    ## Get session duration in seconds
    F duration_seconds(&self, current_time: i64) -> u64 {
        if self.closed_at > 0 {
            ~diff = self.closed_at - self.created_at;
            if diff < 0 { return 0 }
            diff as u64
        } else {
            ~diff = current_time - self.created_at;
            if diff < 0 { return 0 }
            diff as u64
        }
    }

    ## Get memory count for this session
    F memory_count(&self) -> u32 {
        self.memory_ids.len() as u32
    }

    ## Set the graph node ID for this session
    F set_graph_node(~self, node_id: u64) {
        self.graph_node_id = node_id;
    }

    ## Set token budget
    F set_token_budget(~self, budget: u32) {
        self.token_budget = budget;
    }

    ## Add metadata entry
    F add_metadata(~self, key: Str, value: Str) {
        self.metadata.insert(key, value);
    }

    ## Get metadata value
    F get_metadata(&self, key: &Str) -> Option<&Str> {
        self.metadata.get(key)
    }
}

# ============================================================================
# SessionManager — Manages all agent sessions
# ============================================================================

S SessionManager {
    sessions: Vec<AgentSession>,
    next_session_id: u64,
    is_open: bool,
}

X SessionManager {
    ## Create a new session manager
    F new() -> SessionManager {
        SessionManager {
            sessions: Vec.new(),
            next_session_id: 1,
            is_open: false,
        }
    }

    ## Open the session manager
    F open(~self) {
        self.is_open = true;
    }

    ## Close the session manager
    F close(~self) {
        self.is_open = false;
    }

    ## Create a new session for an agent
    F create_session(~self, agent_id: Str, token_budget: u32,
                     current_time: i64) -> Result<u64, VaisError> {
        if !self.is_open {
            return Err(err_rag_engine_closed());
        }

        # Check concurrent session limit for this agent
        ~active_count: u32 = 0;
        ~i: u32 = 0;
        W i < self.sessions.len() as u32 {
            ~session = self.sessions.get(i as usize);
            if session.agent_id == agent_id && session.is_active() {
                active_count = active_count + 1;
            }
            i = i + 1;
        }

        if active_count >= MAX_CONCURRENT_SESSIONS {
            return Err(VaisError.new(
                "VAIS-0808010",
                "Maximum concurrent sessions per agent exceeded"
            ));
        }

        ~session_id = self.next_session_id;
        self.next_session_id = self.next_session_id + 1;

        ~session = AgentSession.new(session_id, agent_id, current_time);
        session.set_token_budget(token_budget);

        self.sessions.push(session);
        Ok(session_id)
    }

    ## Get a session by ID with agent ownership validation
    ## Returns Err if session belongs to a different agent
    F get_session_for_agent(&self, session_id: u64, agent_id: &Str) -> Result<&AgentSession, VaisError> {
        M self.get_session(session_id) {
            Some(session) => {
                if session.agent_id != *agent_id {
                    return Err(VaisError.new(
                        "VAIS-0808011",
                        "Session {session_id} belongs to a different agent"
                    ));
                }
                Ok(session)
            },
            None => Err(err_rag_session_not_found(session_id)),
        }
    }

    ## Get a session by ID (internal, no ownership check)
    F get_session(&self, session_id: u64) -> Option<&AgentSession> {
        ~i: u32 = 0;
        W i < self.sessions.len() as u32 {
            ~session = self.sessions.get(i as usize);
            if session.session_id == session_id {
                return Some(session);
            }
            i = i + 1;
        }
        None
    }

    ## Get mutable session
    F get_session_mut(~self, session_id: u64) -> Option<&~AgentSession> {
        ~i: u32 = 0;
        W i < self.sessions.len() as u32 {
            ~session = self.sessions.get_mut(i as usize);
            if session.session_id == session_id {
                return Some(session);
            }
            i = i + 1;
        }
        None
    }

    ## Get active sessions for an agent
    F get_active_sessions(&self, agent_id: &Str) -> Vec<&AgentSession> {
        ~result = Vec.new();
        ~i: u32 = 0;
        W i < self.sessions.len() as u32 {
            ~session = self.sessions.get(i as usize);
            if session.agent_id == *agent_id && session.is_active() {
                result.push(session);
            }
            i = i + 1;
        }
        result
    }

    ## Close a session (validates agent ownership)
    F close_session(~self, session_id: u64, agent_id: &Str,
                    current_time: i64) -> Result<(), VaisError> {
        if !self.is_open {
            return Err(err_rag_engine_closed());
        }

        M self.get_session_mut(session_id) {
            Some(session) => {
                if session.agent_id != *agent_id {
                    return Err(VaisError.new(
                        "VAIS-0808011",
                        "Session {session_id} belongs to a different agent"
                    ));
                }
                session.close(current_time);
                Ok(())
            },
            None => Err(err_rag_session_not_found(session_id)),
        }
    }

    ## Close all sessions for an agent
    F close_agent_sessions(~self, agent_id: &Str, current_time: i64) {
        ~i: u32 = 0;
        W i < self.sessions.len() as u32 {
            ~session = self.sessions.get_mut(i as usize);
            if session.agent_id == *agent_id && !session.is_closed() {
                session.close(current_time);
            }
            i = i + 1;
        }
    }

    ## Get memory IDs for a session (for memory retrieval)
    F get_session_memories(&self, session_id: u64) -> Vec<u64> {
        M self.get_session(session_id) {
            Some(session) => {
                ~result = Vec.new();
                ~i: u32 = 0;
                W i < session.memory_ids.len() as u32 {
                    ~mem_id = session.memory_ids.get(i as usize);
                    result.push(*mem_id);
                    i = i + 1;
                }
                result
            },
            None => Vec.new(),
        }
    }

    ## Build session graph edges: SESSION_CONTEXT edges from session to memories
    ## Returns list of (from_node_id, to_node_id) pairs
    F build_session_edges(&self, session_id: u64,
                          memory_to_graph: &Vec<(u64, u64)>,
                          session_graph_node: u64) -> Vec<(u64, u64)> {
        ~edges = Vec.new();

        M self.get_session(session_id) {
            Some(session) => {
                # Create edges from session node to each memory's graph node
                ~i: u32 = 0;
                W i < session.memory_ids.len() as u32 {
                    ~mem_id = session.memory_ids.get(i as usize);

                    # Find graph node for this memory
                    ~j: u32 = 0;
                    ~found = false;
                    W j < memory_to_graph.len() as u32 && !found {
                        ~pair = memory_to_graph.get(j as usize);
                        if pair.0 == *mem_id {
                            edges.push((session_graph_node, pair.1));
                            found = true;
                        }
                        j = j + 1;
                    }

                    i = i + 1;
                }
            },
            None => {},
        }

        edges
    }

    ## Get session count by status
    F count_by_status(&self, status: u8) -> u32 {
        ~count: u32 = 0;
        ~i: u32 = 0;
        W i < self.sessions.len() as u32 {
            ~session = self.sessions.get(i as usize);
            if session.status == status {
                count = count + 1;
            }
            i = i + 1;
        }
        count
    }

    ## Get total session count
    F session_count(&self) -> u64 {
        self.sessions.len() as u64
    }

    ## Get count of active sessions
    F active_session_count(&self) -> u32 {
        self.count_by_status(SESSION_STATUS_ACTIVE)
    }

    ## Get count of closed sessions
    F closed_session_count(&self) -> u32 {
        self.count_by_status(SESSION_STATUS_CLOSED)
    }

    ## Remove closed sessions older than threshold (cleanup)
    F cleanup_old_sessions(~self, threshold_seconds: u64, current_time: i64) -> u32 {
        ~removed_count: u32 = 0;
        ~new_sessions = Vec.new();

        ~i: u32 = 0;
        W i < self.sessions.len() as u32 {
            ~session = self.sessions.get(i as usize);
            ~should_keep = true;

            if session.is_closed() {
                ~age_diff = current_time - session.closed_at;
                ~age: u64 = if age_diff > 0 { age_diff as u64 } else { 0 };
                if age > threshold_seconds {
                    should_keep = false;
                    removed_count = removed_count + 1;
                }
            }

            if should_keep {
                # Reconstruct session (AgentSession has Str/Vec/HashMap fields)
                ~copy = AgentSession.new(
                    session.session_id, session.agent_id.clone(), session.created_at
                );
                copy.status = session.status;
                # Copy memory_ids
                ~mi: u32 = 0;
                W mi < session.memory_ids.len() as u32 {
                    copy.memory_ids.push(*session.memory_ids.get(mi as usize));
                    mi = mi + 1;
                }
                copy.graph_node_id = session.graph_node_id;
                copy.turn_count = session.turn_count;
                copy.token_budget = session.token_budget;
                copy.tokens_used = session.tokens_used;
                copy.last_active_at = session.last_active_at;
                copy.closed_at = session.closed_at;
                # metadata: skip copying for cleanup (not critical)
                new_sessions.push(copy);
            }

            i = i + 1;
        }

        self.sessions = new_sessions;
        removed_count
    }
}
