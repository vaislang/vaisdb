## Agent Memory Storage
##
## Physical storage layer for AI agent memories.
## Provides CRUD operations with:
## - Importance scoring and decay
## - TTL-based expiration
## - Session-based retrieval
## - Type-based filtering
##
## Integrates with SQL tables, vector indexes, and graph nodes
## for hybrid memory retrieval.

U std/vec.Vec
U std/string.Str
U std/option.{Option, Some, None}
U std/hashmap.HashMap
U std/result.{Result, Ok, Err}
U storage/error.{VaisError}
U rag/types.{
    LABEL_MEMORY, EDGE_TYPE_RELATED_TO, EDGE_TYPE_TEMPORAL_NEXT,
    EDGE_TYPE_SESSION_CONTEXT, MEMORY_TYPE_WORKING,
    err_rag_memory_not_found, err_rag_engine_closed
}
U rag/memory/types.{MemoryEntry, MemoryConfig, ImportanceScorer}

## In-memory storage for agent memories
##
## Production implementation would delegate to:
## - SQL tables for structured metadata
## - Vector indexes for semantic search
## - Graph nodes for relationships
S MemoryStore {
    memories: Vec<MemoryEntry>,
    config: MemoryConfig,
    scorer: ImportanceScorer,
    next_memory_id: u64,
    is_open: bool,
}

X MemoryStore {
    ## Create new memory store with configuration
    F new(config: MemoryConfig) -> MemoryStore {
        MemoryStore {
            memories: Vec.new(),
            config: config,
            scorer: ImportanceScorer.default(),
            next_memory_id: 1,
            is_open: false,
        }
    }

    ## Open the memory store
    F open(~self) {
        self.is_open = true
    }

    ## Close the memory store
    F close(~self) {
        self.is_open = false
    }

    ## Insert a new memory entry
    ##
    ## Returns the assigned memory_id.
    ## Initial importance is calculated based on explicit metadata
    ## or defaults to 0.5.
    F insert_memory(
        ~self,
        memory_type: u8,
        content: Str,
        embedding: Vec<f32>,
        metadata: HashMap<Str, Str>,
        session_id: u64,
        current_time: i64,
    ) -> Result<u64, VaisError> {
        I !self.is_open {
            R Err(err_rag_engine_closed())
        }

        ~memory_id = self.next_memory_id
        self.next_memory_id = self.next_memory_id + 1

        # Get TTL for this memory type
        ~ttl_seconds = self.config.get_default_ttl(memory_type)

        # Check for explicit importance in metadata
        ~explicit_importance = metadata.get(&Str.from("importance"))
        ~initial_importance = M explicit_importance {
            Some(val) => {
                M val.parse_f64() {
                    Ok(imp) => {
                        I imp < 0.0 {
                            0.5
                        } E I imp > 1.0 {
                            1.0
                        } E {
                            imp
                        }
                    }
                    Err(_) => 0.5,
                }
            }
            None => 0.5,
        }

        ~entry = MemoryEntry.new(
            memory_id,
            memory_type,
            content,
            embedding,
            metadata,
            initial_importance,
            session_id,
            current_time,
            ttl_seconds,
        )

        self.memories.push(entry)

        Ok(memory_id)
    }

    ## Get memory by ID (immutable reference)
    F get_memory(self, memory_id: u64) -> Option<&MemoryEntry> {
        E entry in &self.memories {
            I entry.memory_id == memory_id {
                R Some(entry)
            }
        }
        None
    }

    ## Get memory by ID (mutable reference)
    F get_memory_mut(~self, memory_id: u64) -> Option<&~MemoryEntry> {
        E entry in &~self.memories {
            I entry.memory_id == memory_id {
                R Some(entry)
            }
        }
        None
    }

    ## Update importance score for a memory
    F update_importance(
        ~self,
        memory_id: u64,
        new_importance: f64,
    ) -> Result<(), VaisError> {
        I !self.is_open {
            R Err(err_rag_engine_closed())
        }

        M self.get_memory_mut(memory_id) {
            Some(entry) => {
                ~clamped = new_importance
                I clamped < 0.0 {
                    clamped = 0.0
                }
                I clamped > 1.0 {
                    clamped = 1.0
                }
                entry.importance = clamped
                Ok(())
            }
            None => Err(err_rag_memory_not_found()),
        }
    }

    ## Touch a memory (update last_accessed, increment access_count)
    F touch_memory(
        ~self,
        memory_id: u64,
        current_time: i64,
    ) -> Result<(), VaisError> {
        I !self.is_open {
            R Err(err_rag_engine_closed())
        }

        M self.get_memory_mut(memory_id) {
            Some(entry) => {
                entry.touch(current_time)
                Ok(())
            }
            None => Err(err_rag_memory_not_found()),
        }
    }

    ## Delete a memory by ID
    F delete_memory(~self, memory_id: u64) -> Result<(), VaisError> {
        I !self.is_open {
            R Err(err_rag_engine_closed())
        }

        ~found_index: i64 = -1
        ~i: u32 = 0
        W i < self.memories.len() as u32 {
            ~entry = self.memories.get(i as u64)
            I entry.memory_id == memory_id {
                found_index = i as i64
                i = self.memories.len() as u32  # exit loop
            } E {
                i = i + 1
            }
        }

        I found_index < 0 {
            R Err(err_rag_memory_not_found())
        }
        self.memories.remove(found_index as u64)
        Ok(())
    }

    ## Delete all expired memories
    ##
    ## Returns count of deleted memories.
    F delete_expired(~self, current_time: i64) -> u32 {
        I !self.is_open {
            R 0
        }

        ~to_delete = Vec.new()

        ~i: u32 = 0
        W i < self.memories.len() as u32 {
            ~entry = self.memories.get(i as u64)
            I entry.is_expired(current_time) {
                to_delete.push(i)
            }
            i = i + 1
        }

        # Remove in reverse order to maintain indices
        ~deleted_count = to_delete.len() as u32
        ~j: i64 = (to_delete.len() as i64) - 1
        W j >= 0 {
            ~idx = to_delete.get(j as u64)
            self.memories.remove(idx as u64)
            j = j - 1
        }

        deleted_count
    }

    ## Get all memories of a specific type
    F get_memories_by_type(self, memory_type: u8) -> Vec<&MemoryEntry> {
        ~result = Vec.new()

        E entry in &self.memories {
            I entry.memory_type == memory_type {
                result.push(entry)
            }
        }

        result
    }

    ## Get all memories for a specific session
    F get_memories_by_session(self, session_id: u64) -> Vec<&MemoryEntry> {
        ~result = Vec.new()

        E entry in &self.memories {
            I entry.session_id == session_id {
                result.push(entry)
            }
        }

        result
    }

    ## Apply importance decay to all memories
    ##
    ## Uses exponential decay based on time since last access.
    ## Decay half-life is taken from config.
    F apply_decay(~self, current_time: i64) {
        I !self.is_open {
            R
        }

        ~half_life = self.config.decay_half_life

        E entry in &~self.memories {
            ~elapsed = (current_time - entry.last_accessed) as f64
            I elapsed > 0.0 {
                entry.importance = self.scorer.decay_importance(
                    entry.importance,
                    elapsed,
                    half_life,
                )
            }
        }
    }

    ## Get total memory count
    F memory_count(self) -> u64 {
        self.memories.len() as u64
    }

    ## Get memory count by type
    F memory_count_by_type(self, memory_type: u8) -> u32 {
        ~count = 0u32

        E entry in &self.memories {
            I entry.memory_type == memory_type {
                count = count + 1
            }
        }

        count
    }

    ## Get memories sorted by importance (descending)
    F get_top_memories(self, limit: u32, current_time: i64) -> Vec<&MemoryEntry> {
        ~result = Vec.new()

        # Collect all memories with decayed importance
        ~ids = Vec.new()
        ~scores = Vec.new()
        ~i: u32 = 0
        W i < self.memories.len() as u32 {
            ~entry = self.memories.get(i as u64)
            ~importance = entry.importance_with_decay(
                current_time,
                self.config.decay_half_life,
            )
            ids.push(i)
            scores.push(importance)
            i = i + 1
        }

        # Insertion sort by importance (descending)
        ~si: u32 = 1
        W si < ids.len() as u32 {
            ~key_id = ids.get(si as u64)
            ~key_score = scores.get(si as u64)
            ~sj: i64 = (si as i64) - 1
            W sj >= 0 {
                ~sj_score = scores.get(sj as u64)
                I sj_score < key_score {
                    ids.set((sj + 1) as u64, ids.get(sj as u64))
                    scores.set((sj + 1) as u64, sj_score)
                    sj = sj - 1
                } E {
                    sj = -1  # exit inner loop
                }
            }
            ids.set((sj + 1) as u64, key_id)
            scores.set((sj + 1) as u64, key_score)
            si = si + 1
        }

        # Take top limit
        ~count = 0u32
        W count < limit {
            I count >= ids.len() as u32 {
                count = limit  # exit loop
            } E {
                ~idx = ids.get(count as u64)
                result.push(self.memories.get(idx as u64))
                count = count + 1
            }
        }

        result
    }

    ## Get memories above importance threshold
    F get_important_memories(
        &self,
        threshold: f64,
        current_time: i64,
    ) -> Vec<&MemoryEntry> {
        ~result = Vec.new()

        E entry in &self.memories {
            ~importance = entry.importance_with_decay(
                current_time,
                self.config.decay_half_life,
            )
            I importance >= threshold {
                result.push(entry)
            }
        }

        result
    }

    ## Consolidate working memories above threshold into episodic memories
    ##
    ## This would typically:
    ## 1. Find high-importance working memories
    ## 2. Merge/summarize related working memories
    ## 3. Create new episodic memory entries
    ## 4. Delete original working memories
    ##
    ## Returns count of working memories consolidated.
    F consolidate_working_memories(
        ~self,
        current_time: i64,
    ) -> Result<u32, VaisError> {
        I !self.is_open {
            R Err(err_rag_engine_closed())
        }

        ~threshold = self.config.consolidation_threshold

        # Find high-importance working memories
        ~candidates = Vec.new()
        E entry in &self.memories {
            I entry.memory_type == MEMORY_TYPE_WORKING {
                ~importance = entry.importance_with_decay(
                    current_time,
                    self.config.decay_half_life,
                )
                I importance >= threshold {
                    candidates.push(entry.memory_id)
                }
            }
        }

        # TODO: In production, this would:
        # - Group related working memories by session/topic
        # - Use LLM to summarize/merge content
        # - Create episodic memory with combined context
        # - Transfer graph relationships
        # For now, just return count of candidates
        Ok(candidates.len() as u32)
    }

    ## Evict least important working memories if over limit
    ##
    ## Returns count of evicted memories.
    F evict_working_memories(
        ~self,
        current_time: i64,
    ) -> u32 {
        I !self.is_open {
            R 0
        }

        ~max_entries = self.config.max_working_memory_entries as u64

        # Count working memories
        ~wm_ids = Vec.new()
        ~wm_scores = Vec.new()

        ~i: u32 = 0
        W i < self.memories.len() as u32 {
            ~entry = self.memories.get(i as u64)
            I entry.memory_type == MEMORY_TYPE_WORKING {
                ~importance = entry.importance_with_decay(
                    current_time,
                    self.config.decay_half_life,
                )
                wm_ids.push(entry.memory_id)
                wm_scores.push(importance)
            }
            i = i + 1
        }

        I wm_ids.len() <= max_entries {
            R 0
        }

        # Insertion sort by importance (ascending, least important first)
        ~si: u32 = 1
        W si < wm_ids.len() as u32 {
            ~key_id = wm_ids.get(si as u64)
            ~key_score = wm_scores.get(si as u64)
            ~sj: i64 = (si as i64) - 1
            W sj >= 0 {
                ~sj_score = wm_scores.get(sj as u64)
                I sj_score > key_score {
                    wm_ids.set((sj + 1) as u64, wm_ids.get(sj as u64))
                    wm_scores.set((sj + 1) as u64, sj_score)
                    sj = sj - 1
                } E {
                    sj = -1  # exit inner loop
                }
            }
            wm_ids.set((sj + 1) as u64, key_id)
            wm_scores.set((sj + 1) as u64, key_score)
            si = si + 1
        }

        # Evict excess memories (least important first)
        ~to_evict = wm_ids.len() - max_entries
        ~evicted = 0u32

        ~ei: u32 = 0
        W ei < to_evict as u32 {
            ~mid = wm_ids.get(ei as u64)
            M self.delete_memory(mid) {
                Ok(_) => { evicted = evicted + 1 },
                Err(_) => {},
            }
            ei = ei + 1
        }

        evicted
    }
}
