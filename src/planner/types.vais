# Hybrid Query Planner — Core Types
# Defines HybridPlanNode (cross-engine plan tree), HybridCost (per-engine cost breakdown),
# and supporting types for the unified query planner across vector, graph, SQL, and full-text engines.
#
# HybridPlanNode extends PlanNode with engine-specific scan nodes:
# - VectorScan: HNSW ANN search with MVCC post-filter
# - GraphTraverse: BFS/DFS graph traversal with edge type filter
# - FullTextScan: BM25 inverted index search
# - ScoreFusion: combine results from multiple engines (WeightedSum, RRF)
# - CrossEngineJoin: join SQL rows with engine results (vector → graph, etc.)
# - SqlPlan: delegate to existing SQL PlanNode

U storage/error.{VaisError};
U sql/parser/ast.{Expr, JoinType, OrderByItem, SelectQuery};
U sql/planner/mod.{PlanNode, CostEstimate, ProjectColumn, AggregateSpec, WindowSpec};

# ============================================================================
# Error Codes: EE=00 (common/planner), CC=08 (planner)
# ============================================================================

L ERR_CODE_HYBRID_PLAN_FAILED: Str = "VAIS-0008001";
L ERR_CODE_HYBRID_COST_FAILED: Str = "VAIS-0008002";
L ERR_CODE_HYBRID_ENGINE_MISMATCH: Str = "VAIS-0008003";
L ERR_CODE_HYBRID_UNSUPPORTED_COMBO: Str = "VAIS-0008004";
L ERR_CODE_HYBRID_SCORE_FUSION_INVALID: Str = "VAIS-0008005";

F err_hybrid_plan_failed(reason: Str) -> VaisError {
    VaisError.new(ERR_CODE_HYBRID_PLAN_FAILED, "Hybrid plan failed: {reason}")
}

F err_hybrid_cost_failed(reason: Str) -> VaisError {
    VaisError.new(ERR_CODE_HYBRID_COST_FAILED, "Hybrid cost estimation failed: {reason}")
}

F err_hybrid_engine_mismatch(reason: Str) -> VaisError {
    VaisError.new(ERR_CODE_HYBRID_ENGINE_MISMATCH, "Engine mismatch: {reason}")
}

F err_hybrid_unsupported_combo(reason: Str) -> VaisError {
    VaisError.new(ERR_CODE_HYBRID_UNSUPPORTED_COMBO, "Unsupported engine combination: {reason}")
}

F err_hybrid_score_fusion_invalid(reason: Str) -> VaisError {
    VaisError.new(ERR_CODE_HYBRID_SCORE_FUSION_INVALID, "Invalid score fusion config: {reason}")
}

# ============================================================================
# Engine Type Tags
# ============================================================================

# Identifies which engine a plan node belongs to
E EngineType {
    Sql,
    Vector,
    Graph,
    FullText,
    Hybrid,    # Cross-engine fusion
}

X EngineType {
    F name(self) -> Str {
        M self {
            EngineType.Sql => "sql".to_string(),
            EngineType.Vector => "vector".to_string(),
            EngineType.Graph => "graph".to_string(),
            EngineType.FullText => "fulltext".to_string(),
            EngineType.Hybrid => "hybrid".to_string(),
        }
    }
}

# ============================================================================
# Hybrid Cost — Per-Engine Cost Breakdown
# ============================================================================

# Extended cost estimate with per-engine breakdown
# Used by EXPLAIN ANALYZE to show "80% graph, 15% vector, 5% SQL"
S HybridCost {
    # Aggregate cost (sum of all engines)
    total_io_cost: f64,
    total_cpu_cost: f64,
    total_memory_bytes: u64,
    row_estimate: u64,

    # Per-engine breakdown
    sql_io_cost: f64,
    sql_cpu_cost: f64,
    vector_io_cost: f64,
    vector_cpu_cost: f64,
    graph_io_cost: f64,
    graph_cpu_cost: f64,
    fulltext_io_cost: f64,
    fulltext_cpu_cost: f64,

    # Engine-specific metrics
    vector_dimension: u32,        # Vector dimension (affects SIMD cost)
    vector_ef_search: u32,        # HNSW ef_search parameter
    graph_avg_degree: f64,        # Average node degree (affects traversal cost)
    graph_max_depth: u32,         # Traversal depth limit
    fulltext_posting_length: u64, # Avg posting list length
}

X HybridCost {
    F new() -> HybridCost {
        HybridCost {
            total_io_cost: 0.0,
            total_cpu_cost: 0.0,
            total_memory_bytes: 0,
            row_estimate: 0,
            sql_io_cost: 0.0,
            sql_cpu_cost: 0.0,
            vector_io_cost: 0.0,
            vector_cpu_cost: 0.0,
            graph_io_cost: 0.0,
            graph_cpu_cost: 0.0,
            fulltext_io_cost: 0.0,
            fulltext_cpu_cost: 0.0,
            vector_dimension: 0,
            vector_ef_search: 0,
            graph_avg_degree: 0.0,
            graph_max_depth: 0,
            fulltext_posting_length: 0,
        }
    }

    # Total weighted cost (I/O × 1.0 + CPU × 0.1), compatible with SQL CostEstimate
    F total(self) -> f64 {
        self.total_io_cost * 1.0 + self.total_cpu_cost * 0.1
    }

    # Add another HybridCost (for composing sub-plan costs)
    F add(self, other: &HybridCost) -> HybridCost {
        HybridCost {
            total_io_cost: self.total_io_cost + other.total_io_cost,
            total_cpu_cost: self.total_cpu_cost + other.total_cpu_cost,
            total_memory_bytes: self.total_memory_bytes + other.total_memory_bytes,
            row_estimate: self.row_estimate,  # Keep first as output cardinality
            sql_io_cost: self.sql_io_cost + other.sql_io_cost,
            sql_cpu_cost: self.sql_cpu_cost + other.sql_cpu_cost,
            vector_io_cost: self.vector_io_cost + other.vector_io_cost,
            vector_cpu_cost: self.vector_cpu_cost + other.vector_cpu_cost,
            graph_io_cost: self.graph_io_cost + other.graph_io_cost,
            graph_cpu_cost: self.graph_cpu_cost + other.graph_cpu_cost,
            fulltext_io_cost: self.fulltext_io_cost + other.fulltext_io_cost,
            fulltext_cpu_cost: self.fulltext_cpu_cost + other.fulltext_cpu_cost,
            vector_dimension: I self.vector_dimension > 0 { self.vector_dimension } E { other.vector_dimension },
            vector_ef_search: I self.vector_ef_search > 0 { self.vector_ef_search } E { other.vector_ef_search },
            graph_avg_degree: I self.graph_avg_degree > 0.0 { self.graph_avg_degree } E { other.graph_avg_degree },
            graph_max_depth: I self.graph_max_depth > 0 { self.graph_max_depth } E { other.graph_max_depth },
            fulltext_posting_length: I self.fulltext_posting_length > 0 { self.fulltext_posting_length } E { other.fulltext_posting_length },
        }
    }

    # Convert from SQL CostEstimate (for wrapping existing SQL plan costs)
    F from_sql_cost(cost: &CostEstimate) -> HybridCost {
        HybridCost {
            total_io_cost: cost.io_cost,
            total_cpu_cost: cost.cpu_cost,
            total_memory_bytes: 0,
            row_estimate: cost.row_estimate,
            sql_io_cost: cost.io_cost,
            sql_cpu_cost: cost.cpu_cost,
            vector_io_cost: 0.0,
            vector_cpu_cost: 0.0,
            graph_io_cost: 0.0,
            graph_cpu_cost: 0.0,
            fulltext_io_cost: 0.0,
            fulltext_cpu_cost: 0.0,
            vector_dimension: 0,
            vector_ef_search: 0,
            graph_avg_degree: 0.0,
            graph_max_depth: 0,
            fulltext_posting_length: 0,
        }
    }

    # Per-engine cost percentage for EXPLAIN ANALYZE breakdown
    F engine_breakdown(self) -> Vec<EngineBreakdown> {
        ~total = self.total();
        I total <= 0.0 {
            R Vec.new();
        }

        ~result: Vec<EngineBreakdown> = Vec.new();

        ~sql_total = self.sql_io_cost * 1.0 + self.sql_cpu_cost * 0.1;
        I sql_total > 0.0 {
            result.push(EngineBreakdown {
                engine: EngineType.Sql,
                cost: sql_total,
                percentage: (sql_total / total) * 100.0,
            });
        }

        ~vector_total = self.vector_io_cost * 1.0 + self.vector_cpu_cost * 0.1;
        I vector_total > 0.0 {
            result.push(EngineBreakdown {
                engine: EngineType.Vector,
                cost: vector_total,
                percentage: (vector_total / total) * 100.0,
            });
        }

        ~graph_total = self.graph_io_cost * 1.0 + self.graph_cpu_cost * 0.1;
        I graph_total > 0.0 {
            result.push(EngineBreakdown {
                engine: EngineType.Graph,
                cost: graph_total,
                percentage: (graph_total / total) * 100.0,
            });
        }

        ~ft_total = self.fulltext_io_cost * 1.0 + self.fulltext_cpu_cost * 0.1;
        I ft_total > 0.0 {
            result.push(EngineBreakdown {
                engine: EngineType.FullText,
                cost: ft_total,
                percentage: (ft_total / total) * 100.0,
            });
        }

        # Sort by percentage descending
        result.sort_by(|a, b| b.percentage.partial_cmp(&a.percentage).unwrap_or(std.cmp.Ordering.Equal));
        result
    }
}

# Single engine's cost share
S EngineBreakdown {
    engine: EngineType,
    cost: f64,
    percentage: f64,
}

# ============================================================================
# Score Fusion Configuration
# ============================================================================

# How to combine scores from multiple engines
E FusionMethod {
    # Combined score = weight_a × norm_a + weight_b × norm_b
    WeightedSum { weight_a: f64, weight_b: f64 },

    # Score = Σ 1/(k + rank_i) across all result lists. k=60 default
    ReciprocalRankFusion { k: u32 },
}

X FusionMethod {
    F default_weighted() -> FusionMethod {
        FusionMethod.WeightedSum { weight_a: 0.5, weight_b: 0.5 }
    }

    F default_rrf() -> FusionMethod {
        FusionMethod.ReciprocalRankFusion { k: 60 }
    }
}

# ============================================================================
# Vector Scan Parameters (for HybridPlanNode.VectorScan)
# ============================================================================

S VectorScanParams {
    table_name: Str,
    column_name: Str,
    query_vector_expr: Expr,   # Expression that evaluates to query vector (literal or parameter)
    top_k: u32,
    ef_search: Option<u32>,    # Override HNSW ef_search (None = use index default)
    pre_filter: Option<Expr>,  # SQL WHERE pushed into vector pre-filter
    post_filter: Option<Expr>, # Residual filter after vector search
}

X VectorScanParams {
    F new(table_name: Str, column_name: Str, query_vector_expr: Expr, top_k: u32) -> VectorScanParams {
        VectorScanParams {
            table_name,
            column_name,
            query_vector_expr,
            top_k,
            ef_search: None,
            pre_filter: None,
            post_filter: None,
        }
    }

    F with_ef_search(~self, ef: u32) -> ~VectorScanParams {
        self.ef_search = Some(ef);
        self
    }

    F with_pre_filter(~self, filter: Expr) -> ~VectorScanParams {
        self.pre_filter = Some(filter);
        self
    }

    F with_post_filter(~self, filter: Expr) -> ~VectorScanParams {
        self.post_filter = Some(filter);
        self
    }
}

# ============================================================================
# Graph Traverse Parameters (for HybridPlanNode.GraphTraverse)
# ============================================================================

L DIRECTION_OUTGOING: u8 = 0;
L DIRECTION_INCOMING: u8 = 1;
L DIRECTION_BOTH: u8 = 2;

S GraphTraverseNodeParams {
    start_node_expr: Expr,             # Expression evaluating to start node ID
    max_depth: u32,                     # 0 = unlimited
    direction: u8,                      # OUTGOING, INCOMING, BOTH
    edge_type_filter: Option<Vec<Str>>, # Filter by edge type names
    return_paths: bool,                 # Include full path info in output
    use_dfs: bool,                      # true = DFS, false = BFS
    filter: Option<Expr>,               # SQL WHERE pushed into traversal filter
}

X GraphTraverseNodeParams {
    F new(start_node_expr: Expr, max_depth: u32) -> GraphTraverseNodeParams {
        GraphTraverseNodeParams {
            start_node_expr,
            max_depth,
            direction: DIRECTION_OUTGOING,
            edge_type_filter: None,
            return_paths: false,
            use_dfs: false,
            filter: None,
        }
    }

    F with_direction(~self, direction: u8) -> ~GraphTraverseNodeParams {
        self.direction = direction;
        self
    }

    F with_edge_filter(~self, types: Vec<Str>) -> ~GraphTraverseNodeParams {
        self.edge_type_filter = Some(types);
        self
    }

    F with_paths(~self) -> ~GraphTraverseNodeParams {
        self.return_paths = true;
        self
    }

    F with_dfs(~self) -> ~GraphTraverseNodeParams {
        self.use_dfs = true;
        self
    }

    F with_filter(~self, filter: Expr) -> ~GraphTraverseNodeParams {
        self.filter = Some(filter);
        self
    }
}

# ============================================================================
# FullText Scan Parameters (for HybridPlanNode.FullTextScan)
# ============================================================================

E FullTextSearchMode {
    Simple,             # Basic BM25 term matching
    Phrase { slop: u32 },   # Position-aware phrase matching
    Boolean,            # AND/OR/NOT operators
}

S FullTextScanParams {
    table_name: Str,
    column_name: Str,
    query_text_expr: Expr,  # Expression evaluating to search query string
    top_k: u32,
    search_mode: FullTextSearchMode,
    filter: Option<Expr>,   # SQL WHERE pushed into full-text filter
}

X FullTextScanParams {
    F new(table_name: Str, column_name: Str, query_text_expr: Expr, top_k: u32) -> FullTextScanParams {
        FullTextScanParams {
            table_name,
            column_name,
            query_text_expr,
            top_k,
            search_mode: FullTextSearchMode.Simple,
            filter: None,
        }
    }

    F with_mode(~self, mode: FullTextSearchMode) -> ~FullTextScanParams {
        self.search_mode = mode;
        self
    }

    F with_filter(~self, filter: Expr) -> ~FullTextScanParams {
        self.filter = Some(filter);
        self
    }
}

# ============================================================================
# Hybrid Plan Node — Cross-Engine Execution Plan
# ============================================================================

# The core plan tree node for hybrid queries spanning multiple engines
L HybridPlanNode =
    # Delegate to existing SQL planner's PlanNode
    SqlPlan { plan: PlanNode, cost: HybridCost } |

    # HNSW ANN search via VECTOR_SEARCH()
    VectorScan { params: VectorScanParams, alias: Option<Str>, cost: HybridCost } |

    # Graph BFS/DFS traversal via GRAPH_TRAVERSE()
    GraphTraverse { params: GraphTraverseNodeParams, alias: Option<Str>, cost: HybridCost } |

    # Full-text BM25 search via FULLTEXT_MATCH()
    FullTextScan { params: FullTextScanParams, alias: Option<Str>, cost: HybridCost } |

    # Score fusion: combine results from two engine scans
    ScoreFusion {
        left: Box<HybridPlanNode>,
        right: Box<HybridPlanNode>,
        method: FusionMethod,
        top_k: u32,
        cost: HybridCost,
    } |

    # Cross-engine join: join SQL table with engine scan results
    # e.g., SELECT * FROM docs d JOIN VECTOR_SEARCH(...) v ON d.id = v.row_id
    CrossEngineJoin {
        left: Box<HybridPlanNode>,
        right: Box<HybridPlanNode>,
        join_type: JoinType,
        condition: Option<Expr>,
        cost: HybridCost,
    } |

    # Filter applied to hybrid plan output
    HybridFilter { input: Box<HybridPlanNode>, predicate: Expr, cost: HybridCost } |

    # Project columns from hybrid plan output
    HybridProject { input: Box<HybridPlanNode>, columns: Vec<ProjectColumn>, cost: HybridCost } |

    # Sort hybrid plan output
    HybridSort { input: Box<HybridPlanNode>, order_by: Vec<OrderByItem>, cost: HybridCost } |

    # Limit/offset on hybrid plan output
    HybridLimit { input: Box<HybridPlanNode>, limit: Option<u64>, offset: Option<u64>, cost: HybridCost } |

    # Aggregate on hybrid plan output
    HybridAggregate {
        input: Box<HybridPlanNode>,
        group_by: Vec<Expr>,
        aggregates: Vec<AggregateSpec>,
        having: Option<Expr>,
        cost: HybridCost,
    };

X HybridPlanNode {
    # Get the cost of this plan node
    F get_cost(self) -> &HybridCost {
        M self {
            HybridPlanNode.SqlPlan { cost, .. } => cost,
            HybridPlanNode.VectorScan { cost, .. } => cost,
            HybridPlanNode.GraphTraverse { cost, .. } => cost,
            HybridPlanNode.FullTextScan { cost, .. } => cost,
            HybridPlanNode.ScoreFusion { cost, .. } => cost,
            HybridPlanNode.CrossEngineJoin { cost, .. } => cost,
            HybridPlanNode.HybridFilter { cost, .. } => cost,
            HybridPlanNode.HybridProject { cost, .. } => cost,
            HybridPlanNode.HybridSort { cost, .. } => cost,
            HybridPlanNode.HybridLimit { cost, .. } => cost,
            HybridPlanNode.HybridAggregate { cost, .. } => cost,
        }
    }

    # Get the engine type of this plan node
    F engine_type(self) -> EngineType {
        M self {
            HybridPlanNode.SqlPlan { .. } => EngineType.Sql,
            HybridPlanNode.VectorScan { .. } => EngineType.Vector,
            HybridPlanNode.GraphTraverse { .. } => EngineType.Graph,
            HybridPlanNode.FullTextScan { .. } => EngineType.FullText,
            HybridPlanNode.ScoreFusion { .. } => EngineType.Hybrid,
            HybridPlanNode.CrossEngineJoin { .. } => EngineType.Hybrid,
            HybridPlanNode.HybridFilter { input, .. } => input.engine_type(),
            HybridPlanNode.HybridProject { input, .. } => input.engine_type(),
            HybridPlanNode.HybridSort { input, .. } => input.engine_type(),
            HybridPlanNode.HybridLimit { input, .. } => input.engine_type(),
            HybridPlanNode.HybridAggregate { input, .. } => input.engine_type(),
        }
    }

    # Get estimated output row count
    F row_estimate(self) -> u64 {
        self.get_cost().row_estimate
    }

    # Check I this plan involves multiple engines
    F is_hybrid(self) -> bool {
        M self {
            HybridPlanNode.ScoreFusion { .. } => true,
            HybridPlanNode.CrossEngineJoin { left, right, .. } => {
                left.engine_type() != right.engine_type()
            },
            HybridPlanNode.HybridFilter { input, .. } => input.is_hybrid(),
            HybridPlanNode.HybridProject { input, .. } => input.is_hybrid(),
            HybridPlanNode.HybridSort { input, .. } => input.is_hybrid(),
            HybridPlanNode.HybridLimit { input, .. } => input.is_hybrid(),
            HybridPlanNode.HybridAggregate { input, .. } => input.is_hybrid(),
            _ => false,
        }
    }
}

# ============================================================================
# Query Profile — Result of query analysis
# ============================================================================

# Detected engine usage in a query
S QueryProfile {
    uses_sql: bool,
    uses_vector: bool,
    uses_graph: bool,
    uses_fulltext: bool,
    vector_calls: Vec<VectorScanParams>,
    graph_calls: Vec<GraphTraverseNodeParams>,
    fulltext_calls: Vec<FullTextScanParams>,
    sql_tables: Vec<Str>,              # Regular SQL tables referenced
}

X QueryProfile {
    F new() -> QueryProfile {
        QueryProfile {
            uses_sql: false,
            uses_vector: false,
            uses_graph: false,
            uses_fulltext: false,
            vector_calls: Vec.new(),
            graph_calls: Vec.new(),
            fulltext_calls: Vec.new(),
            sql_tables: Vec.new(),
        }
    }

    # Count of engines involved
    F engine_count(self) -> u32 {
        ~count: u32 = 0;
        I self.uses_sql { count += 1; }
        I self.uses_vector { count += 1; }
        I self.uses_graph { count += 1; }
        I self.uses_fulltext { count += 1; }
        count
    }

    # Whether this is a single-engine query (can use fast path)
    F is_single_engine(self) -> bool {
        self.engine_count() == 1
    }

    # Whether this is a pure SQL query (no engine functions)
    F is_pure_sql(self) -> bool {
        self.uses_sql && !self.uses_vector && !self.uses_graph && !self.uses_fulltext
    }

    # Whether this requires cross-engine score fusion
    F needs_score_fusion(self) -> bool {
        ~engine_count: u32 = 0;
        I self.uses_vector { engine_count += 1; }
        I self.uses_fulltext { engine_count += 1; }
        engine_count >= 2
    }
}

# ============================================================================
# Hybrid Execution Stats — For EXPLAIN ANALYZE
# ============================================================================

S HybridExecStats {
    engine: EngineType,
    rows_produced: u64,
    rows_scanned: u64,
    pages_read: u64,
    elapsed_us: u64,           # Microseconds for this node
    memory_bytes: u64,
    children: Vec<HybridExecStats>,
}

X HybridExecStats {
    F new(engine: EngineType) -> HybridExecStats {
        HybridExecStats {
            engine,
            rows_produced: 0,
            rows_scanned: 0,
            pages_read: 0,
            elapsed_us: 0,
            memory_bytes: 0,
            children: Vec.new(),
        }
    }

    F total_elapsed_us(self) -> u64 {
        ~total = self.elapsed_us;
        L child: self.children.iter() {
            total += child.total_elapsed_us();
        }
        total
    }
}
