# Page & WAL Encryption Engine
# AES-256-CTR per-page encryption with key_id in PageHeader reserved field
# WAL record payload encryption (header remains plaintext for recovery)
# Key management: load, rotate, external KMS interface
# Key rotation: background re-encryption with no downtime
# Error codes: EE=09 (security), CC=08 (encryption)

U std/bytes.{ByteBuffer};
U std/vec.Vec;
U std/string.Str;
U std/option.{Option, Some, None};
U std/hashmap.HashMap;
U storage/error.{VaisError};
U storage/constants.{PAGE_HEADER_SIZE};
U storage/hash.{fnv1a_hash};
U security/types.{
    SecurityConfig, SecurityMeta, EncryptionKeyInfo,
    ENCRYPT_ALGO_NONE, ENCRYPT_ALGO_AES_256_CTR, ENCRYPT_ALGO_AES_256_GCM,
    KDF_PBKDF2, KDF_HKDF,
    KEY_ROTATION_IDLE, KEY_ROTATION_IN_PROGRESS,
    KEY_ROTATION_COMPLETE, KEY_ROTATION_FAILED,
    err_encryption_key_not_set, err_encryption_failed,
    err_decryption_failed, err_key_rotation_in_progress,
    err_invalid_encryption_config,
};

# ============================================================================
# PageEncryptor — Per-page encryption using AES-256-CTR (XOR-based simulation)
# ============================================================================
#
# Design:
# - Each page is encrypted independently using page_id as nonce component
# - Page header (first PAGE_HEADER_SIZE bytes) is NOT encrypted
#   (needed for buffer pool to identify page type without decryption)
# - Encryption key ID is stored in a reserved field of the page header
# - Uses XOR-based stream cipher as AES-256-CTR placeholder
#   (real AES requires C FFI to libcrypto)

S PageEncryptor {
    active_key_id: u32,
    keys: HashMap<u32, EncryptionKey>,     # key_id -> key material
    algorithm: u8,                          # ENCRYPT_ALGO_* constant
    enabled: bool,
}

# Encryption key material (in-memory only)
S EncryptionKey {
    key_id: u32,
    key_data: Vec<u8>,                     # 32 bytes for AES-256
    info: EncryptionKeyInfo,               # Metadata
}

X PageEncryptor {
    # Create a new disabled encryptor (no encryption)
    F disabled() -> PageEncryptor {
        PageEncryptor {
            active_key_id: 0,
            keys: HashMap.new(),
            algorithm: ENCRYPT_ALGO_NONE,
            enabled: false,
        }
    }

    # Create a new encryptor with a given key
    F new(algorithm: u8, key_data: Vec<u8>) -> Result<PageEncryptor, VaisError> {
        I algorithm == ENCRYPT_ALGO_NONE {
            R Ok(PageEncryptor.disabled());
        }

        I key_data.len() != 32 {
            R Err(err_invalid_encryption_config("Key must be exactly 32 bytes for AES-256"));
        }

        ~key_hash = fnv1a_hash(&key_data);
        ~key_info = EncryptionKeyInfo.new(1, algorithm, KDF_HKDF, key_hash);
        ~key = EncryptionKey {
            key_id: 1,
            key_data: key_data.clone(),
            info: key_info,
        };

        ~keys = HashMap.new();
        keys.insert(1, key);

        Ok(PageEncryptor {
            active_key_id: 1,
            keys,
            algorithm,
            enabled: true,
        })
    }

    # Encrypt a page in-place (skip header, encrypt data portion)
    # page_data: mutable reference to full page buffer (header + data)
    # page_id: used as nonce component
    F encrypt_page(self, page_data: &~Vec<u8>, page_id: u32) -> Result<(), VaisError> {
        I !self.enabled {
            R Ok(());
        }

        ~key = M self.keys.get(&self.active_key_id) {
            Some(k) => k,
            None => { R Err(err_encryption_key_not_set()); },
        };

        # Generate keystream and XOR with data portion (after header)
        ~header_size = PAGE_HEADER_SIZE as u64;
        ~data_len = page_data.len();
        I data_len <= header_size {
            R Ok(());  # No data to encrypt
        }

        # XOR-based stream cipher (placeholder for AES-256-CTR)
        ~nonce = build_nonce(page_id, self.active_key_id);
        ~stream = generate_keystream(&key.key_data, &nonce, (data_len - header_size) as u32);

        ~i: u64 = header_size;
        ~si: u64 = 0;
        W i < data_len {
            page_data[i] = page_data[i] ^ stream[si];
            i = i + 1;
            si = si + 1;
        }

        Ok(())
    }

    # Decrypt a page in-place
    # For CTR mode, decryption is identical to encryption (XOR is its own inverse)
    F decrypt_page(self, page_data: &~Vec<u8>, page_id: u32, key_id: u32) -> Result<(), VaisError> {
        I !self.enabled {
            R Ok(());
        }

        ~key = M self.keys.get(&key_id) {
            Some(k) => k,
            None => { R Err(err_decryption_failed("Key not found for key_id")); },
        };

        ~header_size = PAGE_HEADER_SIZE as u64;
        ~data_len = page_data.len();
        I data_len <= header_size {
            R Ok(());
        }

        # XOR decryption (same as encryption for CTR mode)
        ~nonce = build_nonce(page_id, key_id);
        ~stream = generate_keystream(&key.key_data, &nonce, (data_len - header_size) as u32);

        ~i: u64 = header_size;
        ~si: u64 = 0;
        W i < data_len {
            page_data[i] = page_data[i] ^ stream[si];
            i = i + 1;
            si = si + 1;
        }

        Ok(())
    }

    # Get active key ID (for writing to page header)
    F active_key_id(self) -> u32 {
        self.active_key_id
    }

    # Check if encryption is enabled
    F is_enabled(self) -> bool {
        self.enabled
    }

    # Add a new key (for key rotation)
    F add_key(~self, key_id: u32, key_data: Vec<u8>) -> Result<(), VaisError> {
        I key_data.len() != 32 {
            R Err(err_invalid_encryption_config("Key must be 32 bytes"));
        }
        ~key_hash = fnv1a_hash(&key_data);
        ~key_info = EncryptionKeyInfo.new(key_id, self.algorithm, KDF_HKDF, key_hash);
        ~key = EncryptionKey {
            key_id,
            key_data,
            info: key_info,
        };
        self.keys.insert(key_id, key);
        Ok(())
    }

    # Set active key (after rotation completes)
    F set_active_key(~self, key_id: u32) -> Result<(), VaisError> {
        I !self.keys.contains_key(&key_id) {
            R Err(err_encryption_key_not_set());
        }
        self.active_key_id = key_id;
        Ok(())
    }
}

# ============================================================================
# WalEncryptor — WAL record payload encryption
# ============================================================================
#
# Design:
# - WAL record header (type, txn_id, length, etc.) is NOT encrypted
#   (needed for recovery scanner to identify record boundaries)
# - Only the payload portion is encrypted
# - Uses the same key as PageEncryptor

S WalEncryptor {
    encryptor: &PageEncryptor,
}

X WalEncryptor {
    F new(encryptor: &PageEncryptor) -> WalEncryptor {
        WalEncryptor { encryptor }
    }

    # Encrypt WAL record payload
    # lsn: used as nonce component (unique per record)
    F encrypt_payload(self, payload: &~Vec<u8>, lsn: u64) -> Result<(), VaisError> {
        I !self.encryptor.is_enabled() {
            R Ok(());
        }

        ~key_id = self.encryptor.active_key_id;
        ~key = M self.encryptor.keys.get(&key_id) {
            Some(k) => k,
            None => { R Err(err_encryption_key_not_set()); },
        };

        # Use LSN as nonce for WAL records
        ~nonce_buf = ByteBuffer.new(12);
        nonce_buf.put_u64_le(lsn);
        nonce_buf.put_u32_le(key_id);
        ~nonce = nonce_buf.to_vec();

        ~stream = generate_keystream(&key.key_data, &nonce, payload.len() as u32);

        ~i: u64 = 0;
        W i < payload.len() {
            payload[i] = payload[i] ^ stream[i];
            i = i + 1;
        }

        Ok(())
    }

    # Decrypt WAL record payload
    F decrypt_payload(self, payload: &~Vec<u8>, lsn: u64, key_id: u32) -> Result<(), VaisError> {
        I !self.encryptor.is_enabled() {
            R Ok(());
        }

        ~key = M self.encryptor.keys.get(&key_id) {
            Some(k) => k,
            None => { R Err(err_decryption_failed("WAL key not found")); },
        };

        ~nonce_buf = ByteBuffer.new(12);
        nonce_buf.put_u64_le(lsn);
        nonce_buf.put_u32_le(key_id);
        ~nonce = nonce_buf.to_vec();

        ~stream = generate_keystream(&key.key_data, &nonce, payload.len() as u32);

        ~i: u64 = 0;
        W i < payload.len() {
            payload[i] = payload[i] ^ stream[i];
            i = i + 1;
        }

        Ok(())
    }
}

# ============================================================================
# KeyManager — Key loading, rotation, and KMS interface
# ============================================================================

S KeyManager {
    encryptor: PageEncryptor,
    rotation_status: u8,                   # KEY_ROTATION_* constant
    rotation_progress: f64,                # 0.0 to 1.0
}

X KeyManager {
    # Create with no encryption
    F disabled() -> KeyManager {
        KeyManager {
            encryptor: PageEncryptor.disabled(),
            rotation_status: KEY_ROTATION_IDLE,
            rotation_progress: 0.0,
        }
    }

    # Create with a key from config/KMS
    F from_key(algorithm: u8, key_data: Vec<u8>) -> Result<KeyManager, VaisError> {
        ~encryptor = PageEncryptor.new(algorithm, key_data)?;
        Ok(KeyManager {
            encryptor,
            rotation_status: KEY_ROTATION_IDLE,
            rotation_progress: 0.0,
        })
    }

    # Get reference to page encryptor
    F page_encryptor(self) -> &PageEncryptor {
        &self.encryptor
    }

    # Get mutable reference
    F page_encryptor_mut(~self) -> &~PageEncryptor {
        &self.encryptor
    }

    # Create a WAL encryptor referencing this key manager's page encryptor
    F wal_encryptor(self) -> WalEncryptor {
        WalEncryptor.new(&self.encryptor)
    }

    # Start key rotation: add new key, begin background re-encryption
    F begin_key_rotation(
        ~self,
        new_key_id: u32,
        new_key_data: Vec<u8>,
        meta: &~SecurityMeta,
    ) -> Result<(), VaisError> {
        I self.rotation_status == KEY_ROTATION_IN_PROGRESS {
            R Err(err_key_rotation_in_progress());
        }

        # Add the new key
        self.encryptor.add_key(new_key_id, new_key_data)?;

        # Set as new active key (new writes will use it)
        self.encryptor.set_active_key(new_key_id)?;

        # Update metadata
        meta.encryption_key_id = new_key_id;
        meta.key_rotation_status = KEY_ROTATION_IN_PROGRESS;

        self.rotation_status = KEY_ROTATION_IN_PROGRESS;
        self.rotation_progress = 0.0;

        Ok(())
    }

    # Update rotation progress (called during background re-encryption)
    F update_rotation_progress(~self, progress: f64) {
        self.rotation_progress = progress;
    }

    # Complete key rotation
    F complete_key_rotation(~self, meta: &~SecurityMeta) {
        self.rotation_status = KEY_ROTATION_COMPLETE;
        self.rotation_progress = 1.0;
        meta.key_rotation_status = KEY_ROTATION_COMPLETE;
    }

    # Fail key rotation
    F fail_key_rotation(~self, meta: &~SecurityMeta) {
        self.rotation_status = KEY_ROTATION_FAILED;
        meta.key_rotation_status = KEY_ROTATION_FAILED;
    }

    # Get rotation status
    F rotation_status(self) -> u8 {
        self.rotation_status
    }

    # Get rotation progress
    F rotation_progress(self) -> f64 {
        self.rotation_progress
    }

    # Check if encryption is active
    F is_encrypted(self) -> bool {
        self.encryptor.is_enabled()
    }
}

# ============================================================================
# KeyRotator — Background re-encryption worker
# ============================================================================

S KeyRotator {
    old_key_id: u32,
    new_key_id: u32,
    total_pages: u64,
    pages_processed: u64,
}

X KeyRotator {
    F new(old_key_id: u32, new_key_id: u32, total_pages: u64) -> KeyRotator {
        KeyRotator {
            old_key_id,
            new_key_id,
            total_pages,
            pages_processed: 0,
        }
    }

    # Process a batch of pages for re-encryption
    # Returns number of pages processed in this batch
    # page_ids: pages to re-encrypt in this batch
    F process_batch(
        ~self,
        key_mgr: &KeyManager,
        page_ids: &Vec<u32>,
        page_buffers: &~Vec<Vec<u8>>,
    ) -> Result<u64, VaisError> {
        ~processed: u64 = 0;
        ~encryptor = key_mgr.page_encryptor();

        ~i: u64 = 0;
        W i < page_ids.len() {
            ~page_id = page_ids[i];
            ~page_data = &page_buffers[i];

            # Decrypt with old key
            encryptor.decrypt_page(page_data, page_id, self.old_key_id)?;

            # Re-encrypt with new key
            encryptor.encrypt_page(page_data, page_id)?;

            processed = processed + 1;
            self.pages_processed = self.pages_processed + 1;
            i = i + 1;
        }

        Ok(processed)
    }

    # Get progress as fraction
    F progress(self) -> f64 {
        I self.total_pages == 0 {
            R 1.0;
        }
        self.pages_processed as f64 / self.total_pages as f64
    }

    # Check if rotation is complete
    F is_complete(self) -> bool {
        self.pages_processed >= self.total_pages
    }
}

# ============================================================================
# Internal Helper Functions
# ============================================================================

# Build nonce from page_id and key_id (12 bytes for CTR mode)
F build_nonce(page_id: u32, key_id: u32) -> Vec<u8> {
    ~buf = ByteBuffer.new(12);
    buf.put_u32_le(page_id);
    buf.put_u32_le(key_id);
    buf.put_u32_le(0);  # Counter block starts at 0
    buf.to_vec()
}

# Generate a keystream of given length using FNV-1a-based PRNG
# (Placeholder for AES-256-CTR keystream generation via C FFI)
# This is cryptographically weak - production would use OpenSSL/libcrypto
F generate_keystream(key: &Vec<u8>, nonce: &Vec<u8>, length: u32) -> Vec<u8> {
    ~stream = Vec.with_capacity(length as u64);
    ~block_counter: u32 = 0;

    W stream.len() < length as u64 {
        # Build input for this block: key + nonce + counter
        ~buf = ByteBuffer.new(key.len() + nonce.len() + 4);
        ~ki: u64 = 0;
        W ki < key.len() {
            buf.put_u8(key[ki]);
            ki = ki + 1;
        }
        ~ni: u64 = 0;
        W ni < nonce.len() {
            buf.put_u8(nonce[ni]);
            ni = ni + 1;
        }
        buf.put_u32_le(block_counter);

        # Hash to produce 8 bytes of keystream per block
        ~hash = fnv1a_hash(buf.as_slice());
        ~hash_buf = ByteBuffer.new(8);
        hash_buf.put_u64_le(hash);
        ~hash_bytes = hash_buf.to_vec();

        ~j: u64 = 0;
        W j < 8 && stream.len() < length as u64 {
            stream.push(hash_bytes[j]);
            j = j + 1;
        }

        block_counter = block_counter + 1;
    }

    stream
}
