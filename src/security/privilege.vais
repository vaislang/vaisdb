# Privilege Checker Middleware
# Pre-query privilege verification for all SQL operations
# Checks table-level and column-level privileges against session's active roles
# Handles role inheritance via resolved effective roles in SessionContext
# Error codes: EE=09 (security), CC=09 (privilege)

U std/vec.Vec;
U std/string.Str;
U std/option.{Option, Some, None};
U std/hashmap.HashMap;
U storage/error.{VaisError};
U security/types.{
    SessionContext, PrivilegeCheck, GrantEntry,
    SUPERUSER_ROLE_ID, PUBLIC_ROLE_ID, SYSTEM_USER_ID,
    PRIV_SELECT, PRIV_INSERT, PRIV_UPDATE, PRIV_DELETE,
    PRIV_CREATE, PRIV_DROP, PRIV_ALTER, PRIV_ALL,
    OBJ_TYPE_TABLE, OBJ_TYPE_COLUMN, OBJ_TYPE_DATABASE,
    privilege_name,
    err_privilege_denied, err_privilege_insufficient,
    err_privilege_superuser_required,
};
U security/grant.{GrantManager};
U security/role.{RoleManager};

# ============================================================================
# PrivilegeChecker â€” Middleware for pre-query privilege verification
# ============================================================================

S PrivilegeChecker {
    grant_mgr: &GrantManager,
    role_mgr: &RoleManager,
}

X PrivilegeChecker {
    F new(grant_mgr: &GrantManager, role_mgr: &RoleManager) -> PrivilegeChecker {
        PrivilegeChecker { grant_mgr, role_mgr }
    }

    # ========================================================================
    # Table-Level Privilege Checks
    # ========================================================================

    # Check if the session has a specific privilege on a table
    # This is the main entry point for privilege checking before query execution
    F check_table_privilege(
        self,
        session: &SessionContext,
        table_name: &Str,
        priv_type: u8,
    ) -> Result<PrivilegeCheck, VaisError> {
        # Superuser bypasses all checks
        I session.is_superuser {
            R Ok(PrivilegeCheck.allowed(priv_type, table_name.clone(), "superuser"));
        }

        # Resolve all effective roles (direct + inherited)
        ~effective_roles = self.role_mgr.resolve_effective_roles(&session.active_roles);

        # Check each effective role for the required privilege
        ~i: u64 = 0;
        W i < effective_roles.len() {
            ~role_id = effective_roles[i];
            ~grants = self.grant_mgr.get_grants_for_role(role_id);
            ~j: u64 = 0;
            W j < grants.len() {
                ~g = grants[j];
                I g.object_type == OBJ_TYPE_TABLE
                    && g.object_name == *table_name
                    && g.has_privilege(priv_type) {
                    ~role_name = M self.role_mgr.get_role_name(role_id) {
                        Some(n) => n.clone(),
                        None => "unknown",
                    };
                    R Ok(PrivilegeCheck.allowed(priv_type, table_name.clone(), role_name));
                }
                j = j + 1;
            }
            i = i + 1;
        }

        # Also check PUBLIC role (implicit for all users)
        ~pub_grants = self.grant_mgr.get_grants_for_role(PUBLIC_ROLE_ID);
        ~k: u64 = 0;
        W k < pub_grants.len() {
            ~g = pub_grants[k];
            I g.object_type == OBJ_TYPE_TABLE
                && g.object_name == *table_name
                && g.has_privilege(priv_type) {
                R Ok(PrivilegeCheck.allowed(priv_type, table_name.clone(), "public"));
            }
            k = k + 1;
        }

        # Privilege denied
        Ok(PrivilegeCheck.denied(priv_type, table_name.clone()))
    }

    # ========================================================================
    # Column-Level Privilege Checks
    # ========================================================================

    # Check privilege on a specific column
    # Falls back to table-level privilege if no column-specific grant exists
    F check_column_privilege(
        self,
        session: &SessionContext,
        table_name: &Str,
        column_name: &Str,
        priv_type: u8,
    ) -> Result<PrivilegeCheck, VaisError> {
        # Superuser bypasses
        I session.is_superuser {
            R Ok(PrivilegeCheck.allowed(priv_type, table_name.clone(), "superuser"));
        }

        # First check table-level privilege (covers all columns)
        ~table_check = self.check_table_privilege(session, table_name, priv_type)?;
        I table_check.allowed {
            R Ok(table_check);
        }

        # Then check column-specific grants
        ~effective_roles = self.role_mgr.resolve_effective_roles(&session.active_roles);
        ~i: u64 = 0;
        W i < effective_roles.len() {
            ~role_id = effective_roles[i];
            ~grants = self.grant_mgr.get_grants_for_role(role_id);
            ~j: u64 = 0;
            W j < grants.len() {
                ~g = grants[j];
                I g.object_type == OBJ_TYPE_TABLE
                    && g.object_name == *table_name
                    && g.applies_to_column(column_name)
                    && g.has_privilege(priv_type) {
                    ~role_name = M self.role_mgr.get_role_name(role_id) {
                        Some(n) => n.clone(),
                        None => "unknown",
                    };
                    R Ok(PrivilegeCheck.allowed(priv_type, table_name.clone(), role_name));
                }
                j = j + 1;
            }
            i = i + 1;
        }

        Ok(PrivilegeCheck.denied(priv_type, table_name.clone()))
    }

    # ========================================================================
    # Superuser Check
    # ========================================================================

    # Check if the session is a superuser
    F has_superuser(self, session: &SessionContext) -> bool {
        session.is_superuser
    }

    # Require superuser privilege (returns error if not superuser)
    F require_superuser(self, session: &SessionContext) -> Result<(), VaisError> {
        I !session.is_superuser {
            R Err(err_privilege_superuser_required());
        }
        Ok(())
    }

    # ========================================================================
    # Batch Privilege Checks (for multi-table queries)
    # ========================================================================

    # Check SELECT privilege on multiple tables (for JOINs)
    F check_select_on_tables(
        self,
        session: &SessionContext,
        table_names: &Vec<Str>,
    ) -> Result<(), VaisError> {
        ~i: u64 = 0;
        W i < table_names.len() {
            ~check = self.check_table_privilege(session, &table_names[i], PRIV_SELECT)?;
            I !check.allowed {
                R Err(err_privilege_denied(
                    &session.username,
                    &"SELECT",
                    &table_names[i],
                ));
            }
            i = i + 1;
        }
        Ok(())
    }

    # ========================================================================
    # DML-Specific Checks
    # ========================================================================

    # Check privilege for INSERT operation
    F check_insert(
        self,
        session: &SessionContext,
        table_name: &Str,
    ) -> Result<(), VaisError> {
        ~check = self.check_table_privilege(session, table_name, PRIV_INSERT)?;
        I !check.allowed {
            R Err(err_privilege_denied(&session.username, &"INSERT", table_name));
        }
        Ok(())
    }

    # Check privilege for UPDATE operation
    F check_update(
        self,
        session: &SessionContext,
        table_name: &Str,
    ) -> Result<(), VaisError> {
        ~check = self.check_table_privilege(session, table_name, PRIV_UPDATE)?;
        I !check.allowed {
            R Err(err_privilege_denied(&session.username, &"UPDATE", table_name));
        }
        Ok(())
    }

    # Check privilege for DELETE operation
    F check_delete(
        self,
        session: &SessionContext,
        table_name: &Str,
    ) -> Result<(), VaisError> {
        ~check = self.check_table_privilege(session, table_name, PRIV_DELETE)?;
        I !check.allowed {
            R Err(err_privilege_denied(&session.username, &"DELETE", table_name));
        }
        Ok(())
    }

    # Check privilege for SELECT operation
    F check_select(
        self,
        session: &SessionContext,
        table_name: &Str,
    ) -> Result<(), VaisError> {
        ~check = self.check_table_privilege(session, table_name, PRIV_SELECT)?;
        I !check.allowed {
            R Err(err_privilege_denied(&session.username, &"SELECT", table_name));
        }
        Ok(())
    }

    # ========================================================================
    # DDL-Specific Checks
    # ========================================================================

    # Check privilege for CREATE TABLE
    F check_create(
        self,
        session: &SessionContext,
        database_name: &Str,
    ) -> Result<(), VaisError> {
        I session.is_superuser {
            R Ok(());
        }

        # Check CREATE privilege on the database
        ~effective_roles = self.role_mgr.resolve_effective_roles(&session.active_roles);
        ~i: u64 = 0;
        W i < effective_roles.len() {
            ~role_id = effective_roles[i];
            ~grants = self.grant_mgr.get_grants_for_role(role_id);
            ~j: u64 = 0;
            W j < grants.len() {
                ~g = grants[j];
                I g.object_type == OBJ_TYPE_DATABASE
                    && g.object_name == *database_name
                    && g.has_privilege(PRIV_CREATE) {
                    R Ok(());
                }
                j = j + 1;
            }
            i = i + 1;
        }

        Err(err_privilege_denied(&session.username, &"CREATE", database_name))
    }

    # Check privilege for DROP TABLE
    F check_drop(
        self,
        session: &SessionContext,
        table_name: &Str,
    ) -> Result<(), VaisError> {
        ~check = self.check_table_privilege(session, table_name, PRIV_DROP)?;
        I !check.allowed {
            R Err(err_privilege_denied(&session.username, &"DROP", table_name));
        }
        Ok(())
    }

    # Check privilege for ALTER TABLE
    F check_alter(
        self,
        session: &SessionContext,
        table_name: &Str,
    ) -> Result<(), VaisError> {
        ~check = self.check_table_privilege(session, table_name, PRIV_ALTER)?;
        I !check.allowed {
            R Err(err_privilege_denied(&session.username, &"ALTER", table_name));
        }
        Ok(())
    }

    # ========================================================================
    # Combined check for DML statement type
    # ========================================================================

    # Check privilege based on DML operation type constant
    # dml_type: 0=SELECT, 1=INSERT, 2=UPDATE, 3=DELETE
    F check_dml(
        self,
        session: &SessionContext,
        table_name: &Str,
        dml_type: u8,
    ) -> Result<(), VaisError> {
        ~priv_type = M dml_type {
            0 => PRIV_SELECT,
            1 => PRIV_INSERT,
            2 => PRIV_UPDATE,
            3 => PRIV_DELETE,
            _ => { R Err(err_privilege_insufficient()); },
        };

        ~check = self.check_table_privilege(session, table_name, priv_type)?;
        I !check.allowed {
            ~priv_str = privilege_name(priv_type);
            R Err(err_privilege_denied(&session.username, &priv_str, table_name));
        }
        Ok(())
    }
}
