# Stage 5: Transaction Manager Integration Tests
# Tests: MVCC visibility (10 scenarios), snapshot isolation,
#         conflict detection, deadlock detection, undo/rollback,
#         CLOG status tracking, transaction timeout

use std/test.{assert_eq, assert_ne, assert_true, assert_false, describe, it};

use storage/constants.{INVALID_TXN_ID, NULL_UNDO_PTR};
use storage/txn/visibility.{is_visible, is_committed, is_aborted};
use storage/txn/snapshot.{Snapshot};
use storage/txn/clog.{Clog, TxnStatus};
use storage/txn/att.{ActiveTransactionTable, TxnState};
use storage/txn/conflict.{ConflictDetector};
use storage/txn/deadlock.{WaitForGraph};
use storage/txn/undo_entry.{UndoEntry, UndoType};
use storage/page/mvcc.{MvccTupleMeta};

describe("MVCC Visibility - 10 Scenarios") {
    # Scenario 1: Transaction sees its own uncommitted insert
    it("Scenario 1: own uncommitted insert is visible") {
        ~tuple = MvccTupleMeta.new(100, 0);  # Created by txn 100, not expired
        ~snapshot = Snapshot.new(100, vec![100], 99);  # txn 100 is the reader

        # txn 100 can see its own insert (Case 1)
        ~clog = Clog.new(4096, 4);
        clog.set_status(100, TxnStatus.InProgress);

        assert_true(is_visible(&tuple, 100, 0, &snapshot, &clog));
    }

    # Scenario 2: Transaction cannot see another's uncommitted insert
    it("Scenario 2: other's uncommitted insert is not visible") {
        ~tuple = MvccTupleMeta.new(101, 0);  # Created by txn 101
        ~snapshot = Snapshot.new(100, vec![100, 101], 99);

        ~clog = Clog.new(4096, 4);
        clog.set_status(101, TxnStatus.InProgress);

        # txn 100 cannot see txn 101's uncommitted insert
        assert_false(is_visible(&tuple, 100, 0, &snapshot, &clog));
    }

    # Scenario 3: Transaction sees a committed insert from before snapshot
    it("Scenario 3: committed insert from before snapshot is visible") {
        ~tuple = MvccTupleMeta.new(90, 0);  # Created by txn 90

        ~clog = Clog.new(4096, 4);
        clog.set_status(90, TxnStatus.Committed);

        ~snapshot = Snapshot.new(100, vec![100], 99);

        assert_true(is_visible(&tuple, 100, 0, &snapshot, &clog));
    }

    # Scenario 4: Transaction cannot see a committed insert from after snapshot
    it("Scenario 4: committed insert after snapshot is not visible") {
        ~tuple = MvccTupleMeta.new(105, 0);  # Created by txn 105 (after snapshot)

        ~clog = Clog.new(4096, 4);
        clog.set_status(105, TxnStatus.Committed);

        ~snapshot = Snapshot.new(100, vec![100], 99);

        # txn 105 > snapshot boundary → not visible
        assert_false(is_visible(&tuple, 100, 0, &snapshot, &clog));
    }

    # Scenario 5: Deleted tuple is not visible to same transaction
    it("Scenario 5: own delete makes tuple invisible") {
        ~tuple = MvccTupleMeta.new(90, 0);
        tuple.set_expire(100, 0);  # Expired by txn 100

        ~clog = Clog.new(4096, 4);
        clog.set_status(90, TxnStatus.Committed);
        clog.set_status(100, TxnStatus.InProgress);

        ~snapshot = Snapshot.new(100, vec![100], 99);

        # txn 100 deleted this tuple → not visible (Case 3 with own txn)
        assert_false(is_visible(&tuple, 100, 0, &snapshot, &clog));
    }

    # Scenario 6: Deleted by another committed txn before snapshot
    it("Scenario 6: deleted by committed txn before snapshot") {
        ~tuple = MvccTupleMeta.new(80, 0);
        tuple.set_expire(85, 0);

        ~clog = Clog.new(4096, 4);
        clog.set_status(80, TxnStatus.Committed);
        clog.set_status(85, TxnStatus.Committed);

        ~snapshot = Snapshot.new(100, vec![100], 99);

        # Both create and expire are committed before snapshot → not visible (expired)
        assert_false(is_visible(&tuple, 100, 0, &snapshot, &clog));
    }

    # Scenario 7: Deleted by uncommitted txn → still visible
    it("Scenario 7: deleted by uncommitted txn is still visible") {
        ~tuple = MvccTupleMeta.new(80, 0);
        tuple.set_expire(101, 0);  # Expired by txn 101 (uncommitted)

        ~clog = Clog.new(4096, 4);
        clog.set_status(80, TxnStatus.Committed);
        clog.set_status(101, TxnStatus.InProgress);

        ~snapshot = Snapshot.new(100, vec![100, 101], 99);

        # txn 101 hasn't committed → tuple still visible to txn 100
        assert_true(is_visible(&tuple, 100, 0, &snapshot, &clog));
    }

    # Scenario 8: Aborted transaction's insert is not visible
    it("Scenario 8: aborted insert is not visible (fast-path)") {
        ~tuple = MvccTupleMeta.new(95, 0);

        ~clog = Clog.new(4096, 4);
        clog.set_status(95, TxnStatus.Aborted);

        ~snapshot = Snapshot.new(100, vec![100], 99);

        # is_aborted fast-path: aborted txn's tuples never visible
        assert_true(is_aborted(95, &clog));
        assert_false(is_visible(&tuple, 100, 0, &snapshot, &clog));
    }

    # Scenario 9: Command ID visibility within same transaction
    it("Scenario 9: cmd_id ordering within transaction") {
        ~tuple = MvccTupleMeta.new(100, 0);
        tuple.cmd_id = 5;  # Created at command 5

        ~clog = Clog.new(4096, 4);
        clog.set_status(100, TxnStatus.InProgress);

        ~snapshot = Snapshot.new(100, vec![100], 99);

        # Command 10 sees tuple created at command 5
        assert_true(is_visible(&tuple, 100, 10, &snapshot, &clog));

        # Command 3 does NOT see tuple created at command 5
        assert_false(is_visible(&tuple, 100, 3, &snapshot, &clog));
    }

    # Scenario 10: Concurrent updates with snapshot isolation
    it("Scenario 10: snapshot isolation consistency") {
        # txn 100 takes snapshot, then txn 101 updates and commits
        ~tuple_v1 = MvccTupleMeta.new(80, 0);
        tuple_v1.set_expire(101, 0);  # Expired by txn 101

        ~tuple_v2 = MvccTupleMeta.new(101, 0);  # New version by txn 101

        ~clog = Clog.new(4096, 4);
        clog.set_status(80, TxnStatus.Committed);
        clog.set_status(101, TxnStatus.Committed);

        ~snapshot = Snapshot.new(100, vec![100], 99);

        # txn 100's snapshot was taken before txn 101 committed
        # v1 is still visible (101 committed after snapshot)
        assert_true(is_visible(&tuple_v1, 100, 0, &snapshot, &clog));

        # v2 is NOT visible (created by txn 101 which is after snapshot)
        assert_false(is_visible(&tuple_v2, 100, 0, &snapshot, &clog));
    }
}

describe("CLOG") {
    it("should track 2-bit status per transaction") {
        ~clog = Clog.new(4096, 4);

        clog.set_status(1, TxnStatus.InProgress);
        assert_eq(clog.get_status(1), TxnStatus.InProgress);

        clog.set_status(1, TxnStatus.Committed);
        assert_eq(clog.get_status(1), TxnStatus.Committed);

        clog.set_status(2, TxnStatus.Aborted);
        assert_eq(clog.get_status(2), TxnStatus.Aborted);
    }

    it("should handle large transaction IDs") {
        ~clog = Clog.new(4096, 4);

        # Test with transaction IDs spanning multiple pages
        clog.set_status(10000, TxnStatus.Committed);
        assert_eq(clog.get_status(10000), TxnStatus.Committed);

        clog.set_status(10001, TxnStatus.Aborted);
        assert_eq(clog.get_status(10001), TxnStatus.Aborted);
    }
}

describe("Conflict Detection") {
    it("should allow first writer") {
        ~detector = ConflictDetector.new();

        ~result = detector.check_and_lock(100, 1, 10, 0);
        assert_true(result.is_ok());
    }

    it("should detect write-write conflict") {
        ~detector = ConflictDetector.new();

        # txn 100 locks row
        detector.check_and_lock(100, 1, 10, 0).unwrap();

        # txn 101 tries same row → conflict
        ~result = detector.check_and_lock(101, 1, 10, 0);
        assert_true(result.is_err());
    }

    it("should release locks on commit/abort") {
        ~detector = ConflictDetector.new();

        detector.check_and_lock(100, 1, 10, 0).unwrap();
        detector.release_locks(100);

        # Now txn 101 can lock the same row
        ~result = detector.check_and_lock(101, 1, 10, 0);
        assert_true(result.is_ok());
    }
}

describe("Deadlock Detection") {
    it("should detect simple cycle") {
        ~graph = WaitForGraph.new();

        # txn 1 waits for txn 2
        graph.add_wait(1, 2);
        assert_false(graph.has_cycle().is_some());

        # txn 2 waits for txn 1 → cycle!
        graph.add_wait(2, 1);
        ~victim = graph.has_cycle();
        assert_true(victim.is_some());
    }

    it("should detect 3-way cycle") {
        ~graph = WaitForGraph.new();
        graph.add_wait(1, 2);
        graph.add_wait(2, 3);
        assert_false(graph.has_cycle().is_some());

        graph.add_wait(3, 1);  # Completes cycle
        assert_true(graph.has_cycle().is_some());
    }

    it("should resolve after removing transaction") {
        ~graph = WaitForGraph.new();
        graph.add_wait(1, 2);
        graph.add_wait(2, 1);

        # Remove txn 1 (abort victim)
        graph.remove_txn(1);
        assert_false(graph.has_cycle().is_some());
    }
}

describe("Undo Entry") {
    it("should serialize and deserialize round-trip") {
        ~entry = UndoEntry.for_insert(100, 1, 10, 5);
        ~buf = Vec.with_capacity(64);
        buf.resize(64, 0u8);
        ~bb = ByteBuffer.wrap(&buf);
        entry.serialize(&bb);

        ~read_bb = ByteBuffer.wrap_readonly(&buf);
        ~restored = UndoEntry.deserialize(&read_bb).unwrap();
        assert_eq(restored.txn_id, 100);
        assert_eq(restored.undo_type, UndoType.Insert);
        assert_eq(restored.file_id, 1);
        assert_eq(restored.page_id, 10);
        assert_eq(restored.slot_id, 5);
    }

    it("should carry old data for update operations") {
        ~old_data = [1u8, 2, 3, 4, 5, 6, 7, 8];
        ~entry = UndoEntry.for_update(100, 1, 10, 5, &old_data);

        assert_eq(entry.undo_type, UndoType.Update);
        assert_eq(&entry.old_data, &old_data);
    }
}

describe("Active Transaction Table") {
    it("should register and retrieve transactions") {
        ~att = ActiveTransactionTable.new();

        att.register(100, 0);
        ~entry = att.get(100).unwrap();
        assert_eq(entry.txn_id, 100);

        M entry.state {
            TxnState.Active => {},
            _ => panic!("Expected Active state"),
        }
    }

    it("should track state transitions") {
        ~att = ActiveTransactionTable.new();
        att.register(100, 0);

        att.set_state(100, TxnState.Committing);
        ~entry = att.get(100).unwrap();
        M entry.state {
            TxnState.Committing => {},
            _ => panic!("Expected Committing state"),
        }
    }

    it("should find timed-out transactions") {
        ~att = ActiveTransactionTable.new();
        att.register(100, 0);
        att.register(101, 0);

        # Simulate time passing (set old start_time)
        # In real implementation, start_time would be checked against current time
        ~timed_out = att.find_timed_out_transactions(1);  # 1 second timeout
        # Can't easily test timeout without time manipulation
        # Just verify the method exists and returns a list
        assert_true(timed_out.len() >= 0);
    }
}
