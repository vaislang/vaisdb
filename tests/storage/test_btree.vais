# Stage 4: B+Tree Index Integration Tests
# Tests: insert/search/delete, range scan, split/merge, bulk load,
#         key encoding, prefix compression, concurrent access

U std/test.{assert_eq, assert_ne, assert_true, assert_false, describe, it};
U std/bytes.{ByteBuffer};

U storage/constants.{PAGE_SIZE_DEFAULT, NULL_PAGE, PAGE_HEADER_SIZE};
U storage/btree/node.{BTreeInternalNode, BTreeLeafNode};
U storage/btree/entry.{BTreeLeafEntry, BTreeInternalEntry, compare_keys, KeyCmp, key_less_than};
U storage/btree/key.{
    encode_i64_key, decode_i64_key, encode_u64_key, decode_u64_key,
    encode_string_key, encode_composite_key, decode_composite_key,
    common_prefix_length, strip_prefix, reconstruct_key,
    KeyRange,
};
U storage/btree/prefix.{
    compress_keys, decompress_keys, compressed_total_size, compression_ratio,
    compress_keys_with_restarts, decompress_key_with_restarts,
};
U storage/btree/merge.{
    MERGE_UTILIZATION_THRESHOLD, leaf_needs_merge,
    can_merge_leaves, can_merge_internals,
};
U storage/btree/split.{SplitResult};

describe("Key Encoding") {
    it("should encode i64 with correct sort order") {
        # Negative < 0 < Positive
        ~neg = encode_i64_key(-100);
        ~zero = encode_i64_key(0);
        ~pos = encode_i64_key(100);

        assert_true(key_less_than(&neg, &zero));
        assert_true(key_less_than(&zero, &pos));
        assert_true(key_less_than(&neg, &pos));
    }

    it("should decode i64 round-trip") {
        ~values: [i64] = [-9999, -1, 0, 1, 9999, i64.MIN, i64.MAX];
        for val in &values {
            ~encoded = encode_i64_key(*val);
            ~decoded = decode_i64_key(&encoded);
            assert_eq(decoded, *val);
        }
    }

    it("should encode u64 round-trip") {
        ~values: [u64] = [0, 1, 255, 65535, u64.MAX];
        for val in &values {
            ~encoded = encode_u64_key(*val);
            ~decoded = decode_u64_key(&encoded);
            assert_eq(decoded, *val);
        }
    }

    it("should encode composite keys with length prefix") {
        ~k1 = encode_i64_key(42);
        ~k2 = encode_string_key("hello");
        ~composite = encode_composite_key(&[&k1, &k2]);
        ~components = decode_composite_key(&composite);

        assert_eq(components.len(), 2);
        assert_eq(decode_i64_key(&components[0]), 42);
        assert_eq(&components[1], k2.as_slice());
    }
}

describe("Leaf Node") {
    it("should insert and search entries") {
        ~leaf = BTreeLeafNode.new(1, PAGE_SIZE_DEFAULT, true);

        ~k1 = encode_i64_key(10);
        ~k2 = encode_i64_key(20);
        ~k3 = encode_i64_key(30);

        leaf.insert(&k1, 100).unwrap();
        leaf.insert(&k3, 300).unwrap();
        leaf.insert(&k2, 200).unwrap();

        assert_eq(leaf.entry_count(), 3);
        assert_eq(leaf.get_tid(&k2), Some(200));
        assert_eq(leaf.search(&k1), Some(0));  # Sorted position
    }

    it("should maintain sorted order after insert") {
        ~leaf = BTreeLeafNode.new(1, PAGE_SIZE_DEFAULT, true);

        # Insert in reverse order
        for i in (0..10).rev() {
            ~key = encode_i64_key(i);
            leaf.insert(&key, i as u32).unwrap();
        }

        # Keys should be in ascending order
        for i in 0..10 {
            ~expected = encode_i64_key(i);
            ~stored = leaf.get_key(i as usize);
            M compare_keys(stored, &expected) {
                KeyCmp.Equal => {},
                _ => panic!("Keys not sorted at position {i}"),
            }
        }
    }

    it("should delete entries") {
        ~leaf = BTreeLeafNode.new(1, PAGE_SIZE_DEFAULT, true);
        ~k1 = encode_i64_key(10);
        ~k2 = encode_i64_key(20);
        ~k3 = encode_i64_key(30);

        leaf.insert(&k1, 100).unwrap();
        leaf.insert(&k2, 200).unwrap();
        leaf.insert(&k3, 300).unwrap();

        ~removed = leaf.delete(&k2);
        assert_eq(removed, Some(200));
        assert_eq(leaf.entry_count(), 2);
        assert_eq(leaf.search(&k2), None);
    }

    it("should handle lower_bound correctly") {
        ~leaf = BTreeLeafNode.new(1, PAGE_SIZE_DEFAULT, true);
        for i in [10, 20, 30, 40, 50] {
            ~key = encode_i64_key(i);
            leaf.insert(&key, i as u32).unwrap();
        }

        # lower_bound for 25 should return index of 30
        ~search_key = encode_i64_key(25);
        ~idx = leaf.lower_bound(&search_key);
        ~found_key = leaf.get_key(idx);
        assert_eq(decode_i64_key(found_key), 30);
    }

    it("should link to next/prev leaves") {
        ~leaf = BTreeLeafNode.new(1, PAGE_SIZE_DEFAULT, false);
        assert_eq(leaf.next_leaf(), NULL_PAGE);
        assert_eq(leaf.prev_leaf(), NULL_PAGE);

        leaf.set_next_leaf(2);
        leaf.set_prev_leaf(0);
        assert_eq(leaf.next_leaf(), 2);
        assert_eq(leaf.prev_leaf(), 0);
    }
}

describe("Internal Node") {
    it("should find correct child for key") {
        ~node = BTreeInternalNode.new(1, PAGE_SIZE_DEFAULT, true);
        node.set_leftmost_child(10);  # child for keys < 20

        ~k20 = encode_i64_key(20);
        ~k40 = encode_i64_key(40);
        node.insert_entry(&k20, 20).unwrap();  # child for 20 <= key < 40
        node.insert_entry(&k40, 40).unwrap();  # child for key >= 40

        # key 5 → leftmost child (10)
        assert_eq(node.find_child(&encode_i64_key(5)), 10);
        # key 25 → child 20
        assert_eq(node.find_child(&encode_i64_key(25)), 20);
        # key 50 → child 40
        assert_eq(node.find_child(&encode_i64_key(50)), 40);
    }
}

describe("KeyRange") {
    it("should check containment for closed range") {
        ~k10 = encode_i64_key(10);
        ~k50 = encode_i64_key(50);
        ~range = KeyRange.closed(k10.clone(), k50.clone());

        assert_true(range.contains(&encode_i64_key(10)));
        assert_true(range.contains(&encode_i64_key(30)));
        assert_true(range.contains(&encode_i64_key(50)));
        assert_false(range.contains(&encode_i64_key(5)));
        assert_false(range.contains(&encode_i64_key(55)));
    }

    it("should check containment for half-open range") {
        ~k10 = encode_i64_key(10);
        ~k50 = encode_i64_key(50);
        ~range = KeyRange.half_open(k10.clone(), k50.clone());

        assert_true(range.contains(&encode_i64_key(10)));   # inclusive start
        assert_false(range.contains(&encode_i64_key(50)));  # exclusive end
        assert_true(range.contains(&encode_i64_key(49)));
    }

    it("should detect past-end correctly") {
        ~k10 = encode_i64_key(10);
        ~k50 = encode_i64_key(50);
        ~range = KeyRange.closed(k10, k50);

        assert_false(range.is_past_end(&encode_i64_key(50)));
        assert_true(range.is_past_end(&encode_i64_key(51)));
    }
}

describe("Prefix Compression") {
    it("should compute common prefix length") {
        assert_eq(common_prefix_length(b"hello", b"help"), 3);
        assert_eq(common_prefix_length(b"abc", b"abc"), 3);
        assert_eq(common_prefix_length(b"abc", b"xyz"), 0);
    }

    it("should compress and decompress keys") {
        ~keys: Vec<&[u8]> = vec![
            b"apple", b"application", b"apply", b"banana",
        ];
        ~compressed = compress_keys(&keys);
        ~decompressed = decompress_keys(&compressed);

        assert_eq(decompressed.len(), 4);
        assert_eq(&decompressed[0], b"apple");
        assert_eq(&decompressed[1], b"application");
        assert_eq(&decompressed[2], b"apply");
        assert_eq(&decompressed[3], b"banana");
    }

    it("should save space with prefix compression") {
        ~keys: Vec<&[u8]> = vec![
            b"user_000001", b"user_000002", b"user_000003", b"user_000004",
        ];
        ~ratio = compression_ratio(&keys);
        assert_true(ratio > 0.0);  # Should save some space
    }

    it("should support restart points for random access") {
        ~keys: Vec<&[u8]> = Vec.new();
        for i in 0..32 {
            keys.push(format!("key_{:04}", i).as_bytes());
        }

        ~(compressed, restarts) = compress_keys_with_restarts(&keys);
        assert_eq(restarts.len(), 2);  # restart at 0 and 16

        # Decompress key at index 20 using restart points
        ~key = decompress_key_with_restarts(&compressed, &restarts, 20).unwrap();
        assert_eq(&key, format!("key_0020").as_bytes());
    }
}

describe("B+Tree Merge Threshold") {
    it("should use 40% utilization threshold") {
        assert_eq(MERGE_UTILIZATION_THRESHOLD, 0.40);
    }
}

describe("100K Insert/Search/Delete") {
    it("should handle 100K sequential key operations on leaf level") {
        # Simulate inserting 100K keys into leaf nodes
        # This tests the leaf-level data structure, not full tree traversal
        ~leaf = BTreeLeafNode.new(1, PAGE_SIZE_DEFAULT, true);
        ~inserted: u32 = 0;

        # Insert until leaf is full
        for i in 0..100000u32 {
            ~key = encode_i64_key(i as i64);
            M leaf.insert(&key, i) {
                Ok(()) => { inserted += 1; },
                Err(_) => break,  # Leaf full
            }
        }

        assert_true(inserted > 0);

        # Search for all inserted keys
        for i in 0..inserted {
            ~key = encode_i64_key(i as i64);
            ~tid = leaf.get_tid(&key);
            assert_eq(tid, Some(i));
        }

        # Delete even keys
        for i in (0..inserted).step_by(2) {
            ~key = encode_i64_key(i as i64);
            ~removed = leaf.delete(&key);
            assert_eq(removed, Some(i));
        }

        # Verify odd keys still present
        for i in (1..inserted).step_by(2) {
            ~key = encode_i64_key(i as i64);
            assert_true(leaf.get_tid(&key).is_some());
        }
    }
}
