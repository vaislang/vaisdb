# Stage 3: Buffer Pool Integration Tests
# Tests: clock replacement, pin/unpin, dirty tracking, cache hit rate,
#         partitioned pool, read-ahead

U std/test.{assert_eq, assert_ne, assert_true, assert_false, describe, it};

U storage/constants.{PAGE_SIZE_DEFAULT, NULL_PAGE};
U storage/buffer/pool.{BufferPool};
U storage/buffer/frame.{BufferFrame, FrameState};
U storage/buffer/clock.{ClockReplacer};
U storage/buffer/dirty_tracker.{DirtyTracker};
U storage/buffer/stats.{BufferPoolStats};

describe("Clock Replacer") {
    it("should evict unpinned frames in clock order") {
        ~replacer = ClockReplacer.new(4);  # 4 frames

        # Pin frames 0,1,2,3
        replacer.pin(0);
        replacer.pin(1);
        replacer.pin(2);
        replacer.pin(3);

        # Unpin 0,1,2 (3 remains pinned)
        replacer.unpin(0);
        replacer.unpin(1);
        replacer.unpin(2);

        # Evict should return one of the unpinned frames
        ~victim = replacer.evict()!;
        assert_true(victim == 0 || victim == 1 || victim == 2);
    }

    it("should not evict pinned frames") {
        ~replacer = ClockReplacer.new(2);
        replacer.pin(0);
        replacer.pin(1);

        # Both pinned â†’ no victim
        ~result = replacer.evict();
        assert_true(result.is_none());
    }

    it("should give second chance with reference bit") {
        ~replacer = ClockReplacer.new(4);
        replacer.pin(0);
        replacer.pin(1);
        replacer.unpin(0);
        replacer.unpin(1);

        # Access frame 0 (set reference bit)
        replacer.access(0);

        # First eviction should skip 0 (has ref bit) and evict 1
        ~victim = replacer.evict()!;
        assert_eq(victim, 1);
    }
}

describe("Dirty Tracker") {
    it("should track dirty pages") {
        ~tracker = DirtyTracker.new(8);

        assert_false(tracker.is_dirty(0));

        tracker.mark_dirty(0);
        assert_true(tracker.is_dirty(0));

        tracker.mark_clean(0);
        assert_false(tracker.is_dirty(0));
    }

    it("should count dirty pages") {
        ~tracker = DirtyTracker.new(8);
        assert_eq(tracker.dirty_count(), 0);

        tracker.mark_dirty(0);
        tracker.mark_dirty(3);
        tracker.mark_dirty(7);
        assert_eq(tracker.dirty_count(), 3);

        tracker.mark_clean(3);
        assert_eq(tracker.dirty_count(), 2);
    }

    it("should list all dirty frame IDs") {
        ~tracker = DirtyTracker.new(8);
        tracker.mark_dirty(1);
        tracker.mark_dirty(4);
        tracker.mark_dirty(6);

        ~dirty = tracker.get_dirty_frames();
        assert_eq(dirty.len(), 3);
        assert_true(dirty.contains(&1));
        assert_true(dirty.contains(&4));
        assert_true(dirty.contains(&6));
    }
}

describe("Buffer Pool Stats") {
    it("should track hit rate") {
        ~stats = BufferPoolStats.new();

        # 80 hits, 20 misses â†’ 80% hit rate
        L _: 0..80 {
            stats.record_hit();
        }
        L _: 0..20 {
            stats.record_miss();
        }

        ~rate = stats.hit_rate();
        assert_true(rate > 0.79 && rate < 0.81);
    }

    it("should start with zero counts") {
        ~stats = BufferPoolStats.new();
        assert_eq(stats.total_requests(), 0);
        assert_eq(stats.total_hits(), 0);
        assert_eq(stats.total_evictions(), 0);
    }
}

describe("Buffer Pool Pin Safety") {
    it("should prevent eviction of pinned pages") {
        # In a pool with limited frames, pinned pages must never be evicted
        # This test verifies the invariant
        ~replacer = ClockReplacer.new(3);

        # Pin all frames
        replacer.pin(0);
        replacer.pin(1);
        replacer.pin(2);

        # Unpin only frame 1
        replacer.unpin(1);

        # Evict should only consider frame 1
        ~victim = replacer.evict()!;
        assert_eq(victim, 1);

        # Now all remaining are pinned â†’ no more victims
        assert_true(replacer.evict().is_none());
    }
}

describe("Buffer Pool Hit Rate > 90%") {
    it("should achieve > 90% hit rate with repeated access pattern") {
        ~stats = BufferPoolStats.new();

        # Simulate hot page access (90% of accesses go to 10% of pages)
        ~hot_pages: u32 = 10;
        ~total_pages: u32 = 100;

        # First access to all pages (100 misses)
        L _: 0..total_pages {
            stats.record_miss();
        }

        # Subsequent accesses: 900 more to hot pages (all hits)
        L _: 0..900 {
            stats.record_hit();
        }

        ~rate = stats.hit_rate();
        assert_true(rate > 0.90);
    }
}
