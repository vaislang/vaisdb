# Phase 11 — Hybrid Query Planner & RAG Engine Unit Tests
# Tests: HybridCost, EngineType, FusionMethod, QueryProfile, HybridExecStats,
#         PlanCacheKey, PlanCache, PlanCacheStats, ExplainOptions,
#         StatisticsConfig, TableColumnStats, AnalyzeResult,
#         RagConfig, RagMeta, ChunkInfo, DocumentInfo, RagSearchResult,
#         RagFusionConfig, ScoredChunk, ChunkMeta, DocumentMeta,
#         MemorySearchParams

U std/test.{describe, it, assert_eq, assert_ne, assert_true, assert_false};
U std/bytes.{ByteBuffer};
U std/vec.Vec;
U std/string.Str;
U std/option.{Option, Some, None};
U std/hashmap.HashMap;

U planner/types.{
    HybridCost, EngineType, FusionMethod, EngineBreakdown,
    VectorScanParams, GraphTraverseNodeParams, FullTextScanParams,
    FullTextSearchMode, HybridPlanNode, QueryProfile, HybridExecStats,
    DIRECTION_OUTGOING, DIRECTION_INCOMING, DIRECTION_BOTH,
    ERR_CODE_HYBRID_PLAN_FAILED, ERR_CODE_HYBRID_COST_FAILED,
    ERR_CODE_HYBRID_ENGINE_MISMATCH, ERR_CODE_HYBRID_UNSUPPORTED_COMBO,
    ERR_CODE_HYBRID_SCORE_FUSION_INVALID,
};
U planner/cache.{
    PlanCacheKey, PlanCacheEntry, PlanCacheStats, PlanCache,
    DEFAULT_MAX_ENTRIES, normalize_query,
};
U planner/explain.{
    ExplainFormat, ExplainOptions,
    format_hybrid_cost, explain_plan,
};
U planner/statistics.{
    TableColumnStats, StatisticsConfig, AnalyzeResult,
    DEFAULT_SAMPLE_SIZE, DEFAULT_HISTOGRAM_BUCKETS, MIN_ROWS_FOR_SAMPLING,
    pseudo_random, compare_values, build_histogram, reservoir_sample,
};
U rag/types.{
    RagConfig, RagMeta, ChunkInfo, DocumentInfo,
    RagSearchResult, RagFusionConfig, ScoredChunk,
    ChunkMeta, DocumentMeta,
    RAG_FORMAT_VERSION, FILE_ID_RAG, FILE_NAME_RAG,
    CHUNK_STRATEGY_FIXED_SIZE, CHUNK_STRATEGY_SENTENCE, CHUNK_STRATEGY_PARAGRAPH,
    DEFAULT_CHUNK_SIZE, DEFAULT_MIN_CHUNK_SIZE, DEFAULT_MAX_CHUNK_SIZE,
    DEFAULT_OVERLAP_TOKENS,
    MEMORY_TYPE_EPISODIC, MEMORY_TYPE_SEMANTIC, MEMORY_TYPE_PROCEDURAL, MEMORY_TYPE_WORKING,
    DEFAULT_TTL_EPISODIC, DEFAULT_TTL_SEMANTIC, DEFAULT_TTL_PROCEDURAL, DEFAULT_TTL_WORKING,
    DEFAULT_VECTOR_WEIGHT, DEFAULT_FULLTEXT_WEIGHT, DEFAULT_GRAPH_WEIGHT, DEFAULT_MEMORY_WEIGHT,
    PAGE_TYPE_RAG_CHUNK, PAGE_TYPE_RAG_DOC_META, PAGE_TYPE_RAG_EMBED_META, PAGE_TYPE_RAG_MEMORY,
    ENGINE_TAG_RAG,
    EDGE_TYPE_NEXT_CHUNK, EDGE_TYPE_SAME_SECTION, EDGE_TYPE_SAME_DOCUMENT,
    EDGE_TYPE_CONTAINS, EDGE_TYPE_REFERENCES, EDGE_TYPE_SUPERSEDES, EDGE_TYPE_RELATED_TO,
    EDGE_TYPE_TEMPORAL_NEXT, EDGE_TYPE_SESSION_CONTEXT,
    LABEL_DOCUMENT, LABEL_SECTION, LABEL_PARAGRAPH, LABEL_CHUNK, LABEL_MEMORY, LABEL_SESSION,
    DISTANCE_COSINE, DISTANCE_L2, DISTANCE_DOT_PRODUCT,
    MAX_CHUNK_EDGES, MAX_HIERARCHY_DEPTH,
};
U rag/memory/search.{MemorySearchParams};
U sql/types.{SqlValue};
U storage/hash.{fnv1a_hash};

# ==========================================================================
# Planner — EngineType
# ==========================================================================

describe("EngineType", |t| {
    it("name returns correct string for each variant", || {
        assert_eq(EngineType.Sql.name(), "sql");
        assert_eq(EngineType.Vector.name(), "vector");
        assert_eq(EngineType.Graph.name(), "graph");
        assert_eq(EngineType.FullText.name(), "fulltext");
        assert_eq(EngineType.Hybrid.name(), "hybrid");
    });
});

# ==========================================================================
# Planner — HybridCost
# ==========================================================================

describe("HybridCost", |t| {
    it("new creates zero-cost instance", || {
        ~cost = HybridCost.new();
        assert_eq(cost.total_io_cost, 0.0);
        assert_eq(cost.total_cpu_cost, 0.0);
        assert_eq(cost.total_memory_bytes, 0u64);
        assert_eq(cost.row_estimate, 0u64);
        assert_eq(cost.sql_io_cost, 0.0);
        assert_eq(cost.sql_cpu_cost, 0.0);
        assert_eq(cost.vector_io_cost, 0.0);
        assert_eq(cost.vector_cpu_cost, 0.0);
        assert_eq(cost.graph_io_cost, 0.0);
        assert_eq(cost.graph_cpu_cost, 0.0);
        assert_eq(cost.fulltext_io_cost, 0.0);
        assert_eq(cost.fulltext_cpu_cost, 0.0);
        assert_eq(cost.vector_dimension, 0u32);
        assert_eq(cost.vector_ef_search, 0u32);
        assert_eq(cost.graph_avg_degree, 0.0);
        assert_eq(cost.graph_max_depth, 0u32);
        assert_eq(cost.fulltext_posting_length, 0u64);
    });

    it("total returns weighted sum of IO and CPU", || {
        ~cost = HybridCost.new();
        cost.total_io_cost = 10.0;
        cost.total_cpu_cost = 50.0;
        # total = IO * 1.0 + CPU * 0.1 = 10.0 + 5.0 = 15.0
        ~total = cost.total();
        assert_true(total > 14.99 && total < 15.01);
    });

    it("total returns zero for zero-cost", || {
        ~cost = HybridCost.new();
        assert_eq(cost.total(), 0.0);
    });

    it("add combines two costs correctly", || {
        ~a = HybridCost.new();
        a.total_io_cost = 10.0;
        a.total_cpu_cost = 20.0;
        a.total_memory_bytes = 1024;
        a.row_estimate = 100;
        a.sql_io_cost = 5.0;
        a.sql_cpu_cost = 10.0;
        a.vector_io_cost = 5.0;
        a.vector_cpu_cost = 10.0;
        a.vector_dimension = 128;
        a.vector_ef_search = 64;

        ~b = HybridCost.new();
        b.total_io_cost = 3.0;
        b.total_cpu_cost = 4.0;
        b.total_memory_bytes = 512;
        b.row_estimate = 50;
        b.graph_io_cost = 3.0;
        b.graph_cpu_cost = 4.0;
        b.graph_avg_degree = 5.0;
        b.graph_max_depth = 3;

        ~sum = a.add(&b);
        assert_eq(sum.total_io_cost, 13.0);
        assert_eq(sum.total_cpu_cost, 24.0);
        assert_eq(sum.total_memory_bytes, 1536u64);
        # row_estimate keeps first operand's value
        assert_eq(sum.row_estimate, 100u64);
        assert_eq(sum.sql_io_cost, 5.0);
        assert_eq(sum.sql_cpu_cost, 10.0);
        assert_eq(sum.vector_io_cost, 5.0);
        assert_eq(sum.vector_cpu_cost, 10.0);
        assert_eq(sum.graph_io_cost, 3.0);
        assert_eq(sum.graph_cpu_cost, 4.0);
        # Keeps first non-zero for engine-specific metrics
        assert_eq(sum.vector_dimension, 128u32);
        assert_eq(sum.vector_ef_search, 64u32);
        assert_true(sum.graph_avg_degree > 4.99 && sum.graph_avg_degree < 5.01);
        assert_eq(sum.graph_max_depth, 3u32);
    });

    it("add preserves second operand engine metrics when first is zero", || {
        ~a = HybridCost.new();
        ~b = HybridCost.new();
        b.vector_dimension = 768;
        b.vector_ef_search = 200;
        b.graph_avg_degree = 10.0;
        b.graph_max_depth = 5;
        b.fulltext_posting_length = 42;

        ~sum = a.add(&b);
        assert_eq(sum.vector_dimension, 768u32);
        assert_eq(sum.vector_ef_search, 200u32);
        assert_true(sum.graph_avg_degree > 9.99 && sum.graph_avg_degree < 10.01);
        assert_eq(sum.graph_max_depth, 5u32);
        assert_eq(sum.fulltext_posting_length, 42u64);
    });

    it("engine_breakdown returns empty for zero cost", || {
        ~cost = HybridCost.new();
        ~breakdown = cost.engine_breakdown();
        assert_eq(breakdown.len(), 0u64);
    });

    it("engine_breakdown returns correct percentages for multi-engine", || {
        ~cost = HybridCost.new();
        # SQL: IO=10, CPU=0 => weighted=10.0
        cost.total_io_cost = 20.0;
        cost.total_cpu_cost = 100.0;
        cost.sql_io_cost = 10.0;
        cost.sql_cpu_cost = 0.0;
        cost.vector_io_cost = 10.0;
        cost.vector_cpu_cost = 100.0;
        # total = 20*1.0 + 100*0.1 = 30.0
        # SQL weighted = 10*1.0 + 0*0.1 = 10.0 => 33.3%
        # Vector weighted = 10*1.0 + 100*0.1 = 20.0 => 66.7%

        ~breakdown = cost.engine_breakdown();
        assert_eq(breakdown.len(), 2u64);
        # Sorted descending by percentage, Vector should be first
    });

    it("engine_breakdown includes only non-zero engines", || {
        ~cost = HybridCost.new();
        cost.total_io_cost = 5.0;
        cost.total_cpu_cost = 0.0;
        cost.fulltext_io_cost = 5.0;
        cost.fulltext_cpu_cost = 0.0;

        ~breakdown = cost.engine_breakdown();
        assert_eq(breakdown.len(), 1u64);
    });
});

# ==========================================================================
# Planner — FusionMethod
# ==========================================================================

describe("FusionMethod", |t| {
    it("default_weighted creates equal 50/50 weights", || {
        ~method = FusionMethod.default_weighted();
        M method {
            FusionMethod.WeightedSum { weight_a, weight_b } => {
                assert_true(weight_a > 0.49 && weight_a < 0.51);
                assert_true(weight_b > 0.49 && weight_b < 0.51);
            },
            _ => assert_true(false),
        }
    });

    it("default_rrf uses k=60", || {
        ~method = FusionMethod.default_rrf();
        M method {
            FusionMethod.ReciprocalRankFusion { k } => {
                assert_eq(k, 60u32);
            },
            _ => assert_true(false),
        }
    });
});

# ==========================================================================
# Planner — GraphTraverseNodeParams defaults
# ==========================================================================

describe("GraphTraverseNodeParams", |t| {
    it("direction constants are distinct", || {
        assert_eq(DIRECTION_OUTGOING, 0u8);
        assert_eq(DIRECTION_INCOMING, 1u8);
        assert_eq(DIRECTION_BOTH, 2u8);
        assert_ne(DIRECTION_OUTGOING, DIRECTION_INCOMING);
        assert_ne(DIRECTION_INCOMING, DIRECTION_BOTH);
    });
});

# ==========================================================================
# Planner — FullTextSearchMode
# ==========================================================================

describe("FullTextSearchMode", |t| {
    it("variants are distinct", || {
        # Verify we can construct each variant
        ~simple = FullTextSearchMode.Simple;
        ~phrase = FullTextSearchMode.Phrase { slop: 2 };
        ~boolean = FullTextSearchMode.Boolean;
        # Verify phrase slop
        M phrase {
            FullTextSearchMode.Phrase { slop } => assert_eq(slop, 2u32),
            _ => assert_true(false),
        }
    });
});

# ==========================================================================
# Planner — QueryProfile
# ==========================================================================

describe("QueryProfile", |t| {
    it("new creates empty profile", || {
        ~profile = QueryProfile.new();
        assert_false(profile.uses_sql);
        assert_false(profile.uses_vector);
        assert_false(profile.uses_graph);
        assert_false(profile.uses_fulltext);
        assert_eq(profile.vector_calls.len(), 0u64);
        assert_eq(profile.graph_calls.len(), 0u64);
        assert_eq(profile.fulltext_calls.len(), 0u64);
        assert_eq(profile.sql_tables.len(), 0u64);
    });

    it("engine_count returns zero for empty profile", || {
        ~profile = QueryProfile.new();
        assert_eq(profile.engine_count(), 0u32);
    });

    it("engine_count counts active engines", || {
        ~profile = QueryProfile.new();
        profile.uses_sql = true;
        profile.uses_vector = true;
        assert_eq(profile.engine_count(), 2u32);
    });

    it("engine_count counts all four engines", || {
        ~profile = QueryProfile.new();
        profile.uses_sql = true;
        profile.uses_vector = true;
        profile.uses_graph = true;
        profile.uses_fulltext = true;
        assert_eq(profile.engine_count(), 4u32);
    });

    it("is_single_engine true for SQL only", || {
        ~profile = QueryProfile.new();
        profile.uses_sql = true;
        assert_true(profile.is_single_engine());
    });

    it("is_single_engine false for multi-engine", || {
        ~profile = QueryProfile.new();
        profile.uses_sql = true;
        profile.uses_vector = true;
        assert_false(profile.is_single_engine());
    });

    it("is_pure_sql for SQL-only query", || {
        ~profile = QueryProfile.new();
        profile.uses_sql = true;
        assert_true(profile.is_pure_sql());
    });

    it("is_pure_sql false when vector used", || {
        ~profile = QueryProfile.new();
        profile.uses_sql = true;
        profile.uses_vector = true;
        assert_false(profile.is_pure_sql());
    });

    it("is_pure_sql false when graph used", || {
        ~profile = QueryProfile.new();
        profile.uses_sql = true;
        profile.uses_graph = true;
        assert_false(profile.is_pure_sql());
    });

    it("needs_score_fusion requires vector + fulltext", || {
        ~profile = QueryProfile.new();
        profile.uses_vector = true;
        profile.uses_fulltext = true;
        assert_true(profile.needs_score_fusion());
    });

    it("needs_score_fusion false for vector only", || {
        ~profile = QueryProfile.new();
        profile.uses_vector = true;
        assert_false(profile.needs_score_fusion());
    });

    it("needs_score_fusion false for graph + sql (non-scoring engines)", || {
        ~profile = QueryProfile.new();
        profile.uses_sql = true;
        profile.uses_graph = true;
        assert_false(profile.needs_score_fusion());
    });
});

# ==========================================================================
# Planner — HybridExecStats
# ==========================================================================

describe("HybridExecStats", |t| {
    it("new creates zero stats", || {
        ~stats = HybridExecStats.new(EngineType.Sql);
        assert_eq(stats.rows_produced, 0u64);
        assert_eq(stats.rows_scanned, 0u64);
        assert_eq(stats.pages_read, 0u64);
        assert_eq(stats.elapsed_us, 0u64);
        assert_eq(stats.memory_bytes, 0u64);
        assert_eq(stats.children.len(), 0u64);
    });

    it("total_elapsed_us returns own time for leaf", || {
        ~stats = HybridExecStats.new(EngineType.Vector);
        stats.elapsed_us = 1000;
        assert_eq(stats.total_elapsed_us(), 1000u64);
    });

    it("total_elapsed_us sums children", || {
        ~parent = HybridExecStats.new(EngineType.Hybrid);
        parent.elapsed_us = 100;

        ~child1 = HybridExecStats.new(EngineType.Vector);
        child1.elapsed_us = 500;

        ~child2 = HybridExecStats.new(EngineType.FullText);
        child2.elapsed_us = 300;

        parent.children.push(child1);
        parent.children.push(child2);

        # 100 + 500 + 300 = 900
        assert_eq(parent.total_elapsed_us(), 900u64);
    });

    it("total_elapsed_us sums nested children", || {
        ~root = HybridExecStats.new(EngineType.Hybrid);
        root.elapsed_us = 10;

        ~mid = HybridExecStats.new(EngineType.Sql);
        mid.elapsed_us = 20;

        ~leaf = HybridExecStats.new(EngineType.Graph);
        leaf.elapsed_us = 30;

        mid.children.push(leaf);
        root.children.push(mid);

        # 10 + (20 + 30) = 60
        assert_eq(root.total_elapsed_us(), 60u64);
    });
});

# ==========================================================================
# Planner — Error Codes
# ==========================================================================

describe("Planner error codes", |t| {
    it("error codes have correct format", || {
        assert_eq(ERR_CODE_HYBRID_PLAN_FAILED, "VAIS-0008001");
        assert_eq(ERR_CODE_HYBRID_COST_FAILED, "VAIS-0008002");
        assert_eq(ERR_CODE_HYBRID_ENGINE_MISMATCH, "VAIS-0008003");
        assert_eq(ERR_CODE_HYBRID_UNSUPPORTED_COMBO, "VAIS-0008004");
        assert_eq(ERR_CODE_HYBRID_SCORE_FUSION_INVALID, "VAIS-0008005");
    });
});

# ==========================================================================
# Planner — PlanCacheKey
# ==========================================================================

describe("PlanCacheKey", |t| {
    it("new creates key with hash from SQL string", || {
        ~key = PlanCacheKey.new("SELECT * FROM users WHERE id = $1".to_string());
        assert_ne(key.hash, 0u64);
        assert_eq(key.normalized_sql, "SELECT * FROM users WHERE id = $1");
    });

    it("same SQL produces same hash", || {
        ~key1 = PlanCacheKey.new("SELECT * FROM t".to_string());
        ~key2 = PlanCacheKey.new("SELECT * FROM t".to_string());
        assert_true(key1.eq(&key2));
    });

    it("different SQL produces different hash", || {
        ~key1 = PlanCacheKey.new("SELECT * FROM t".to_string());
        ~key2 = PlanCacheKey.new("SELECT * FROM u".to_string());
        assert_false(key1.eq(&key2));
    });

    it("from_hash creates lookup key", || {
        ~key = PlanCacheKey.from_hash(12345);
        assert_eq(key.hash, 12345u64);
        assert_eq(key.normalized_sql, "");
    });
});

# ==========================================================================
# Planner — PlanCacheStats
# ==========================================================================

describe("PlanCacheStats", |t| {
    it("new creates zero stats", || {
        ~stats = PlanCacheStats.new();
        assert_eq(stats.hits, 0u64);
        assert_eq(stats.misses, 0u64);
        assert_eq(stats.evictions, 0u64);
        assert_eq(stats.entries, 0u64);
    });

    it("hit_rate returns 0 when no queries", || {
        ~stats = PlanCacheStats.new();
        assert_eq(stats.hit_rate(), 0.0);
    });

    it("hit_rate computes correctly", || {
        ~stats = PlanCacheStats.new();
        stats.hits = 75;
        stats.misses = 25;
        # 75 / 100 = 0.75
        ~rate = stats.hit_rate();
        assert_true(rate > 0.749 && rate < 0.751);
    });

    it("hit_rate is 1.0 for all hits", || {
        ~stats = PlanCacheStats.new();
        stats.hits = 100;
        stats.misses = 0;
        ~rate = stats.hit_rate();
        assert_true(rate > 0.999 && rate < 1.001);
    });
});

# ==========================================================================
# Planner — PlanCache
# ==========================================================================

describe("PlanCache", |t| {
    it("new creates empty cache with default capacity", || {
        ~cache = PlanCache.new();
        assert_eq(cache.len(), 0u64);
        assert_true(cache.is_empty());
        assert_eq(cache.capacity(), DEFAULT_MAX_ENTRIES);
    });

    it("with_capacity sets custom max entries", || {
        ~cache = PlanCache.with_capacity(64);
        assert_eq(cache.capacity(), 64u64);
    });

    it("invalidate_all clears the cache", || {
        ~cache = PlanCache.new();
        # Insert something (need a HybridPlanNode, but we can test invalidate_all
        # on empty cache at minimum)
        cache.invalidate_all();
        assert_true(cache.is_empty());
    });
});

# ==========================================================================
# Planner — Query Normalization
# ==========================================================================

describe("normalize_query", |t| {
    it("replaces integer literals with parameters", || {
        ~result = normalize_query(&"SELECT * FROM t WHERE id = 42");
        # Numbers get replaced with $N
        assert_true(result.contains("$"));
        assert_false(result.contains("42"));
    });

    it("replaces string literals with parameters", || {
        ~result = normalize_query(&"SELECT * FROM t WHERE name = 'alice'");
        assert_true(result.contains("$"));
        assert_false(result.contains("alice"));
    });

    it("preserves keywords and identifiers", || {
        ~result = normalize_query(&"SELECT * FROM users WHERE active = true");
        assert_true(result.contains("SELECT"));
        assert_true(result.contains("FROM"));
        assert_true(result.contains("users"));
        assert_true(result.contains("WHERE"));
    });

    it("produces same output for same query structure", || {
        ~r1 = normalize_query(&"SELECT * FROM t WHERE id = 1");
        ~r2 = normalize_query(&"SELECT * FROM t WHERE id = 2");
        # Both replace the number with $1, so should match
        assert_eq(r1, r2);
    });
});

# ==========================================================================
# Planner — ExplainOptions
# ==========================================================================

describe("ExplainOptions", |t| {
    it("default creates non-analyze non-verbose text format", || {
        ~opts = ExplainOptions.default();
        assert_false(opts.analyze);
        assert_false(opts.verbose);
        M opts.format {
            ExplainFormat.Text => assert_true(true),
            ExplainFormat.Json => assert_true(false),
        }
    });
});

# ==========================================================================
# Planner — Statistics: TableColumnStats
# ==========================================================================

describe("TableColumnStats", |t| {
    it("new creates empty stats", || {
        ~stats = TableColumnStats.new("users".to_string(), "age".to_string());
        assert_eq(stats.table_name, "users");
        assert_eq(stats.column_name, "age");
        assert_eq(stats.n_distinct, 0u64);
        assert_eq(stats.null_fraction, 0.0);
        assert_eq(stats.histogram.len(), 0u64);
        assert_true(stats.min_value.is_none());
        assert_true(stats.max_value.is_none());
        assert_eq(stats.avg_width, 0u32);
    });

    it("estimate_equality_selectivity returns 0.1 when n_distinct=0", || {
        ~stats = TableColumnStats.new("t".to_string(), "c".to_string());
        ~sel = stats.estimate_equality_selectivity();
        assert_true(sel > 0.099 && sel < 0.101);
    });

    it("estimate_equality_selectivity returns 1/n_distinct", || {
        ~stats = TableColumnStats.new("t".to_string(), "c".to_string());
        stats.n_distinct = 100;
        # 1/100 = 0.01
        ~sel = stats.estimate_equality_selectivity();
        assert_true(sel > 0.009 && sel < 0.011);
    });

    it("estimate_range_selectivity returns 0.3 when no histogram", || {
        ~stats = TableColumnStats.new("t".to_string(), "c".to_string());
        ~val = SqlValue.IntVal { v: 50 };
        ~sel = stats.estimate_range_selectivity(&val);
        assert_true(sel > 0.29 && sel < 0.31);
    });
});

# ==========================================================================
# Planner — Statistics: StatisticsConfig
# ==========================================================================

describe("StatisticsConfig", |t| {
    it("default uses standard values", || {
        ~config = StatisticsConfig.default();
        assert_eq(config.sample_size, DEFAULT_SAMPLE_SIZE);
        assert_eq(config.histogram_buckets, DEFAULT_HISTOGRAM_BUCKETS);
        assert_false(config.force_full_scan);
    });

    it("builder pattern customizes values", || {
        ~config = StatisticsConfig.default();
        config = config.with_sample_size(5000);
        assert_eq(config.sample_size, 5000u64);

        config = config.with_histogram_buckets(50);
        assert_eq(config.histogram_buckets, 50u64);

        config = config.with_force_full_scan();
        assert_true(config.force_full_scan);
    });

    it("constants have expected values", || {
        assert_eq(DEFAULT_SAMPLE_SIZE, 1000u64);
        assert_eq(DEFAULT_HISTOGRAM_BUCKETS, 100u64);
        assert_eq(MIN_ROWS_FOR_SAMPLING, 5000u64);
    });
});

# ==========================================================================
# Planner — Statistics: pseudo_random
# ==========================================================================

describe("pseudo_random", |t| {
    it("produces non-zero output", || {
        ~val = pseudo_random(42, 0);
        assert_ne(val, 0u64);
    });

    it("produces different output for different indices", || {
        ~v1 = pseudo_random(42, 0);
        ~v2 = pseudo_random(42, 1);
        ~v3 = pseudo_random(42, 2);
        assert_ne(v1, v2);
        assert_ne(v2, v3);
    });

    it("produces different output for different seeds", || {
        ~v1 = pseudo_random(1, 0);
        ~v2 = pseudo_random(2, 0);
        assert_ne(v1, v2);
    });

    it("is deterministic", || {
        ~v1 = pseudo_random(42, 100);
        ~v2 = pseudo_random(42, 100);
        assert_eq(v1, v2);
    });
});

# ==========================================================================
# Planner — Statistics: compare_values
# ==========================================================================

describe("compare_values", |t| {
    it("compares equal integers", || {
        ~a = SqlValue.IntVal { v: 42 };
        ~b = SqlValue.IntVal { v: 42 };
        ~result = compare_values(&a, &b);
        assert_true(result.is_ok());
        assert_eq(result.unwrap(), 0);
    });

    it("compares less-than integers", || {
        ~a = SqlValue.IntVal { v: 10 };
        ~b = SqlValue.IntVal { v: 20 };
        ~result = compare_values(&a, &b);
        assert_eq(result.unwrap(), -1);
    });

    it("compares greater-than integers", || {
        ~a = SqlValue.IntVal { v: 20 };
        ~b = SqlValue.IntVal { v: 10 };
        ~result = compare_values(&a, &b);
        assert_eq(result.unwrap(), 1);
    });

    it("compares floats", || {
        ~a = SqlValue.FloatVal { v: 1.5 };
        ~b = SqlValue.FloatVal { v: 2.5 };
        ~result = compare_values(&a, &b);
        assert_eq(result.unwrap(), -1);
    });

    it("compares strings", || {
        ~a = SqlValue.StringVal { v: "apple".to_string() };
        ~b = SqlValue.StringVal { v: "banana".to_string() };
        ~result = compare_values(&a, &b);
        assert_eq(result.unwrap(), -1);
    });

    it("NULL sorts first", || {
        ~a = SqlValue.Null;
        ~b = SqlValue.IntVal { v: 42 };
        ~result = compare_values(&a, &b);
        assert_eq(result.unwrap(), -1);
    });

    it("value sorts after NULL", || {
        ~a = SqlValue.IntVal { v: 42 };
        ~b = SqlValue.Null;
        ~result = compare_values(&a, &b);
        assert_eq(result.unwrap(), 1);
    });

    it("NULL equals NULL", || {
        ~a = SqlValue.Null;
        ~b = SqlValue.Null;
        ~result = compare_values(&a, &b);
        assert_eq(result.unwrap(), 0);
    });

    it("errors on incompatible types", || {
        ~a = SqlValue.IntVal { v: 42 };
        ~b = SqlValue.StringVal { v: "hello".to_string() };
        ~result = compare_values(&a, &b);
        assert_true(result.is_err());
    });
});

# ==========================================================================
# Planner — Statistics: build_histogram
# ==========================================================================

describe("build_histogram", |t| {
    it("returns empty for empty input", || {
        ~sample: Vec<SqlValue> = Vec.new();
        ~hist = build_histogram(&sample, 10);
        assert_eq(hist.len(), 0u64);
    });

    it("returns empty for zero buckets", || {
        ~sample = Vec.new();
        sample.push(SqlValue.IntVal { v: 1 });
        sample.push(SqlValue.IntVal { v: 2 });
        ~hist = build_histogram(&sample, 0);
        assert_eq(hist.len(), 0u64);
    });
});

# ==========================================================================
# Planner — Statistics: reservoir_sample
# ==========================================================================

describe("reservoir_sample", |t| {
    it("returns empty for empty input", || {
        ~rows: Vec<SqlValue> = Vec.new();
        ~sample = reservoir_sample(&rows, 10, 42);
        assert_eq(sample.len(), 0u64);
    });

    it("returns empty for zero sample size", || {
        ~rows = Vec.new();
        rows.push(SqlValue.IntVal { v: 1 });
        ~sample = reservoir_sample(&rows, 0, 42);
        assert_eq(sample.len(), 0u64);
    });

    it("returns all rows when sample_size >= input size", || {
        ~rows = Vec.new();
        rows.push(SqlValue.IntVal { v: 1 });
        rows.push(SqlValue.IntVal { v: 2 });
        rows.push(SqlValue.IntVal { v: 3 });
        ~sample = reservoir_sample(&rows, 10, 42);
        assert_eq(sample.len(), 3u64);
    });
});

# ==========================================================================
# RAG — Constants
# ==========================================================================

describe("RAG constants", |t| {
    it("format version is 1", || {
        assert_eq(RAG_FORMAT_VERSION, 1u8);
    });

    it("file ID for RAG is 5", || {
        assert_eq(FILE_ID_RAG, 5u8);
    });

    it("file name is rag.vdb", || {
        assert_eq(FILE_NAME_RAG, "rag.vdb");
    });

    it("chunk strategies are distinct", || {
        assert_eq(CHUNK_STRATEGY_FIXED_SIZE, 0u8);
        assert_eq(CHUNK_STRATEGY_SENTENCE, 1u8);
        assert_eq(CHUNK_STRATEGY_PARAGRAPH, 2u8);
    });

    it("default chunk parameters have correct values", || {
        assert_eq(DEFAULT_CHUNK_SIZE, 512u32);
        assert_eq(DEFAULT_MIN_CHUNK_SIZE, 64u32);
        assert_eq(DEFAULT_MAX_CHUNK_SIZE, 1024u32);
        assert_eq(DEFAULT_OVERLAP_TOKENS, 50u32);
    });

    it("memory types are distinct", || {
        assert_eq(MEMORY_TYPE_EPISODIC, 0u8);
        assert_eq(MEMORY_TYPE_SEMANTIC, 1u8);
        assert_eq(MEMORY_TYPE_PROCEDURAL, 2u8);
        assert_eq(MEMORY_TYPE_WORKING, 3u8);
    });

    it("default TTLs have correct values", || {
        assert_eq(DEFAULT_TTL_EPISODIC, 7776000u64);     # 90 days
        assert_eq(DEFAULT_TTL_SEMANTIC, 0u64);            # no expiry
        assert_eq(DEFAULT_TTL_PROCEDURAL, 0u64);          # no expiry
        assert_eq(DEFAULT_TTL_WORKING, 86400u64);         # 1 day
    });

    it("score fusion weights sum to 1.0", || {
        ~total = DEFAULT_VECTOR_WEIGHT + DEFAULT_FULLTEXT_WEIGHT + DEFAULT_GRAPH_WEIGHT;
        assert_true(total > 0.99 && total < 1.01);
    });

    it("page types are in 0x60 range", || {
        assert_eq(PAGE_TYPE_RAG_CHUNK, 0x60u8);
        assert_eq(PAGE_TYPE_RAG_DOC_META, 0x61u8);
        assert_eq(PAGE_TYPE_RAG_EMBED_META, 0x62u8);
        assert_eq(PAGE_TYPE_RAG_MEMORY, 0x63u8);
    });

    it("engine tag for RAG is 0x05", || {
        assert_eq(ENGINE_TAG_RAG, 0x05u8);
    });

    it("distance metric constants", || {
        assert_eq(DISTANCE_COSINE, 0u8);
        assert_eq(DISTANCE_L2, 1u8);
        assert_eq(DISTANCE_DOT_PRODUCT, 2u8);
    });

    it("graph limits", || {
        assert_eq(MAX_CHUNK_EDGES, 64u32);
        assert_eq(MAX_HIERARCHY_DEPTH, 8u32);
    });

    it("edge type constants are non-empty", || {
        assert_eq(EDGE_TYPE_NEXT_CHUNK, "NEXT_CHUNK");
        assert_eq(EDGE_TYPE_SAME_SECTION, "SAME_SECTION");
        assert_eq(EDGE_TYPE_SAME_DOCUMENT, "SAME_DOCUMENT");
        assert_eq(EDGE_TYPE_CONTAINS, "CONTAINS");
        assert_eq(EDGE_TYPE_REFERENCES, "REFERENCES");
        assert_eq(EDGE_TYPE_SUPERSEDES, "SUPERSEDES");
        assert_eq(EDGE_TYPE_RELATED_TO, "RELATED_TO");
        assert_eq(EDGE_TYPE_TEMPORAL_NEXT, "TEMPORAL_NEXT");
        assert_eq(EDGE_TYPE_SESSION_CONTEXT, "SESSION_CONTEXT");
    });

    it("label constants are non-empty", || {
        assert_eq(LABEL_DOCUMENT, "DOCUMENT");
        assert_eq(LABEL_SECTION, "SECTION");
        assert_eq(LABEL_PARAGRAPH, "PARAGRAPH");
        assert_eq(LABEL_CHUNK, "CHUNK");
        assert_eq(LABEL_MEMORY, "MEMORY");
        assert_eq(LABEL_SESSION, "SESSION");
    });
});

# ==========================================================================
# RAG — RagConfig
# ==========================================================================

describe("RagConfig", |t| {
    it("default creates config with standard values", || {
        ~config = RagConfig.default(4096);
        assert_eq(config.chunk_strategy, CHUNK_STRATEGY_SENTENCE);
        assert_eq(config.target_chunk_size, DEFAULT_CHUNK_SIZE);
        assert_eq(config.min_chunk_size, DEFAULT_MIN_CHUNK_SIZE);
        assert_eq(config.max_chunk_size, DEFAULT_MAX_CHUNK_SIZE);
        assert_eq(config.overlap_tokens, DEFAULT_OVERLAP_TOKENS);
        assert_true(config.vector_weight > 0.39 && config.vector_weight < 0.41);
        assert_true(config.fulltext_weight > 0.29 && config.fulltext_weight < 0.31);
        assert_true(config.graph_weight > 0.29 && config.graph_weight < 0.31);
        assert_false(config.enable_auto_embed);
        assert_true(config.enable_auto_chunk);
        assert_true(config.enable_hierarchy);
        assert_eq(config.page_size, 4096u32);
    });

    it("serialization round-trip preserves all fields", || {
        ~config = RagConfig.default(8192);
        config.chunk_strategy = CHUNK_STRATEGY_PARAGRAPH;
        config.target_chunk_size = 256;
        config.min_chunk_size = 32;
        config.max_chunk_size = 2048;
        config.overlap_tokens = 100;
        config.vector_weight = 0.6;
        config.fulltext_weight = 0.2;
        config.graph_weight = 0.2;
        config.enable_auto_embed = true;
        config.enable_auto_chunk = false;
        config.enable_hierarchy = false;

        ~buf = ByteBuffer.new(64);
        config.serialize(&buf);
        buf.reset_read();
        ~restored = RagConfig.deserialize(&buf, 8192).unwrap();

        assert_eq(restored.chunk_strategy, CHUNK_STRATEGY_PARAGRAPH);
        assert_eq(restored.target_chunk_size, 256u32);
        assert_eq(restored.min_chunk_size, 32u32);
        assert_eq(restored.max_chunk_size, 2048u32);
        assert_eq(restored.overlap_tokens, 100u32);
        assert_true(restored.vector_weight > 0.59 && restored.vector_weight < 0.61);
        assert_true(restored.fulltext_weight > 0.19 && restored.fulltext_weight < 0.21);
        assert_true(restored.graph_weight > 0.19 && restored.graph_weight < 0.21);
        assert_true(restored.enable_auto_embed);
        assert_false(restored.enable_auto_chunk);
        assert_false(restored.enable_hierarchy);
        assert_eq(restored.page_size, 8192u32);
    });

    it("serialization preserves boolean flags correctly", || {
        # Test each flag independently
        ~config1 = RagConfig.default(4096);
        config1.enable_auto_embed = true;
        config1.enable_auto_chunk = false;
        config1.enable_hierarchy = false;

        ~buf1 = ByteBuffer.new(64);
        config1.serialize(&buf1);
        buf1.reset_read();
        ~r1 = RagConfig.deserialize(&buf1, 4096).unwrap();
        assert_true(r1.enable_auto_embed);
        assert_false(r1.enable_auto_chunk);
        assert_false(r1.enable_hierarchy);

        # Test with only hierarchy
        ~config2 = RagConfig.default(4096);
        config2.enable_auto_embed = false;
        config2.enable_auto_chunk = false;
        config2.enable_hierarchy = true;

        ~buf2 = ByteBuffer.new(64);
        config2.serialize(&buf2);
        buf2.reset_read();
        ~r2 = RagConfig.deserialize(&buf2, 4096).unwrap();
        assert_false(r2.enable_auto_embed);
        assert_false(r2.enable_auto_chunk);
        assert_true(r2.enable_hierarchy);
    });
});

# ==========================================================================
# RAG — RagMeta
# ==========================================================================

describe("RagMeta", |t| {
    it("new creates initial metadata", || {
        ~meta = RagMeta.new(4096);
        assert_eq(meta.format_version, RAG_FORMAT_VERSION);
        assert_eq(meta.doc_count, 0u64);
        assert_eq(meta.chunk_count, 0u64);
        assert_eq(meta.memory_count, 0u64);
        assert_eq(meta.session_count, 0u64);
        assert_eq(meta.next_doc_id, 1u64);
        assert_eq(meta.next_chunk_id, 1u64);
        assert_eq(meta.next_memory_id, 1u64);
        assert_eq(meta.next_session_id, 1u64);
        assert_eq(meta.active_model_id, 0u32);
    });

    it("alloc_doc_id increments and returns unique IDs", || {
        ~meta = RagMeta.new(4096);
        assert_eq(meta.alloc_doc_id(), 1u64);
        assert_eq(meta.alloc_doc_id(), 2u64);
        assert_eq(meta.alloc_doc_id(), 3u64);
        assert_eq(meta.next_doc_id, 4u64);
    });

    it("alloc_chunk_id increments and returns unique IDs", || {
        ~meta = RagMeta.new(4096);
        assert_eq(meta.alloc_chunk_id(), 1u64);
        assert_eq(meta.alloc_chunk_id(), 2u64);
        assert_eq(meta.next_chunk_id, 3u64);
    });

    it("alloc_memory_id increments and returns unique IDs", || {
        ~meta = RagMeta.new(4096);
        assert_eq(meta.alloc_memory_id(), 1u64);
        assert_eq(meta.alloc_memory_id(), 2u64);
        assert_eq(meta.next_memory_id, 3u64);
    });

    it("alloc_session_id increments and returns unique IDs", || {
        ~meta = RagMeta.new(4096);
        assert_eq(meta.alloc_session_id(), 1u64);
        assert_eq(meta.alloc_session_id(), 2u64);
        assert_eq(meta.next_session_id, 3u64);
    });

    it("ID allocators are independent", || {
        ~meta = RagMeta.new(4096);
        meta.alloc_doc_id();     # -> 1
        meta.alloc_doc_id();     # -> 2
        meta.alloc_chunk_id();   # -> 1
        meta.alloc_memory_id();  # -> 1
        meta.alloc_session_id(); # -> 1

        assert_eq(meta.next_doc_id, 3u64);
        assert_eq(meta.next_chunk_id, 2u64);
        assert_eq(meta.next_memory_id, 2u64);
        assert_eq(meta.next_session_id, 2u64);
    });

    it("serialization round-trip preserves all fields", || {
        ~meta = RagMeta.new(4096);
        meta.doc_count = 10;
        meta.chunk_count = 50;
        meta.memory_count = 5;
        meta.session_count = 3;
        meta.next_doc_id = 11;
        meta.next_chunk_id = 51;
        meta.next_memory_id = 6;
        meta.next_session_id = 4;
        meta.active_model_id = 2;

        ~buf = ByteBuffer.new(256);
        meta.serialize(&buf);
        buf.reset_read();
        ~restored = RagMeta.deserialize(&buf, 4096).unwrap();

        assert_eq(restored.format_version, RAG_FORMAT_VERSION);
        assert_eq(restored.doc_count, 10u64);
        assert_eq(restored.chunk_count, 50u64);
        assert_eq(restored.memory_count, 5u64);
        assert_eq(restored.session_count, 3u64);
        assert_eq(restored.next_doc_id, 11u64);
        assert_eq(restored.next_chunk_id, 51u64);
        assert_eq(restored.next_memory_id, 6u64);
        assert_eq(restored.next_session_id, 4u64);
        assert_eq(restored.active_model_id, 2u32);
    });
});

# ==========================================================================
# RAG — ChunkInfo
# ==========================================================================

describe("ChunkInfo", |t| {
    it("serialize_meta produces 40 bytes", || {
        ~chunk = ChunkInfo {
            chunk_id: 42,
            parent_doc_id: 10,
            position_in_doc: 3,
            chunk_text: "hello world".to_string(),
            chunk_type: CHUNK_STRATEGY_SENTENCE,
            token_count: 15,
            overlap_start: 100,
            overlap_end: 120,
            created_at: 1700000000,
        };

        ~buf = ByteBuffer.new(48);
        chunk.serialize_meta(&buf);
        assert_eq(buf.written(), 40u64);
    });

    it("serialization round-trip preserves fields (except text)", || {
        ~chunk = ChunkInfo {
            chunk_id: 99,
            parent_doc_id: 7,
            position_in_doc: 5,
            chunk_text: "some text content".to_string(),
            chunk_type: CHUNK_STRATEGY_PARAGRAPH,
            token_count: 25,
            overlap_start: 200,
            overlap_end: 250,
            created_at: 1700001234,
        };

        ~buf = ByteBuffer.new(48);
        chunk.serialize_meta(&buf);
        buf.reset_read();
        ~restored = ChunkInfo.deserialize_meta(&buf).unwrap();

        assert_eq(restored.chunk_id, 99u64);
        assert_eq(restored.parent_doc_id, 7u64);
        assert_eq(restored.position_in_doc, 5u32);
        assert_eq(restored.chunk_type, CHUNK_STRATEGY_PARAGRAPH);
        assert_eq(restored.token_count, 25u32);
        assert_eq(restored.overlap_start, 200u32);
        assert_eq(restored.overlap_end, 250u32);
        assert_eq(restored.created_at, 1700001234i64);
        # chunk_text is not serialized in meta; deserialized as empty
        assert_eq(restored.chunk_text, "");
    });
});

# ==========================================================================
# RAG — DocumentInfo
# ==========================================================================

describe("DocumentInfo", |t| {
    it("serialize_meta produces 56 bytes", || {
        ~doc = DocumentInfo {
            doc_id: 1,
            title: "Test Doc".to_string(),
            source_uri: "file:///test.txt".to_string(),
            content_hash: 12345678,
            chunk_count: 5,
            total_tokens: 500,
            embedding_model_id: 1,
            ttl_seconds: 86400,
            created_at: 1700000000,
            updated_at: 1700000100,
        };

        ~buf = ByteBuffer.new(64);
        doc.serialize_meta(&buf);
        assert_eq(buf.written(), 56u64);
    });

    it("serialization round-trip preserves fixed fields", || {
        ~doc = DocumentInfo {
            doc_id: 42,
            title: "My Document".to_string(),
            source_uri: "https://example.com/doc".to_string(),
            content_hash: 98765432,
            chunk_count: 10,
            total_tokens: 1000,
            embedding_model_id: 3,
            ttl_seconds: 0,
            created_at: 1700000000,
            updated_at: 1700005000,
        };

        ~buf = ByteBuffer.new(64);
        doc.serialize_meta(&buf);
        buf.reset_read();
        ~restored = DocumentInfo.deserialize_meta(&buf).unwrap();

        assert_eq(restored.doc_id, 42u64);
        assert_eq(restored.content_hash, 98765432u64);
        assert_eq(restored.chunk_count, 10u32);
        assert_eq(restored.total_tokens, 1000u32);
        assert_eq(restored.embedding_model_id, 3u32);
        assert_eq(restored.ttl_seconds, 0u64);
        assert_eq(restored.created_at, 1700000000i64);
        assert_eq(restored.updated_at, 1700005000i64);
        # Variable fields not serialized
        assert_eq(restored.title, "");
        assert_eq(restored.source_uri, "");
    });
});

# ==========================================================================
# RAG — RagSearchResult
# ==========================================================================

describe("RagSearchResult", |t| {
    it("new creates result with defaults", || {
        ~result = RagSearchResult.new(1, 10, 0.85, "relevant text".to_string());
        assert_eq(result.source_id, 1u64);
        assert_eq(result.chunk_id, 10u64);
        assert_eq(result.parent_doc_id, 0u64);
        assert_true(result.score > 0.84 && result.score < 0.86);
        assert_eq(result.source_engine, ENGINE_TAG_RAG);
        assert_eq(result.source_text, "relevant text");
        assert_eq(result.context_before, "");
        assert_eq(result.context_after, "");
    });

    it("with_context sets surrounding context", || {
        ~result = RagSearchResult.new(1, 10, 0.85, "chunk".to_string());
        result = result.with_context("before text".to_string(), "after text".to_string());
        assert_eq(result.context_before, "before text");
        assert_eq(result.context_after, "after text");
    });

    it("with_parent sets parent doc ID", || {
        ~result = RagSearchResult.new(1, 10, 0.85, "chunk".to_string());
        result = result.with_parent(42);
        assert_eq(result.parent_doc_id, 42u64);
    });
});

# ==========================================================================
# RAG — RagFusionConfig
# ==========================================================================

describe("RagFusionConfig", |t| {
    it("default creates standard fusion config", || {
        ~config = RagFusionConfig.default();
        assert_true(config.vector_weight > 0.39 && config.vector_weight < 0.41);
        assert_true(config.fulltext_weight > 0.29 && config.fulltext_weight < 0.31);
        assert_true(config.graph_weight > 0.29 && config.graph_weight < 0.31);
        assert_true(config.memory_weight > 0.19 && config.memory_weight < 0.21);
        assert_eq(config.fusion_method, 0u8);  # WeightedSum
        assert_eq(config.rrf_k, 60u32);
        assert_eq(config.top_k, 10u32);
        assert_eq(config.max_context_tokens, 2048u32);
    });

    it("validate succeeds for default config", || {
        ~config = RagFusionConfig.default();
        assert_true(config.validate().is_ok());
    });

    it("validate fails when all weights are zero", || {
        ~config = RagFusionConfig.default();
        config.vector_weight = 0.0;
        config.fulltext_weight = 0.0;
        config.graph_weight = 0.0;
        assert_true(config.validate().is_err());
    });

    it("validate fails when top_k is zero", || {
        ~config = RagFusionConfig.default();
        config.top_k = 0;
        assert_true(config.validate().is_err());
    });

    it("validate succeeds with custom non-zero weights", || {
        ~config = RagFusionConfig.default();
        config.vector_weight = 1.0;
        config.fulltext_weight = 0.0;
        config.graph_weight = 0.0;
        assert_true(config.validate().is_ok());
    });
});

# ==========================================================================
# RAG — ScoredChunk
# ==========================================================================

describe("ScoredChunk", |t| {
    it("new creates scored chunk", || {
        ~sc = ScoredChunk.new(10, 5, 0.95, ENGINE_TAG_RAG);
        assert_eq(sc.chunk_id, 10u64);
        assert_eq(sc.doc_id, 5u64);
        assert_true(sc.score > 0.94 && sc.score < 0.96);
        assert_eq(sc.source_engine, ENGINE_TAG_RAG);
    });
});

# ==========================================================================
# RAG — ChunkMeta (MVCC)
# ==========================================================================

describe("ChunkMeta", |t| {
    it("new creates MVCC metadata", || {
        ~cm = ChunkMeta.new(42, 100);
        assert_eq(cm.chunk_id, 42u64);
        assert_eq(cm.txn_id_create, 100u64);
        assert_eq(cm.txn_id_expire, 0u64);
        assert_eq(cm.cmd_id_create, 0u32);
        assert_eq(cm.cmd_id_expire, 0u32);
    });

    it("clone produces independent copy", || {
        ~cm = ChunkMeta.new(42, 100);
        cm.txn_id_expire = 200;
        cm.cmd_id_create = 5;
        cm.cmd_id_expire = 10;

        ~copy = cm.clone();
        assert_eq(copy.chunk_id, 42u64);
        assert_eq(copy.txn_id_create, 100u64);
        assert_eq(copy.txn_id_expire, 200u64);
        assert_eq(copy.cmd_id_create, 5u32);
        assert_eq(copy.cmd_id_expire, 10u32);
    });
});

# ==========================================================================
# RAG — DocumentMeta (MVCC)
# ==========================================================================

describe("DocumentMeta", |t| {
    it("new creates MVCC metadata", || {
        ~dm = DocumentMeta.new(7, 500);
        assert_eq(dm.doc_id, 7u64);
        assert_eq(dm.txn_id_create, 500u64);
        assert_eq(dm.txn_id_expire, 0u64);
        assert_eq(dm.cmd_id_create, 0u32);
        assert_eq(dm.cmd_id_expire, 0u32);
    });

    it("clone produces independent copy", || {
        ~dm = DocumentMeta.new(7, 500);
        dm.txn_id_expire = 600;
        dm.cmd_id_create = 1;
        dm.cmd_id_expire = 2;

        ~copy = dm.clone();
        assert_eq(copy.doc_id, 7u64);
        assert_eq(copy.txn_id_create, 500u64);
        assert_eq(copy.txn_id_expire, 600u64);
        assert_eq(copy.cmd_id_create, 1u32);
        assert_eq(copy.cmd_id_expire, 2u32);
    });
});

# ==========================================================================
# RAG — MemorySearchParams
# ==========================================================================

describe("MemorySearchParams", |t| {
    it("default creates params with standard values", || {
        ~params = MemorySearchParams.default("hello world".to_string(), 10);
        assert_eq(params.query_text, "hello world");
        assert_eq(params.top_k, 10u32);
        assert_true(params.memory_type_filter.is_none());
        assert_true(params.session_id_filter.is_none());
        assert_eq(params.min_importance, 0.0);
        assert_false(params.include_expired);
        assert_true(params.recency_boost > 0.29 && params.recency_boost < 0.31);
        assert_true(params.importance_weight > 0.39 && params.importance_weight < 0.41);
        assert_true(params.similarity_weight > 0.59 && params.similarity_weight < 0.61);
    });

    it("with_type_filter sets memory type", || {
        ~params = MemorySearchParams.default("query".to_string(), 5);
        params = params.with_type_filter(MEMORY_TYPE_SEMANTIC);
        assert_true(params.memory_type_filter.is_some());
    });

    it("with_session_filter sets session ID", || {
        ~params = MemorySearchParams.default("query".to_string(), 5);
        params = params.with_session_filter(42);
        assert_true(params.session_id_filter.is_some());
    });
});

# ==========================================================================
# Cross-module: FNV-1a hash consistency
# ==========================================================================

describe("FNV-1a hash for RAG", |t| {
    it("produces non-zero hash", || {
        ~h = fnv1a_hash(&"document content");
        assert_ne(h, 0u64);
    });

    it("different inputs produce different hashes", || {
        ~h1 = fnv1a_hash(&"document A");
        ~h2 = fnv1a_hash(&"document B");
        assert_ne(h1, h2);
    });

    it("same input is deterministic", || {
        ~h1 = fnv1a_hash(&"test content");
        ~h2 = fnv1a_hash(&"test content");
        assert_eq(h1, h2);
    });
});
